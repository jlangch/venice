;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2023 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; ASCII table


(ns ascii-table)

;;           standard         double          bold          alpha  
;;
;;        +---+---+---+   ╔═══╤═══╤═══╗   ┏━━━┯━━━┯━━━┓   ABBBCBBBCBBBD
;; head   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   E   F   F   G
;;        +---+---+---+   ╠═══╪═══╪═══╣   ┣━━━┿━━━┿━━━┫   HIIIJIIIJIIIK
;; body   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   L   M   M   N
;;        +---+---+---+   ╟───┼───┼───╢   ┠───┼───┼───┫   OPPPQPPPQPPPR
;; body   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   L   M   M   N
;;        +---+---+---+   ╠═══╪═══╪═══╣   ┣━━━┿━━━┿━━━┫   STTTUTTTUTTTV
;; foot   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   W   X   X   Y
;;        +---+---+---+   ╚═══╧═══╧═══╝   ┗━━━┷━━━┷━━━┛   Z111211121113


;; https://www.charset.org/utf-8/10

                                 ;[-header--][-body][-footer--]
                                 ;0   4  7   11 14  18  22 25                      
(def border-chars                ;|---|--|---|--|---|---|--|---
  { :none                        "✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗"
    :standard                    "+-++|||+-++|||+-+++-++|||+-++"
    :standard-no-data            "+-++|||+-++|||✗✗✗✗+-++|||+-++"
    :standard-no-data-no-outside "✗✗✗✗✗|✗✗-+✗✗|✗✗✗✗✗✗-+✗✗|✗✗✗✗✗"
    :standard-no-outside         "✗✗✗✗✗|✗✗-+✗✗|✗✗-+✗✗-+✗✗|✗✗✗✗✗"
    :double                      "╔═╤╗║│║╠═╪╣║│║╟─┼╢╠═╪╣║│║╚═╧╝"
    :bold                        "┏━┯┓┃│┃┣━┿┫┃│┃┠─┼┨┣━┿┫┃│┃┗━┷┛"
    :alpha                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ123" } )


(def alignments #{:left :center :right})
(def overflow #{:newline :clip-left :clip-right :ellipsis-left :ellipsis-right})
(def modes #{:standard :double :bold :alpha})

(def min-col-width 1)
(def max-col-width 80)


(defn 
  ^{ :arglists '(
          "(ascii-table/render header data footer padding border-type)"
          "(ascii-table/render columns data padding)")
     :doc "Renders an ascii table."
     :examples (list
          """
          (ascii-table/render ["head 1" "head 2"] 
                              [["1 1" "1 2"]
                                ["2 1" "2 2"]] 
                              nil 
                              :double)
          """,
          """
          (ascii-table/render [{:header "head 1" }
                               {:header "head 2" }] 
                              [["1 1" "1 2"]
                               ["2 1" "2 2"]] 
                              nil 
                              :double)
          """ ) }
  render 

  ([header data footer padding border-type]
    (assert (keyword? border-type) "Invalid border type")
    (assert (some? (border-type border-chars)) "Invalid border type")
    (render-table (build-columns header data footer) data border-type padding ))

  ([columns data padding]
    (assert (keyword? border-type) "Invalid border type")
    (assert (some? (border-type border-chars)) "Invalid border type")
    render-table columns data border-type padding ))

(defn render-table [columns data border-type padding]
  (let [columns     (validate-columns columns)
        col-widths  (map :width columns)
        padding     (max 0 padding)
        bc          (let [chars (border-type border-chars)] 
                      (fn [i] (nth chars i)))]
    (try-with [sw (io/string-writer)]
      (when (header? columns)
        (println sw (render-border colwidths (bc 1) (bc 0) (bc 2) (bc 3)))
        (println sw (render-row col-widths (map :header columns) (bc 4) (bc 5) (bc 6)))
        (println sw (render-border col-widths (bc 8) (bc 7) (bc 9) (bc 10))))

      (flush sw)
      @sw)))

;;    (when-not (header? columns)
;;      (render-border columns))
;;
;;    ;; body
;;
;;    (when-not (footer? columns)
;;      (render-border columns))
;;
;;    (when (footer? columns)
;;      (render-border columns)
;;      (render-row columns)
;;      (render-border columns))))



(defn render-border [col-widths fill left middle right]
  (render-row col-widths (map #(str/repeat fill %) column-widths) left middle right))

(defn render-row [col-widths data left middle right]
  (str left (str/join middle data) right))

(defn header? [columns]
  (pos? (count (filter some? (map :header columns)))))

(defn footer? [columns]
  (pos? (count (filter (comp nil? not) (map :footer columns)))))

(defn validate-columns [columns]
  (map validate-column columns))

(defn validate-column [column]
  (let [min-width (max (:min-width column) min-col-width)
        max-width (min (:max-width column) max-col-width)
        width     (:width column)]
    { :header        (:header column)
      :footer        (:footer column)
      :header-align  ((or nil (:header-align column) :left) alignments :left)
      :data-align    ((or nil (:data-align column) :left) alignments :left)
      :footer-align  ((or nil (:footer-align column) :left) alignments :left)
      :overflow      ((or nil (:overflow column) :left) overflow :newline)
      :min-width     min-width
      :max-width     max-width
      :width         (min width (max width min-width) max-width)}))

(defn build-columns [header data footer]
  (let [cols (max (count header) 
                  (apply max (map count data))
                  (count footer))]
    (map (fn [c] (build-column (nth header c nil)
                               (nth footer c nil)
                               (nth data c nil)))
         (range cols))))

(defn build-column [header footer data]
  (let [width (max (max-line-length header) 
                   (max-line-length footer)
                   (max-line-length data))]
    { :header        header
      :footer        footer
      :width         width }))

(defn format-cell [text rows cols width align overflow padding]
  (-> (str/align width align overflow text)
      (expand-lines rows cols)
      (pad-lines padding)))

(defn pad-lines [text padding]
  (let [lines    (str/split-lines text)
        pad-str  (str/repeat " " padding)]
   (apply str (map #(str pad-str % pad-str) lines))))

(defn expand-lines [text total-lines width]
  (let [lines       (str/split-lines text)
        empty-line  (str/repeat " " width)
        add-count   (max 0 (- total-lines (count lines)))]
    (concat lines (repeat add-count empty-line))))

(defn max-line-length [text]
  (if (sequential? text)
    (->> (map max-line-length text)
         (apply max))
    (max 0 (apply max (map count (str/split-lines text))))))

(defn line-count [text]
  (count (str/split-lines text)))

(defn ends-with-lf [text]
  (str/ends-with? text *newline*))

(defn print-debug-text [text]
  (docoll #(println (str "⏵" % "⏴")) 
          (if (coll? text) text (str/split-lines text))))
