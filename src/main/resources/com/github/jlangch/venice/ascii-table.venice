;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2023 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; ASCII table


(ns ascii-table)

;;           standard         double          bold          alpha  
;;
;;        +---+---+---+   ╔═══╤═══╤═══╗   ┏━━━┯━━━┯━━━┓   ABBBCBBBCBBBD
;; head   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   E   F   F   G
;;        +---+---+---+   ╠═══╪═══╪═══╣   ┣━━━┿━━━┿━━━┫   HIIIJIIIJIIIK
;; body   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   L   M   M   N
;;        +---+---+---+   ╟───┼───┼───╢   ┠───┼───┼───┫   OPPPQPPPQPPPR
;; body   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   L   M   M   N
;;        +---+---+---+   ╠═══╪═══╪═══╣   ┣━━━┿━━━┿━━━┫   STTTUTTTUTTTV
;; foot   |   |   |   |   ║   │   │   ║   ┃   │   │   ┃   W   X   X   Y
;;        +---+---+---+   ╚═══╧═══╧═══╝   ┗━━━┷━━━┷━━━┛   Z111211121113


;; https://www.charset.org/utf-8/10

                                 ;[-header--][-body][-footer--]
                                 ;0   4  7   11 14  18  22 25                      
(def border-chars                ;|---|--|---|--|---|---|--|---
  { :none                        "✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗✗"
    :standard                    "+-++|||+-++|||+-+++-++|||+-++"
    :standard-no-data            "+-++|||+-++|||✗✗✗✗+-++|||+-++"
    :standard-no-data-no-outside "✗✗✗✗✗|✗✗-+✗✗|✗✗✗✗✗✗-+✗✗|✗✗✗✗✗"
    :standard-no-outside         "✗✗✗✗✗|✗✗-+✗✗|✗✗-+✗✗-+✗✗|✗✗✗✗✗"
    :double                      "╔═╤╗║│║╠═╪╣║│║╟─┼╢╠═╪╣║│║╚═╧╝"
    :bold                        "┏━┯┓┃│┃┣━┿┫┃│┃┠─┼┨┣━┿┫┃│┃┗━┷┛"
    :alpha                       "ABCDEFGHIJKLMNOPQRSTUVWXYZ123" } )


(def alignments #{:left :center :right})
(def overflows #{:newline :clip-left :clip-right :ellipsis-left :ellipsis-right})
(def borders (into #{} (keys border-chars)))

(def min-col-width 1)
(def max-col-width 80)
(def min-padding  0)
(def max-padding 10)


(defn 
  ^{ :arglists '(
          "(ascii-table/render header data footer padding border-type)"
          "(ascii-table/render columns data padding)")
     :doc "Renders an ascii table."
     :examples (list
          """
          (ascii-table/render ["head 1" "head 2"] 
                              [["1 1" "1 2"]
                                ["2 1" "2 2"]] 
                              nil 
                              :double
                              1)
          """,
          """
          (ascii-table/render [{:header {:text "head 1"}}
                               {:header {:text "head 2"}}] 
                              [["1 1" "1 2"]
                               ["2 1" "2 2"]] 
                              nil 
                              :double
                              1)
          """ ) }
  render 

  ([header data footer border padding]
    (assert (keyword? border) "Invalid border")
    (assert (some? (border border-chars)) "Invalid border")
    (render-table (build-columns header data footer) data border padding ))

  ([columns data border padding]
    (assert (keyword? border) "Invalid border")
    (assert (some? (border border-chars)) "Invalid border")
    render-table columns data border padding ))

(defn render-table [columns data border padding]
  (let [columns     (map validate-column columns)
        padding     (min-max min-padding max-padding padding)
        bc          (let [chars ((validate-border border) border-chars)] 
                      (fn [i] (nth chars i)))]
    (try-with [sw (io/string-writer)]
      (when (header? columns)
        (println sw (render-border-row columns padding (bc 1) (bc 0) (bc 2) (bc 3)))
        (docoll #(println sw %) (render-data-rows columns :header padding (header-cells columns) (bc 4) (bc 5) (bc 6)))
        (println sw (render-border-row columns padding (bc 8) (bc 7) (bc 9) (bc 10))))

      (flush sw)
      @sw)))

;;    (when-not (header? columns)
;;      (render-border columns))
;;
;;    ;; body
;;
;;    (when-not (footer? columns)
;;      (render-border columns))
;;
;;    (when (footer? columns)
;;      (render-border columns)
;;      (render-row columns)
;;      (render-border columns))))



(defn render-border-row [columns padding fill left middle right]
  (let [col-widths (map :width columns)
        pad        (str/repeat fill padding)]
    (render-row (map #(str/repeat fill %) col-widths) 
                (str left pad) (str pad middle pad) (str pad right))))

(defn render-data-rows [columns section padding cells left middle right]
  (let [col-widths     (map :width columns)
        pad            (str/repeat " " padding)
        cells          (format-row columns section cells)
        left           (str left pad)
        middle         (str pad middle pad)
        right          (str pad right)]
    (->> (apply map vector cells)  ;; reorder cell lines
         (map #(render-row % left middle right)))))

(defn render-row [cells left middle right]
  (str left (str/join middle cells) right))

(defn format-row [columns section cells]
  (->> (adjust-row-cells columns cells)
       (format-row-cells columns section)
       (adjust-row-cells-height columns)))

(defn adjust-row-cells [columns cells]
  (let [cells          (sublist cells 0 (count columns))  
        add-cell-count (max 0 (- (count columns) (count cells)))]
    (concat cells (repeat add-cell-count [ "" ]))))

(defn format-row-cells [columns section cells]
  (map-indexed (fn [i v] 
                 (let [col (nth columns i)]
                   (str/align (:width col) 
                              (-> col section :align) 
                              (-> col section :overflow)  
                              v))) 
                 cells))        

(defn adjust-row-cells-height [columns cells]
  (let [cells      (map str/split-lines cells)
        max-lines  (apply max (map count cells))]
    (map-indexed (fn [i v] 
                   (let [width (:width (nth columns i))]
                      (concat v (repeat (max 0 (- max-lines (count v))) 
                                        (str/repeat " " width)))))
                  cells)))

(defn header? [columns]
  (pos? (count (filter some? (map :header columns)))))

(defn footer? [columns]
  (pos? (count (filter (comp nil? not) (map :footer columns)))))

(defn build-columns [header data footer]
  (let [cols (max (count header) 
                  (apply max (map count data))
                  (count footer))]
    (map (fn [c] (build-column (nth header c nil)
                               (nth footer c nil)
                               (nth data c nil)))
         (range cols))))

(defn build-column [header footer data]
  (let [width (max (max-line-length header) 
                   (max-line-length footer)
                   (max-line-length data))]
    { :header        { :text header }
      :footer        { :text footer }
      :width         width }))

(defn max-line-length [text]
  (if (sequential? text)
    (->> (map max-line-length text)
         (apply max))
    (max 0 (apply max (map count (str/split-lines text))))))

(defn line-count [text]
  (count (str/split-lines text)))

(defn ends-with-lf [text]
  (str/ends-with? text *newline*))

(defn min-max [min-val max-val val]
  (min val (max val min-val) max-val))

(defn header-cells [columns]
  (map #(-> % :header :text) columns))

(defn footer-cells [columns]
  (map #(-> % :footer :text) columns))

(defn validate-column [column]
  (let [column    (or column {})
        min-width (max (:min-width column) min-col-width)
        max-width (min (:max-width column) max-col-width)
        width     (:width column)]
    { :header    {:text     (or (-> column :header :text) "")
                  :align    (validate-align (-> column :header :align))
                  :overflow (validate-overflow (-> column :header :overflow))}
      :body      {:align    (validate-align (-> column :body :align))
                  :overflow (validate-overflow (-> column :body :overflow))}
      :footer    {:text     (or (-> column :footer :text) "")
                  :align    (validate-align (-> column :footer :align))
                  :overflow (validate-overflow (-> column :footer :overflow))}                   
      :min-width min-width
      :max-width max-width
      :width     (min-max min-width max-width width) }))

(defn validate-align [align]
  (if (keyword? align) (align alignments :left) :left))

(defn validate-overflow [overflow]
  (if (keyword? overflow) (overflow overflows :newline) :newline))

(defn validate-border [border]
  (if (keyword? border) (border borders :double) :double))

(defn print-debug-text [text]
  (docoll #(println (str "⏵" % "⏴")) 
          (if (coll? text) text (str/split-lines text))))
