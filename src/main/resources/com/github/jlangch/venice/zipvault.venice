;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2023 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; ZIP Vault, AES-256 encrypted and password protected


(ns zipvault)

(import :org.repackage.net.lingala.zip4j.ZipFile)
(import :org.repackage.net.lingala.zip4j.io.outputstream.ZipOutputStream)
(import :org.repackage.net.lingala.zip4j.io.inputstream.ZipInputStream)
(import :org.repackage.net.lingala.zip4j.model.ZipParameters)
(import :org.repackage.net.lingala.zip4j.model.enums.EncryptionMethod)


(defn 
  ^{ :arglists '("(zipvault/zip out passphrase & entries)")
     :doc """
          Creates an AES-256 encrypted and password protected zip form the 
          entries and writes it to out. out may be a file or an output stream.

          An entry is given by a name and data. The entry data may be nil, a 
          bytebuf, a string, a file, an input stream, or a producer function. 
          An entry name with a trailing '/' creates a directory.

          Entry value types:

          | nil          | an empty file is written to the zip entry           |
          | bytebuf      | the bytes are written to the zip entry              |
          | string       | the string is written to the zip entry              |
          | file         | the content of the file is written to the zip entry |
          | input stream | the slurped input stream data is written to the \
                           zip entry |
          | function     | a producer function with a single output stream \
                           argument. All data written to the stream is written \
                           to the zip entry. The stream can be flushed but \
                           must not be closed! |

          **Passphrases:**

          The AES-256 algorithm requires a 256-bit key as input.
          One should use a passphrase with at least 128 bits of entropy 
          (that's roughly a 20-character passphrase of random 
          upper/lower/digits/symbols). 
          Less is dropping below general limits of safety, and more than 
          256 bits won't accomplish anything.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)
            (zipvault/zip (io/file "vault.zip") "my-password" "a.txt" "abc"))
          """,
          """
          (do 
            (load-module :zipvault)
            (zipvault/zip (io/file-out-stream "vault.zip")
                          "my-password"
                          "a.txt"             "abc"
                          "b.txt"             (bytebuf "def")))
          """,
          """
          (do 
            (load-module :zipvault)

            (let [c-tmp (io/file (io/tmp-dir) "c.txt")]
              (io/spit c-tmp "1234")
              (io/delete-file-on-exit c-tmp)

              ;; create "vault.zip"
              ;;          ├── a.txt
              ;;          ├── b.txt
              ;;          ├── c.txt
              ;;          ├── d.txt
              ;;          ├── e.txt
              ;;          ├── empty.txt
              ;;          └── xx
              ;;              └── f.txt
              (zipvault/zip 
                  (io/file "vault.zip")
                  "my-password"
                  "a.txt"               "abc"
                  "b.txt"               (bytebuf "def")
                  (io/file-name c-tmp)  c-tmp
                  "d.txt"               (io/string-in-stream "ghi")
                  "e.txt"               (fn [os] 
                                          (let [wr (io/wrap-os-with-buffered-writer os)]
                                            (println wr "200")
                                            (flush wr)))
                  "empty.txt"           nil
                  "xx/g.txt"            "jkl")))
          """ ) }

  zip [out passphrase & entries]

  { :pre [(or (io/file? out) (instance-of? :java.io.OutputStream out))
          (string? passphrase)] } 

  (let [params  (create-params)
        entries (apply hash-map entries)
        os      (if (io/file? out) (io/file-out-stream out :append false) out)]
    (zip-to-os params passphrase os entries)))


(defn 
  ^{ :arglists '("(zipvault/encrypted?)")
     :doc """
          Extracts a specific file from the zip file to the destination path.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)

            (zipvault/zip (io/file "vault.zip")
                          "my-password"
                          "a.txt" "abc"
                          "b.txt" "def"
                          "xx/c.txt" "ghi")

            (zipvault/extract (io/file "vault.zip")
                              "my-password"
                              "a.txt"
                              "."))
          """ ) }

  encrypted? [zip]

  { :pre [(io/file? zip)] }

  (assert (io/exists-file? zip))
 
  (. (. :ZipFile :new zip) :isEncrypted))


(defn 
  ^{ :arglists '("(zipvault/valid-zip-file? zip)")
     :doc """
          Returns true if the zip is a valid zip file else false.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)

            (zipvault/zip (io/file "vault.zip")
                          "my-password"
                          "a.txt" "abc"
                          "b.txt" "def")

            (zipvault/valid-zip-file? (io/file "vault.zip"))
          """ ) }

  valid-zip-file? [zip]

  { :pre [(io/file? zip)] }

  (. (. :ZipFile :new zip) :isValidZipFile))


(defn 
  ^{ :arglists '("(zipvault/extract-file zip password filename destpath)")
     :doc """
          Extracts a specific file from the zip file to the destination path.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)

            (zipvault/zip (io/file "vault.zip")
                          "my-password"
                          "a.txt" "abc"
                          "b.txt" "def")

            (zipvault/extract-file (io/file "vault.zip")
                                   "my-password"
                                   "a.txt"
                                   "."))
          """ ) }

  extract-file [zip passphrase filename destpath]

  { :pre [(io/file? zip)
          (string? passphrase)
          (string? filename)
          (or (string? destpath) (io/file? destpath))] }

  (assert (io/exists-file? zip))
  (assert (io/file-can-read? zip))
  (assert (io/exists-dir? destpath))
  (assert (io/file-can-write? destpath))

  (let [destpath (if (string? destpath) destpath (io/file-path destpath))
        zip      (. :ZipFile :new zip passphrase)]
    (. zip :extractFile filename destpath)))


(defn 
  ^{ :arglists '("(zipvault/extract-all zip passphrase destpath)")
     :doc """
          Extracts all files from the zip file to the destination path.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)

            (zipvault/zip (io/file "vault.zip")
                          "my-password"
                          "a.txt" "abc"
                          "b.txt" "def")

            (zipvault/extract-all (io/file "vault.zip")
                                  "my-password"
                                  "."))
          """ ) }

  extract-all [zip passphrase destpath]

  { :pre [(io/file? zip)
          (string? passphrase)
          (or (string? destpath) (io/file? destpath))] }

  (assert (io/exists-file? zip))
  (assert (io/file-can-read? zip))
  (assert (io/exists-dir? destpath))
  (assert (io/file-can-write? destpath))

  (let [destpath (if (string? destpath) destpath (io/file-path destpath))
        zip      (. :ZipFile :new zip passphrase)]
    (. zip :extractAll destpath)))


(defn 
  ^{ :arglists '("(zipvault/extract-file-data in passphrase filename)")
     :doc """
          Extracts a specific file from the zip file and returns it as binary 
          data. in may be a file or an input stream.

          Returns `nil` if the file does not exist.
          """
     :examples '(
          """
          (do 
            (load-module :zipvault)

            (zipvault/zip (io/file "vault.zip")
                          "my-password"
                          "a.txt" "abc"
                          "b.txt" "def")

            (zipvault/extract-file-data (io/file "vault.zip")
                                        "my-password"
                                        "a.txt"))
          """ ) }

  extract-file-data [in passphrase filename]

  { :pre [(or (io/file? in) (instance-of? :java.io.InputStream in))
          (string? passphrase)
          (string? filename)] }

  (let [is (if (io/file? in) (io/file-in-stream in) in)]
    (try-with [zis (. :ZipInputStream :new is passphrase)] 
      (loop [header (. zis :getNextEntry)]
        (if (nil? header)
          nil  ;; file not found
          (let [name (. header :getFileName)
                data (io/slurp zis :binary true)]
            (if (= filename name)
              data
              (recur (. zis :getNextEntry)))))))))
 


(defn- zip-to-os [params passphrase os entries]
  (try-with [zos (. :ZipOutputStream :new os passphrase)]  
    (docoll (fn [[k v]] (add-entry params zos k v)) entries)))

(defn- add-entry [params zos name value]
  (cond
     (str/ends-with? name "/")
       (add-entry-folder params zos name)

     (nil? value)
       (add-entry-data params zos name (bytebuf))

     (fn? value)
       (add-entry-producer params zos name value)

     (instance-of? :java.io.InputStream value)
       (add-entry-data params zos name (io/slurp value :binary true))

     (= (type value) :java.io.File)
       (add-entry-data params zos name (io/slurp value :binary true))

     (= (type value) :core/string)
       (add-entry-data params zos name (bytebuf value))

     (= (type value) :core/bytebuf)
       (add-entry-data params zos name value)

     :else
       (throw (ex :VncException 
                  """
                  Invalid zip entry value type ~(type value)! \
                  Expected a file, string, or bytebuf.
                  """))))

(defn- add-entry-folder [params zos name]
  (. params :setFileNameInZip name)
  (. zos :putNextEntry params)
  (. zos :closeEntry))

(defn- add-entry-data [params zos name data]
  (. params :setFileNameInZip name)
  (. zos :putNextEntry params)
  (. zos :write data)
  (. zos :closeEntry))

(defn- add-entry-producer [params zos name producer]
  (. params :setFileNameInZip name)
  (. zos :putNextEntry params)
  (producer zos)
  (. zos :closeEntry))

(defn- create-params []
  (doto (. :ZipParameters :new)
        (. :setEncryptFiles true)
        (. :setEncryptionMethod :AES)
        (. :setAesKeyStrength :KEY_STRENGTH_256)
        (. :setAesVersion :TWO)))
