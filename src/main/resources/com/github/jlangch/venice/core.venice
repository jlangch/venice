;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2025 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice core macros & functions


(ns core)

(import :java.io.PrintStream)
(import :java.io.Writer)


(def-dynamic *assertions* 0)  ; the number of successful assertions


(defmacro
  ^{ :arglists '("(comment & body)")
     :doc "Ignores body, yields nil"
     :examples '(
          """
          (comment
            (println 1)
            (println 5))
          """ ) }

   comment [& body] nil)


(defmacro
  ^{ :arglists '(
          "(assert expr)"
          "(assert expr message)")
     :doc """
          Evaluates expr and throws an `:AssertionException`
          exception if it does not evaluate to logical true.
          """
     :examples '(
          "(assert (= 3 (+ 1 2)))"
          "(assert (= 4 (+ 1 2)))" )
     :see-also '(
          "assert-false", "assert-eq", "assert-ne",
          "assert-throws", "assert-does-not-throw", "test/deftest") }

  assert

  ([expr]
    `(assert ~expr nil))

  ([expr message]
    `(try
       (if-not ~expr
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nExpression:\n" (pr-str '~expr))
                    "assert"
                    (:file (meta '~expr) "unknown")
                    (:line (meta '~expr) -1)
                    (:column (meta '~expr) -1)
                    (pr-str '~expr)))
         (do
           (set! core/*assertions* (inc core/*assertions*))
           true))
       (catch :AssertionException e
         (throw e))
       (catch :Exception e
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nUnexpected exception: " (type e)
                         "\nExpression:\n" (pr-str '~expr))
                    "assert"
                    (:file (meta '~expr) "unknown")
                    (:line (meta '~expr) -1)
                    (:column (meta '~expr) -1)
                    (pr-str '~expr)
                    e))))))


(defmacro
  ^{ :arglists '(
        "(assert-false expr)"
        "(assert-false expr message)")
     :doc
        """
        Evaluates expr and throws an `:AssertionException`
        exception if it does not evaluate to logical false.
        """
     :examples '(
        "(assert-false (= 3 (+ 1 3)))"
        "(assert-false (= 4 (+ 1 3)))" )
     :see-also '(
        "assert", "assert-eq", "assert-ne",
        "assert-throws", "assert-does-not-throw",
        "test/deftest") }

  assert-false

  ([expr]
    `(assert-false ~expr nil))

  ([expr message]
    `(try
       (if ~expr
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nExpression:\n" (pr-str '~expr))
                    "assert-false"
                    (:file (meta '~expr) "unknown")
                    (:line (meta '~expr) -1)
                    (:column (meta '~expr) -1)
                    (pr-str '~expr)))
         (do
           (set! core/*assertions* (inc core/*assertions*))
           true))
       (catch :AssertionException e
         (throw e))
       (catch :Exception e
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nUnexpected exception: " (type e)
                         "\nExpression:\n" (pr-str '~expr))
                    "assert-false"
                    (:file (meta '~expr) "unknown")
                    (:line (meta '~expr) -1)
                    (:column (meta '~expr) -1)
                    (pr-str '~expr)
                    e))))))


(defmacro
  ^{ :arglists '(
        "(assert-eq expected actual)"
        "(assert-eq expected actual message)")
     :doc
        """
        Assert that expected and actual are equal.
        Throws an `:AssertionException` exception if they are not equal.
        """
     :examples '(
        "(assert-eq 3 (+ 1 2))"
        "(assert-eq 4 (+ 1 2))" )
     :see-also '(
        "assert", "assert-false", "assert-ne",
        "assert-throws", "assert-does-not-throw", "test/deftest") }

  assert-eq

  ([expected actual]
    `(assert-eq ~expected ~actual nil))

  ([expected actual message]
    `(try
       (let [exp# ~expected
             act# ~actual]
         (if-not (= exp# act#)
           (throw (ex :AssertionException
                      (str "Assert failed."
                           (if (some? ~message) (str "\n" ~message) "")
                           "\nExpected: " (pr-str exp#)
                           "\nActual:   " (pr-str act#)
                           "\nExpression:\n" (pr-str '~actual))
                      "assert-eq"
                      (:file (meta '~expected) "unknown")
                      (:line (meta '~expected) -1)
                      (:column (meta '~expected) -1)
                      (pr-str '~actual)))
           (do
             (set! core/*assertions* (inc core/*assertions*))
             true)))
       (catch :AssertionException e
         (throw e))
       (catch :Exception e
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nUnexpected exception: " (type e)
                         "\nExpression:\n" (pr-str '~actual))
                    "assert"
                    (:file (meta '~expected) "unknown")
                    (:line (meta '~expected) -1)
                    (:column (meta '~expected) -1)
                    (pr-str '~actual)
                    e))))))


(defmacro
  ^{ :arglists '(
          "(assert-ne unexpected actual)"
          "(assert-ne unexpected actual message)")
     :doc """
          Assert that unexpected and actual are not equal.
          Throws an `:AssertionException` exception if they are equal.
          """
     :examples '(
          "(assert-ne :foo :bar)"
          "(assert-ne :foo :foo)" )
     :see-also '(
          "assert", "assert-false", "assert-eq",
          "assert-throws", "assert-does-not-throw", "test/deftest") }

  assert-ne

  ([unexpected actual]
    `(assert-ne ~unexpected ~actual nil))

  ([unexpected actual message]
    `(try
       (let [nexp# ~unexpected
             act# ~actual]
         (if (= nexp# act#)
           (throw (ex :AssertionException
                      (str "Assert failed."
                           (if (some? ~message) (str "\n" ~message) "")
                           "\nUnexpected: " (pr-str nexp#)
                           "\nActual:     " (pr-str act#)
                           "\nExpression:\n" (pr-str '~actual))
                      "assert-ne"
                      (:file (meta '~unexpected) "unknown")
                      (:line (meta '~unexpected) -1)
                      (:column (meta '~unexpected) -1)
                      (pr-str '~actual)))
           (do
             (set! core/*assertions* (inc core/*assertions*))
             true)))
       (catch :AssertionException e
         (throw e))
       (catch :Exception e
         (throw (ex :AssertionException
                    (str "Assert failed."
                         (if (some? ~message) (str "\n" ~message) "")
                         "\nUnexpected exception: " (type e)
                         "\nExpression:\n" (pr-str '~actual))
                    "assert"
                    (:file (meta '~unexpected) "unknown")
                    (:line (meta '~unexpected) -1)
                    (:column (meta '~unexpected) -1)
                    (pr-str '~actual)
                    e))))))


(defmacro
  ^{ :arglists '(
          "(assert-throws ex-type expr)"
          "(assert-throws ex-type expr message)")
     :doc """
          Evaluates expr and throws an `:AssertionException`
          exception if it does not throw the expected exception of type ex-type.
          """
     :examples '(
          "(assert-throws :VncException (/ 2 0))"
          "(assert-throws :VncException (/ 2 1))" )
     :see-also '(
          "assert", "assert-false", "assert-eq", "assert-ne",
          "assert-does-not-throw", "test/deftest") }

  assert-throws

  ([ex-type expr]
    `(assert-throws ~ex-type ~expr nil))

  ([ex-type expr message]
    `(try
       ~expr
       (throw :no-ex-thrown)
       (catch #(= % :no-ex-thrown) e
              (throw (ex :AssertionException
                         (str "Assert failed."
                              (if (some? ~message) (str "\n" ~message) "")
                              "\nExpected: " ~ex-type
                              "\nBut no exception has been thrown!"
                              "\nExpression:\n" (pr-str '~expr))
                         "assert-throws"
                         (:file (meta '~expr) "unknown")
                         (:line (meta '~expr) -1)
                         (:column (meta '~expr) -1)
                         (pr-str '~expr))))
       (catch ~ex-type e
              (set! core/*assertions* (inc core/*assertions*))
              true)
       (catch :java.lang.Exception e
              (throw (ex :AssertionException
                         (str "Assert failed."
                              (if (some? ~message) (str "\n" ~message) "")
                              "\nExpected: " ~ex-type
                              "\nCaught:   :" (class-name e)
                              "\nExpression:\n" (pr-str '~expr))
                         "assert-throws"
                         (:file (meta '~expr) "unknown")
                         (:line (meta '~expr) -1)
                         (:column (meta '~expr) -1)
                         (pr-str '~expr)))))))


(defmacro
  ^{ :arglists '(
          "(assert-throws-with-msg ex-type ex-msg-regexp expr)"
          "(assert-throws-with-msg ex-type ex-msg-regexp expr message)")
     :doc """
          Evaluates expr and throws an `:AssertionException`
          exception if it does not throw the expected exception of type ex-type.
          """
     :examples '(
          """(assert-throws-with-msg :VncException #"/ by zero" (/ 2 0))""" )
     :see-also '(
          "assert", "assert-false", "assert-eq", "assert-ne",
          "assert-does-not-throw", "test/deftest") }

  assert-throws-with-msg

  ([ex-type ex-msg-regexp expr]
    `(assert-throws-with-msg ~ex-type ~ex-msg-regexp ~expr nil))

  ([ex-type ex-msg-regexp expr message]
    `(try
       ~expr
       (throw :no-ex-thrown)
       (catch #(= % :no-ex-thrown) e
              (throw (ex :AssertionException
                         (str "Assert failed."
                              (if (some? ~message) (str "\n" ~message) "")
                              "\nExpected: " ~ex-type
                              "\nBut no exception has been thrown!"
                              "\nExpression:\n" (pr-str '~expr))
                         "assert-throws"
                         (:file (meta '~expr) "unknown")
                         (:line (meta '~expr) -1)
                         (:column (meta '~expr) -1)
                         (pr-str '~expr))))
       (catch ~ex-type e
              (if (match? (:message e) ~ex-msg-regexp)
                (do
                  (set! core/*assertions* (inc core/*assertions*))
                  true)
                (throw (ex :AssertionException
                           (str "Assert failed."
                                (if (some? ~message) (str "\n" ~message) "")
                                "\nExpected: #\"" ~ex-msg-regexp "\""
                                "\nActual:   " (pr-str (:message e))
                                "\nExpression:\n" (pr-str '~expr))
                           "assert-throws"
                           (:file (meta '~expr) "unknown")
                           (:line (meta '~expr) -1)
                           (:column (meta '~expr) -1)
                           (pr-str '~expr)))))
       (catch :java.lang.Exception e
              (throw (ex :AssertionException
                         (str "Assert failed."
                              (if (some? ~message) (str "\n" ~message) "")
                              "\nExpected: " ~ex-type
                              "\nCaught:   :" (class-name e)
                              "\nExpression:\n" (pr-str '~expr))
                         "assert-throws"
                         (:file (meta '~expr) "unknown")
                         (:line (meta '~expr) -1)
                         (:column (meta '~expr) -1)
                         (pr-str '~expr)))))))


(defmacro
  ^{ :arglists '(
          "(assert-does-not-throw expr)"
          "(assert-does-not-throw expr message)")
     :doc """
          Evaluates expr and throws an `:AssertionException`
          exception if it does throw any kind of exception.
          """
     :examples '(
          "(assert-does-not-throw (/ 2 1))"
          "(assert-does-not-throw (/ 2 0))" )
     :see-also '(
       "assert", "assert-false", "assert-eq", "assert-ne",
       "assert-throws", "test/deftest") }

  assert-does-not-throw

  ([expr]
    `(assert-does-not-throw ~expr nil))

  ([expr message]
    `(try
       ~expr
       (set! core/*assertions* (inc core/*assertions*))
       true
       (catch :java.lang.Exception e
              (throw (ex :AssertionException
                         (str "Assert failed."
                              (if (some? ~message) (str "\n" ~message) "")
                              "\nUnexpected exception: " (type e)
                              "\nExpression:\n" (pr-str '~expr))
                         "assert-does-not-throw"
                         (:file (meta '~expr) "unknown")
                         (:line (meta '~expr) -1)
                         (:column (meta '~expr) -1)
                         (pr-str '~expr)))))))


(defmacro
  ^{ :arglists '(
          "(defn name [args*] condition-map? expr*)"
          "(defn name ([args*] condition-map? expr*)+)")
     :doc """
          Same as `(def name (fn name [args*] condition-map? expr*))` or
          `(def name (fn name ([args*] condition-map? expr*)+))`
          """
     :examples '(
          "(defn sum [x y] (+ x y))"
          "(defn sum [x y] { :pre [(> x 0)] } (+ x y))"
          """
          (defn sum
            ([] 0)
            ([x] x)
            ([x y] (+ x y)))
          """)
     :see-also '("defn-" "fn" "def") }

   defn [name & forms]

   (if (vector? (first forms))
      `(def ~name (fn ~name ~(first forms) ~@(rest forms)))
      `(def ~name (fn ~name ~@forms))))


(defmacro
  ^{ :arglists '(
          "(defn- name [args*] condition-map? expr*)"
          "(defn- name ([args*] condition-map? expr*)+)")
     :doc "Same as `defn`, yielding non-public `def`"
     :examples '("(defn- sum [x y] (+ x y))")
     :see-also '("defn" "fn" "def") }

   defn- [name & forms]

   (list* `defn (with-meta name (assoc (meta name) :private true)) forms))


(defmacro
  ^{ :arglists '("(def- name expr)")
     :doc "Same as `def`, yielding non-public `def`"
     :examples '(
       "(def- x 100)"
       """
       (do
         (ns foo)
         (def- x 100)
         (ns bar)
         foo/x)  ; Illegal access of private symbol
       """)
     :see-also '("def") }

   def- [name & forms]

   (list* `def (with-meta name (assoc (meta name) :private true)) forms))


(defmacro
  ^{ :arglists '("(and x)" "(and x & next)")
     :doc "Ands the predicate forms"
     :examples '("(and true true)", "(and true false)", "(and)")
     :see-also '("or" "not") }

  and

  ([] true)
  ([x] x)
  ([x & next] `(let [cond# ~x]
                  (if cond# (and ~@next) cond#))))


(defmacro
  ^{ :arglists '("(or x)" "(or x & next)")
     :doc "Ors the predicate forms"
     :examples '("(or true false)", "(or false false)", "(or nil 100)", "(or)")
     :see-also '("and" "not") }

  or

  ([] false)
  ([x] x)
  ([x & next] `(let [cond# ~x]
                  (if cond# cond# (or ~@next)))))


(defn
  ^{ :arglists '("(not x)")
     :doc "Returns true if x is logical false, false otherwise."
     :examples '("(not true)"
                 "(not (== 1 2))")
     :see-also '("and" "or") }

  not [x]

  (if x false true))


(defmacro
  ^{ :arglists '("(cond & clauses)")
     :doc """
          Takes a set of test/expr pairs. It evaluates each test one at a time.
          If a test returns logical true, cond evaluates and returns the value
          of the corresponding expr and doesn't evaluate any of the other tests
          or exprs. `(cond)` returns `nil`.
          """
     :examples '(
          """
          (let [n 5]
            (cond
              (< n 0) "negative"
              (> n 0) "positive"
              :else "zero"))
          """ )
     :see-also '("condp" "case") }

  cond [& clauses]

  (when (not-empty? clauses)
    (list 'if (first clauses)
          (if (rest clauses)
              (second clauses)
              (throw (ex :VncException "cond requires an even number of forms")))
          (cons 'cond (rest (rest clauses))))))


(defmacro
  ^{ :arglists '("(condp pred expr & clauses)")
     :doc """
          Takes a binary predicate, an expression, and a set of clauses.

          Each clause can take the form of either:¶
          &ensp; `test-expr result-expr`¶
          &ensp; `test-expr :>> result-fn`¶
          Note `:>>` is an ordinary keyword.

          For each clause, (pred test-expr expr) is evaluated. If it returns
          logical true, the clause is a match. If a binary clause matches, the
          result-expr is returned, if a ternary clause matches, its result-fn,
          which must be a unary function, is called with the result of the
          predicate as its argument, the result of that call being the return
          value of condp. A single default expression can follow the clauses,
          and its value will be returned if no clause matches. If no default
          expression is provided and no clause matches, a VncException
          is thrown.
          """
     :examples '(
          """
          (condp some [1 2 3 4]
             #{0 6 7} :>> inc
             #{4 5 9} :>> dec
             #{1 2 3} :>> #(* % 10))
          """,
          """
          (condp some [-10 -20 0 10]
            pos?  1
            neg? -1
            (constantly true)  0)
          """ )
     :see-also '("cond" "case" )  }

  condp [pred expr & clauses]

  (let [gpred (gensym "pred__")
        gexpr (gensym "expr__")
        emit (fn emit [pred expr args]
               (let [[[a b c :as clause] more]
                       (split-at (if (== :>> (second args)) 3 2) args)
                       n (count clause)]
                 (cond
                  (== 0 n) `(throw (ex :VncException
                                       (str "No matching condp clause: " ~expr)))
                  (== 1 n) a
                  (== 2 n) `(if (~pred ~a ~expr)
                              ~b
                              ~(emit pred expr more))
                  :else (let [p (gensym "pred__")]
                           `(if-let [~p (~pred ~a ~expr)]
                              (~c ~p)
                              ~(emit pred expr more))))))]
    `(let [~gpred ~pred
           ~gexpr ~expr]
       ~(emit gpred gexpr clauses))))


(defmacro
  ^{ :arglists '("(case expr & clauses)")
     :doc """
          Takes an expression and a set of clauses. Each clause takes the form
          of test-constant result-expr
          """
     :examples '(
          """
          (case (+ 1 9)
            10  :ten
            20  :twenty
            30  :thirty
            :dont-know)
          """ )
     :see-also '("cond" "condp") }

     ;; rewrites to (let [e (+ 1 9)]
     ;;                (cond
     ;;                  (== e 10) :ten
     ;;                  (== e 20) :twenty
     ;;                  (== e 30) :thirty
     ;;                  :else :dont-know))

  case [expr & clauses]

  (let [expr-sym (gensym "expr_")
        default_ (if (odd? (count clauses)) (last clauses) nil)
        pairs_ (partition 2 (if (odd? (count clauses)) (butlast clauses) clauses))]
    `(let [~expr-sym ~expr]
       (cond
         ~@(mapcat (fn [[test-const_ result-expr_]]
                       `((== ~expr-sym ~test-const_) ~result-expr_))
                      pairs_)
         :else ~default_))))


(defmacro
  ^{ :arglists '(
          "(if-not test then else)",
          "(if-not test then)")
     :doc """
          Evaluates test. If logical false, evaluates and returns then
          expression, otherwise else expression, if supplied, else nil.
          """
     :examples '(
          "(if-not (== 1 2) 100 0)",
          "(if-not false 100)",
          "(if-not true 100)")
     :see-also '("if" "if-let" "when" "when-not" "when-let")  }

  if-not

  ([test then] `(if-not ~test ~then nil))
  ([test then else] `(if (not ~test) ~then ~else)))


(defmacro
  ^{ :arglists '("(when test & body)")
     :doc "Evaluates test. If logical true, evaluates body in an implicit do."
     :examples '("(when (== 1 1) true)")
     :see-also '("when-not" "when-let" "if" "if-not" "if-let") }

  when [test & body]

  `(if ~test (do ~@body)))


(defmacro
  ^{ :arglists '("(when-not test & body)")
     :doc "Evaluates test. If logical false, evaluates body in an implicit do."
     :examples '("(when-not (== 1 2) true)")
     :see-also '("when" "when-let" "if" "if-not" "if-let") }

  when-not [test & body]

  `(if ~test nil (do ~@body)))


(defmacro
  ^{ :arglists '("(coalesce args*)")
     :doc """
          Returns nil if all of its arguments are nil, otherwise it returns
          the first non nil argument. The arguments are evaluated lazy.
          """
     :examples '(
         "(coalesce)",
         "(coalesce 2)"
         "(coalesce nil 1 2)") }

  coalesce
    ([] nil)
    ([x] x)
    ([x & rest] `(let [c# ~x] (if (core/not (core/nil? c#)) c# (core/coalesce ~@rest)))))


(defmacro
  ^{ :arglists '(
          "(if-let bindings then)"
          "(if-let bindings then else)")
     :doc """
          bindings is a vector with 2 elements: binding-form test.¶
          If test is true, evaluates then with binding-form bound to the value
          of test, if not, yields else
          """
     :examples '(
          """
          (if-let [value (* 100 2)]
            (str "The expression is true. value=" value)
            (str "The expression is false."))
          """ )
     :see-also '("when-let" "let") }

  if-let

  ([bindings then]
     `(if-let ~bindings ~then nil))
  ([bindings then else]
    (let [form (first bindings) tst (second bindings)]
      `(let [temp# ~tst]
        (if temp#
          (let [~form temp#]
            ~then)
          ~else)))))


(defmacro
  ^{ :arglists '("(when-let bindings & body)")
     :doc """
          bindings is a vector with 2 elements: binding-form test.
          
          If test is true, evaluates the body expressions with binding-form
          bound to the value of test, if not, yields nil
          """
     :examples '(
          """
          (when-let [value (* 100 2)]
            (str "The expression is true. value=" value))
          """ )
     :see-also '("if-let" "let") }

  when-let [bindings & body]

  (let [form (first bindings) tst (second bindings)]
    `(let [temp# ~tst]
      (when temp#
        (let [~form temp#]
          ~@body)))))


(defmacro
  ^{ :arglists '("(dotimes bindings & body)")
     :doc "Repeatedly executes body with name bound to integers from 0 through n-1."
     :examples '("""(dotimes [n 3] (println (str "n is " n)))""" )
     :see-also '("repeat" "repeatedly" "doseq" "list-comp") }

  dotimes [bindings & body]

  (let [i (first bindings)
        n (second bindings)]
      `(let [k# (long ~n)]
          (loop [~i 0]
            (when (< ~i k#)
                ~@body
                (recur (inc ~i)))))))


(defmacro
  ^{ :arglists '("(while test & body)")
     :doc """
          Repeatedly executes body while test expression is true. Presumes some
          side-effect will cause test to become false/nil. Returns nil.
          """
     :examples '(
          """
          (do
            (def a (atom 5))
            (while (pos? @a)
              (println @a)
              (swap! a dec)))
          """ ) }

  while [test & body]

  `(loop []
      (when ~test
        ~@body
        (recur))))


(defmacro
  ^{ :arglists '("(doto x & forms)")
     :doc """
          Evaluates x then calls all of the methods and functions with the value
          of x supplied at the front of the given arguments. The forms are
          evaluated in order. Returns x.
          """
     :examples '(
          """
          (doto (. :java.util.HashMap :new)
                (. :put :a 1)
                (. :put :b 2))
          """ ) }

  doto [x & forms]

  (let [gx (gensym)]
    `(let [~gx ~x]
       ~@(map (fn [f] `(~(first f) ~gx ~@(rest f))) forms)
       ~gx)))


(defmacro
  ^{ :arglists '("(-> x & forms)")
     :doc """
          Threads the x through the forms. Inserts x as the second item in the
          first form, making a list of it if it is not a list already.¶
          If there are more forms, inserts the first form as the second item in
          second form, etc.
          """
     :examples '(
          """
          (-> 5 (+ 3) (/ 2) (- 1))
          """
          """
          (do
            (def person
                 {:name "Peter Meier"
                  :address {:street "Lindenstrasse 45"
                            :city "Bern"
                            :zip 3000}})

            (-> person :address :street))
          """ )
     :see-also '("->>" "-<>" "as->") }

  -> [x & forms]

  (loop [x x, forms forms]
    (if forms
      (let [form (first forms)
            threaded (if (list? form)
                       `(~(first form) ~x ~@(empty-to-nil (rest form)))
                       (list form x))]
        (recur threaded (empty-to-nil (rest forms))))
      x)))


(defmacro
  ^{ :arglists '("(->> x & forms)")
     :doc """
          Threads the x through the forms. Inserts x as the last item in the
          first form, making a list of it if it is not a list already. If there
          are more forms, inserts the first form as the last item in second
          form, etc.
          """
     :examples '(
          "(->> 5 (+ 3) (/ 32) (- 1))"
          """
          (->> [ {:a 1 :b 2} {:a 3 :b 4} {:a 5 :b 6} {:a 7 :b 8} ]
               (map (fn [x] (get x :b)))
               (filter (fn [x] (> x 4)))
               (map inc))))
          """ )
     :see-also '("->" "-<>" "as->") }

  ->> [x & forms]

   (loop [x x, forms forms]
     (if forms
       (let [form (first forms)
             threaded (if (list? form)
                         `(~(first form) ~@(empty-to-nil (rest form)) ~x)
                         (list form x))]
         (recur threaded (empty-to-nil (rest forms))))
       x)))


(defmacro
  ;; serves the macro -<>. Inserts x in place of '<>' in form

  -<>* [form x]

  (let [substitute-pos (fn [form_] (replace {'<> x} form_))
        count-pos (fn [form_] (count (filter #(== % '<>) form_)))
        c (cond
            (or (set? form) (list? form) (vector? form)) (count-pos form)
            (map? form) (count-pos (mapcat concat form))
            :otherwise 0)]
    (cond
      (not (== c 1))   (throw (ex :VncException "-<> macro: one position per form is required."))
      (symbol? form)   `(~form ~x)
      (vector? form)   (substitute-pos form)
      (map? form)      (apply hash-map (mapcat substitute-pos form))
      :else            `(~(first form) ~@(substitute-pos (rest form))))))

(defmacro
  ^{ :arglists '("(-<> x & forms)")
     :doc """
          Threads the x through the forms. Inserts x at position of the `<>`
          symbol of the first form, making a list of it if is not a list
          already. If there are more forms, inserts the first form at position
          of the `<>` symbol in second form, etc.
          """
     :examples '(
          """
          (-<> 5
               (+ <> 3)
               (/ 2 <>)
               (- <> 1))
          """ )
     :see-also '("->" "->>" "as->") }

  -<>

  ([x] x)
  ([x form] `(-<>* ~form ~x))
  ([x form & forms] `(-<> (-<> ~x ~form) ~@forms)))


(defmacro
  ^{ :arglists '("(as-> expr name & forms)")
     :doc """
          Binds name to expr, evaluates the first form in the lexical context
          of that binding, then binds name to that result, repeating for each
          successive form, returning the result of the last form. This allows a
          value to thread into any argument position.
          """
     :examples '(
          """
          ; allows to use arbitrary positioning of the argument
          (as-> [:foo :bar] v
                (map name v)
                (first v)
                (str/subs v 1))
          """
          """
          ; allows the use of if statements in the thread
          (as-> {:a 1 :b 2} m
                (update m :a #(+ % 10))
                (if true
                  (update m :b #(+ % 10))
                  m))
          """ )
     :see-also '("->" "->>" "-<>") }

  as-> [expr name & forms]

  `(let [~name ~expr
         ~@(core/interleave (core/repeat (core/count forms) name) (core/butlast forms))]
      ~(if (core/empty? forms)
           name
           (core/last forms))))


(defmacro
  ^{ :arglists '("(cond-> expr & clauses)")
     :doc """
          Takes an expression and a set of test/form pairs. Threads expr
          (via `->`) through each form for which the corresponding test
          expression is true. Note that, unlike cond branching, `cond->`
          threading does not short circuit after the first true test
          expression.

          It is useful in situations where you want selectively assoc,
          update, or dissoc something from a map.

          ```venice
          (cond-> m
            (some-pred? q)  (assoc :key :value))
          ```
          """
     :examples '(
          """
          (cond-> 1        ; we start with 1
            true inc       ; the condition is true so (inc 1) => 2
            false (* 42)   ; the condition is false so the operation is skipped
            (= 2 2) (* 3)) ; (= 2 2) is true so (* 2 3) => 6
          """ )
     :see-also '("cond->>") }

  cond-> [expr & clauses]

  (assert (even? (core/count clauses)))
  (let [g     (core/gensym)
        steps (core/map (fn [[test step]] `(if ~test (-> ~g ~step) ~g))
                        (core/partition 2 clauses))]
    `(let [~g ~expr
           ~@(core/interleave (core/repeat (core/count steps) g) (core/butlast steps))]
       ~(if (core/empty? steps)
          g
          (core/last steps)))))

(defmacro
  ^{ :arglists '("(cond->> expr & clauses)")
     :doc """
          Takes an expression and a set of test/form pairs. Threads expr
          (via `->>`) through each form for which the corresponding test
          expression is true.  Note that, unlike cond branching, `cond->>`
          threading does not short circuit after the first true test
          expression.
          """
     :examples '(
          """
          (cond->> 1       ; we start with 1
            true inc       ; the condition is true so (inc 1) => 2
            false (* 42)   ; the condition is false so the operation is skipped
            (= 2 2) (* 3)) ; (= 2 2) is true so (* 3 2) => 6
          """ )
     :see-also '("cond->") }

  cond->> [expr & clauses]

  (assert (even? (count clauses)))
  (let [g (core/gensym)
        steps (core/map (fn [[test step]] `(if ~test (->> ~g ~step) ~g))
                        (core/partition 2 clauses))]
    `(let [~g ~expr
           ~@(core/interleave (core/repeat (core/count steps) g) (core/butlast steps))]
       ~(if (core/empty? steps)
          g
          (core/last steps)))))

(defmacro
  ^{ :arglists '("(some-> expr & forms)")
     :doc """
          When expr is not nil, threads it into the first form (via `->`),
          and when that result is not nil, through the next etc.
          """
     :examples '(
          """
          (some-> {:y 3 :x 5}
                  :y
                  (- 2))
          """
          """
          (some-> {:y 3 :x 5}
                  :z
                  (- 2))
          """ )
     :see-also '("some->>") }

  some-> [expr & forms]

  (let [g     (core/gensym)
        steps (core/map (fn [step] `(if (core/nil? ~g) nil (-> ~g ~step)))
                        forms)]
    `(let [~g ~expr
           ~@(core/interleave (core/repeat g) (core/butlast steps))]
       ~(if (core/empty? steps)
          g
          (core/last steps)))))


(defmacro
  ^{ :arglists '("(some->> expr & forms)")
     :doc """
          When expr is not nil, threads it into the first form (via `->>`),
          and when that result is not nil, through the next etc.
          """
     :examples '(
          """
          (some->> {:y 3 :x 5}
                   :y
                   (- 2))
          """
          """
          (some->> {:y 3 :x 5}
                   :z
                   (- 2))
          """ )
     :see-also '("some->") }

  some->> [expr & forms]

  (let [g     (core/gensym)
        steps (core/map (fn [step] `(if (core/nil? ~g) nil (->> ~g ~step)))
                        forms)]
    `(let [~g ~expr
           ~@(core/interleave (core/repeat g) (core/butlast steps))]
       ~(if (core/empty? steps)
          g
          (core/last steps)))))


(defmacro
  ^{ :arglists '("(list-comp seq-exprs body-expr)")
     :doc """
          List comprehension. Takes a vector of one or more binding-form or
          collection-expr pairs, each followed by zero or more modifiers, and
          yields a collection of evaluations of expr.

          Supported modifiers are: `:when` predicate

          List comprehensions are used when multiple lists have to be processed
          down to a single list and some filtering has to be applied.
          """
     :examples '(
          "(list-comp [x (range 10)] x)"
          "(list-comp [x (range 5)] (* x 2))"
          "(list-comp [x (range 10) :when (odd? x)] x)"
          "(list-comp [x (range 10) :when (odd? x)] (* x 2))"
          "(list-comp [x (seq \"abc\") y [0 1 2]] [x y])")
     :see-also '("mapcat" "doseq" "dotimes") }

  list-comp [[binding_ coll-expr & bindings] body-expr]

  (cond
    (not binding_)
      `(list ~body-expr)

    (== :when binding_)
      `(when ~coll-expr (list-comp ~bindings ~body-expr))

    :else
      `(mapcat (fn [~binding_] (list-comp ~bindings ~body-expr))
                ~coll-expr)))


(defmacro
  ^{ :arglists '("(doseq seq-exprs & body)")
     :doc """
          Repeatedly executes body (presumably for side-effects) with
          bindings and filtering as provided by `list-comp`. Does not
          retain the head of the sequence. Returns `nil`.

          Supported modifiers are: `:when` predicate
          """
     :examples '(
          "(doseq [x (range 10)] (print x))"
          "(doseq [x (range 10)] (print x) (print \"-\"))"
          "(doseq [x (range 5)] (print (* x 2)))"
          "(doseq [x (range 10) :when (odd? x)] (print x))"
          "(doseq [x (range 10) :when (odd? x)] (print (* x 2)))"
          "(doseq [x [1 2 3] y [1 2 3]] (println [x y]))"
          "(doseq [[x y] [[0 1] [1 2]]] (println [x y]))"
          "(doseq [[k v] {:a 1 :b 2}] (println [k v]))",
          """
          (doseq [[c vals] (group-by count ["a" "as" "asd" "aa" "asdf" "qwer"])]
            (println c vals))
          """)
     :see-also '("list-comp" "dotimes") }

  doseq [[binding_ coll-expr & bindings] & body]

  (cond
    (not binding_)
      `(do ~@body nil)

    (== :when binding_)
      `(when ~coll-expr (doseq ~bindings ~@body) nil)

    :else
      `(do
         (map (fn [~binding_] (doseq ~bindings ~@body)) ~coll-expr)
         nil)))


(defmacro
  ^{ :arglists '("(letfn [fnspec*] exprs*)")
     :doc
       """
       Takes a vector of function specs and a body, and generates a set of
       bindings of functions to their names. All of the names are available
       in all of the definitions of the functions, as well as the body.

       fnspec ==> `(fname [params*] exprs)` or `(fname ([params*] exprs)+)`

       `(letfn [(foo [] "abc")] (foo))`

       is equivalent to

       `(let [foo (fn [] "abc")] (foo))`
       """
     :examples '(
       """
       (letfn [(foo [] "abc")
               (bar [] (str (foo) "def"))]
          (bar))
       """)
     :see-also '("let") }

  letfn [fnspecs & body]

  `(let ~(vector* (interleave (map first fnspecs)
                              (map #(cons `fn %) fnspecs)))
      ~@body))


(defmacro
  ^{ :arglists '("(time expr)")
     :doc "Evaluates expr and prints the time it took. Returns the value of expr."
     :examples '("(time (+ 100 200))")
     :see-also '("dorun") }

  time [expr]

  `(let [start#   (nano-time)
         ret#     ~expr
         end#     (nano-time)
         elapsed# (- end# start#)]
     (printf "Elapsed time: %s%n" (format-nano-time elapsed# :precision 2))
     ret#))


(defmacro
  ^{ :arglists '("(perf expr warmup-iterations test-iterations)")
     :doc """
          Performance test with the given expression.

          Runs the test in 3 phases:

             1. Runs the expr in a warmup phase to allow the HotSpot compiler
                to do optimizations.
             2. Runs the garbage collector.
             3. Runs the expression under profiling. Returns nil.

          After a test run metrics data can be obtained with (prof :data-formatted)
          """
     :examples '(
          """
          (do
            (perf (+ 120 200) 12000 1000)
            (println (prof :data-formatted)))
          """ )
     :see-also '("time" "prof") }

  perf [expr warmup-iterations test-iterations]

  `(do
     (prof :on)
     (prof :clear)
     (let [fn-perf-warmup# (fn _warmup [] (dorun ~warmup-iterations ~expr))
           fn-perf-gc#     (fn _warmup-gc [] (do (dorun 2 (gc)) (sleep 1000)))
           fn-perf-test#   (fn _test [] (dorun ~test-iterations ~expr))]
       (fn-perf-warmup#)
       (fn-perf-gc#)
       (prof :clear)
       (fn-perf-test#)
       (prof :off))
     nil))


(defmacro
  ^{ :arglists '("(with-sh-dir dir & forms)")
     :doc "Sets the directory for use with sh, see sh for details."
     :examples '("""(with-sh-dir "/tmp" (sh "ls" "-l"))""")
     :see-also '("sh", "with-sh-env", "with-sh-throw") }

  with-sh-dir [dir & forms]

  `(binding [*sh-dir* ~dir] (do ~@forms)))


(defmacro
  ^{ :arglists '("(with-sh-env env & forms)")
     :doc "Sets the environment for use with `sh`."
     :examples '("""(with-sh-env {"NAME" "foo"} (sh "ls" "-l"))""")
     :see-also '("sh", "with-sh-dir", "with-sh-throw") }

  with-sh-env [env & forms]

  `(binding [*sh-env* ~env] (do ~@forms)))


(defmacro
  ^{ :arglists '("(with-sh-throw forms)")
     :doc """
          Shell commands executed within a `with-sh-throw` context throw an
          exception if the spawned shell process returns an exit code other
          than 0.

          For use with `sh`, see sh for details. `with-sh-throw` can be
          nested.
          """
     :examples '("""(with-sh-throw (sh "ls" "-l"))""")
     :see-also '("sh", "with-sh-env", "with-sh-dir") }

  with-sh-throw [& forms]

  `(binding [*sh-throw-ex* true] (do ~@forms)))


(defmacro
  ^{ :arglists '("(with-out-str & forms)")
     :doc """
          Evaluates exprs in a context in which `*out*` is bound to a capturing
          output stream. Returns the string created by any nested printing
          calls. `with-out-str` can be nested.
          """
     :examples '("""(with-out-str (println "a string"))""")
     :see-also '("with-err-str") }

  with-out-str [& forms]

  `(binding [*out* (io/capturing-print-stream)]
     (do ~@forms)
     (deref *out*)))


(defmacro
  ^{ :arglists '("(with-err-str & forms)")
     :doc """
          Evaluates exprs in a context in which `*err*` is bound to a capturing
          output stream. Returns the string created by any nested printing
          calls. `with-err-str` can be nested.
          """
     :examples '("""(with-err-str (println *err* "a string"))""")
     :see-also '("with-out-str") }

  with-err-str [& forms]

  `(binding [*err* (io/capturing-print-stream)]
     (do ~@forms)
     (deref *err*)))


(defmacro
  ^{ :arglists '(
          "(with-jmx-connection url ssl env & forms)")
     :doc """
          Establishes a JMX connection to access MBeans of a local or remote 
          Java VM.

          Without an explicit JMX connection local MBeans will be accessed. This
          is the default setup.

          It is strongly recommended to configure SSL and authentication for the
          JMX connector!

          ¶
          ¶
          **Authentication**

          To enable authentication, the server JVM must be started with these 
          system properties:

          ```
          -Dcom.sun.management.jmxremote
          -Dcom.sun.management.jmxremote.port=9999
          -Dcom.sun.management.jmxremote.authenticate=true
          -Dcom.sun.management.jmxremote.ssl=false
          -Dcom.sun.management.jmxremote.password.file=/path/to/jmxremote.password
          -Dcom.sun.management.jmxremote.access.file=/path/to/jmxremote.access
          ```

          Example password file (jmxremote.password):

          ```
          admin secret
          ```

          Set file permissions strictly:

          ```
          chmod 600 /path/to/jmxremote.password
          ```

          Example access file (jmxremote.access):

          ```
          admin readwrite
          ````
          
          ¶
          ¶
          **SSL**

          Step 1: Generate Keystore and Truststore

          For both client and server, the same keystore can be used for testing:

          ```
          keytool -genkeypair -alias jmxssl -keyalg RSA -keystore jmx.keystore -storepass changeit -validity 365
          ```

          Export the certificate:

          ```
          keytool -export -alias jmxssl -keystore jmx.keystore -file jmx.cer -storepass changeit
          ```

          Create a truststore (to trust the server’s certificate):

          ```
          keytool -import -alias jmxssl -file jmx.cer -keystore jmx.truststore -storepass changeit -noprompt
          ```

          Step 2: JMX Server Configuration with SSL

          ```
          -Dcom.sun.management.jmxremote
          -Dcom.sun.management.jmxremote.port=9999
          -Dcom.sun.management.jmxremote.rmi.port=9999
          -Dcom.sun.management.jmxremote.ssl=true
          -Dcom.sun.management.jmxremote.authenticate=true
          -Dcom.sun.management.jmxremote.access.file=/path/to/jmxremote.access
          -Dcom.sun.management.jmxremote.password.file=/path/to/jmxremote.password

          # SSL configuration
          -Djavax.net.ssl.keyStore=/path/to/jmx.keystore
          -Djavax.net.ssl.keyStorePassword=changeit
          -Djavax.net.ssl.trustStore=/path/to/jmx.truststore
          -Djavax.net.ssl.trustStorePassword=changeit
          ```
          """
     :examples '(
          """
          (with-jmx-connection "service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi"
                               nil
                               nil
            (let [name (mbean/object-name "java.lang:type=OperatingSystem")]
              (mbean/info name)))
          """
          """
          ;; example with ssl and username/password authentication
          (with-jmx-connection "service:jmx:rmi:///jndi/rmi://localhost:9999/jmxrmi"
                               { "javax.net.ssl" true
                                 "javax.net.ssl.trustStore" "/path/to/jmx.truststore" 
                                 "javax.net.ssl.trustStorePassword" "changeit" }
                               { "jmx.remote.credentials" ["username" "password"] }
            (let [name (mbean/object-name "java.lang:type=OperatingSystem")]
              (mbean/info name)))
          """
          """
          ;; local access (without explicit JMX connection)
          (let [name (mbean/object-name "java.lang:type=OperatingSystem")]
            (mbean/info name))
          """ ) }

  with-jmx-connection [url env & forms]

  `(binding [*jmx-connection* (mbean/create-jmx-connection ~url ~env)] 
     (do ~@forms)))


(defmacro
  ^{ :arglists '("(delay & body)")
     :doc """
          Takes a body of expressions and yields a Delay object that will invoke
          the body only the first time it is forced (with `force` or
          `deref` / `@`), and will cache the result and return it on all
          subsequent force calls.
          """
     :examples '(
          """
          (do
            (def x (delay (println "working...") 100))
            (deref x))
          """)
    :see-also '("deref" "force" "realized?" "delay?" "memoize") }

  delay [& body]

  `(delay* (fn [] (do ~@body))))


(defprotocol
  ^{ :doc """
          Defines a protocol to customize the `toString` and/or the `compareTo`
          function of custom datatypes.

          Definition:

          ```
          (defprotocol Object
            (toString [this] (to-str false this))
            (compareTo [this other] (compare this other)))
          ```

          `compareTo` returns a negative integer, zero, or a positive integer as
          *this* value is less than, equal to, or greater than the *other*
          value.
          """
     :examples '(
          """
          (do
            (deftype :point [x :long, y :long]
              Object
                (toString [this] (str/format "[%s %s]" (:x this) (:y this)))
                (compareTo [self other] (. (:x self) :compareTo (:x other))))

            ; custom `toString`
            (println "toString:" (point. 1 2))

            ; custom `compareTo`: sort by 'x' ascending
            (println "compareTo:"
                     (sort [(point. 2 100) (point. 3 101) (point. 1 102)])))
          """ )
     :see-also '("defprotocol", "deftype") }

  Object

  (toString [this] (to-str false this))
  (compareTo [this other] (compare this other)))


(defn
  ^{ :arglists '("(loaded-modules)")
     :doc "Returns the names of the loaded modules."
     :see-also '("load-module") }

  loaded-modules [] core/*loaded-modules*)


(defn
  ^{ :arglists '("(print & xs)", "(print os & xs)")
     :doc """
          Prints the values `xs` to the stream that is the current value
          of `*out*` or to the passed stream `os` that must be a subclass of
          either `:java.io.PrintStream` or `:java.io.Writer`.

          Prints the values, separated by spaces if there is more than one.
          `print` and `println` print in a human readable form.

          If the printed data needs to be read back by a Venice reader use the
          functions `pr` and `prn` instead.

          Returns `nil`.
          """
     :examples '(
         "(print [10 20 30])",
         "(print *out* [10 20 30])",
         "(print *err* [10 20 30])" )
     :see-also '("println" "printf" "newline") }

  print

  ([] nil)
  ([x]
    (when-not (or (instance-of? :PrintStream x) (instance-of? :Writer x))
      (io/print *out* (str (coalesce x "nil")))
      nil))
  ([& xs]
    (let [ch  (first xs)
          fmt (fn [zs] (str/join " " (map #(str (coalesce % "nil")) zs)))]
      (if (or (instance-of? :PrintStream ch) (instance-of? :Writer ch))
         (io/print ch (fmt (rest xs)))
         (io/print *out* (fmt xs)))
      nil)))


(defn
  ^{ :arglists '("(printf fmt & args)", "(printf os fmt & args)")
     :doc """
          Without output stream prints formatted output as per format to the
          stream that is the current value of `*out*`.
          With a stream prints to that stream that must be a subclass of either
          `:java.io.PrintStream` or `:java.io.Writer`.

          Prints like `print` and `println` in a human readable form.

          Returns `nil`.

          See: [Java Formatter](https://docs.oracle.com/javase/8/docs/api/java/util/Formatter.html)
          """
     :examples '(
          """(printf "%s: %d" "abc" 100)"""
          """(printf "line 1: %s%nline 2: %s%n" "123" "456")"""
          """(printf "%d%%" 42)"""
          """(printf *out* "%s: %d" "abc" 100)"""
          """(printf *err* "%s: %d" "abc" 100)""" )
      :see-also '("print" "println" "newline") }

  printf [& xs]
    (let [ch (first xs)]
      (if (or (instance-of? :PrintStream ch) (instance-of? :Writer ch))
         (let [fmt (second xs), args (rest (rest xs))]
           (print ch (apply str/format fmt args)))
         (let [fmt (first xs), args (rest xs)]
           (print *out* (apply str/format fmt args)))))
    nil)


(defn
  ^{ :arglists '("(println & xs)", "(println os & xs)")
     :doc """
          Prints the values `xs` to the stream that is the current value
          of `*out*` or to the passed output stream `os` if given followed by
          a `(newline)`. The passed stream must be a subclass of either
          `:java.io.PrintStream` or `:java.io.Writer`.

          Prints the values, separated by spaces if there is more than one.
          `print` and `println` print in a human readable form.

          If the printed data needs to be read back by a Venice reader use the
          functions `pr` and `prn` instead.

          Returns `nil`.
          """
     :examples '(
          "(println 200)"
          "(println [10 20 30])"
          "(println *out* 200)"
          "(println *err* 200)" )
      :see-also '("print" "printf" "newline") }

  println

  ([]
    (newline))
  ([& xs]
    (apply print xs)
    (let [ch (first xs)]
      (if (or (instance-of? :PrintStream ch) (instance-of? :Writer ch))
        (newline ch)
        (newline)))
    nil))


(defn
  ^{ :arglists '("(pr & xs)", "(pr os & xs)")
     :doc """
          Prints the values `xs` to the output stream that is the current value
          of `*out*` or to the passed output stream `os` if given. The passed
          stream must be a subclass of either `:java.io.PrintStream` or
          `:java.io.Writer`.

          Prints the values, separated by spaces if there is more than one.
          `pr` and `prn` print in a way that objects can be read by the reader.

          Returns `nil`.
          """
     :examples '(
         """(pr "hello")""",
         """(pr {:foo "hello" :bar 34.5})""",
         """(pr ['a :b "\\n" #\\space "c"])"""
         "(pr *out* [10 20 30])",
         "(pr *err* [10 20 30])" )
     :see-also '("prn" "newline" "pr-str") }

  pr

  ([] nil)
  ([x]
    (when-not (or (instance-of? :PrintStream x) (instance-of? :Writer x))
      (io/print *out* (pr-str x))
      nil))
  ([& xs]
    (let [ch  (first xs)
          fmt (fn [zs] (str/join " " (map pr-str zs)))]
      (if (or (instance-of? :PrintStream ch) (instance-of? :Writer ch))
        (io/print ch (fmt (rest xs)))
        (io/print *out* (fmt xs)))
      nil)))


(defn
  ^{ :arglists '("(prn & xs)", "(prn os & xs)")
     :doc """
          Prints the values `xs` to the output stream that is the current value
          of `*out*` or to the passed stream `os` if given followed by
          a `(newline)`. The passed stream must be a subclass of either
          `:java.io.PrintStream` or `:java.io.Writer`.

          Prints the values, separated by spaces if there is more than one.
          `pr` and `prn` print in a way that objects can be read by the reader.

          Returns `nil`.
          """
     :examples '(
          """(prn "hello")""",
          """(prn {:foo "hello" :bar 34.5})""",
          """(prn ['a :b "\\n" #\\space "c"])"""
          "(prn *out* [10 20 30])"
          "(prn *err* [10 20 30])" )
      :see-also '("pr" "newline" "pr-str") }

  prn

  ([]
    (newline))
  ([& xs]
    (apply pr xs)
    (let [ch (first xs)]
      (if (or (instance-of? :PrintStream ch) (instance-of? :Writer ch))
        (newline ch)
        (newline)))
    nil))


(defn
  ^{ :arglists '("(newline)", "(newline os)")
     :doc """
          Without arg writes a platform-specific newline to the output channel
          that is the current value of `*out*`. With arg writes a newline to the
          passed stream that must be a subclass of either `:java.io.PrintStream`
          or `:java.io.Writer`.

          Returns `nil`.
          """
     :examples '(
          "(newline)"
          "(newline *out*)"
          "(newline *err*)" )
      :see-also '("print" "println" "printf") }

  newline

  ([]   (newline *out*))
  ([os] (io/print os *newline*)))


(defn
  ^{ :arglists '("(flush)", "(flush os)")
     :doc """
          Without arg flushes the output stream that is the current value
          of `*out*`. With arg flushes the passed stream that must be a subclass
          of either `:java.io.OutputStream` or `:java.io.Writer`.

          Returns `nil`.
          """
     :examples '(
          "(flush)"
          "(flush *out*)"
          "(flush *err*)" )
      :see-also '("io/flush", "io/close") }

  flush

  ([]   (io/flush *out*))
  ([os] (io/flush os)))


(defn
  ^{ :arglists '("(read-line)" "(read-line is)")
     :doc """
          Without arg reads the next line from the stream that is the current
          value of `*in*`. With arg reads the next line from the passed stream
          that must be a subclass of `:java.io.BufferedReader`.

          Returns `nil` if the end of the stream is reached.
          """
     :examples '(
          """
          (try-with [rd (io/buffered-reader "1\\n2\\n3\\n4")]
            (println (read-line rd))
            (println (read-line rd)))
          """ )
     :see-also '("read-char")  }

  read-line

  ([]   (io/read-line *in*))
  ([is] (io/read-line is)))


(defn
  ^{ :arglists '("(read-char)" "(read-char is)")
     :doc """
          Without arg reads the next char from the stream that is the current
          value of `*in*`. With arg reads the next char from the passed stream
          that must be a subclass of `:java.io.Reader`.

          Returns `nil` if the end of the stream is reached.
          """
     :examples '(
          """
          (try-with [rd (io/buffered-reader "1234")]
            (println (read-char rd))
            (println (read-char rd)))
          """ )
     :see-also '("read-line") }

  read-char

  ([]   (io/read-char *in*))
  ([is] (io/read-char is)))


(defn
  ^{ :arglists '("(complement f)")
     :doc """
          Takes a fn f and returns a fn that takes the same arguments as f,
          has the same effects, if any, and returns the opposite truth value.
          """
     :examples '("(complement even?)"
                 "(filter (complement even?) '(1 2 3 4))") }

  complement

  [f] (fn
         ([] (not (f)))
         ([x] (not (f x)))
         ([x y] (not (f x y)))
         ([x y & zs] (not (apply f x y zs)))))


(defn
  ^{ :arglists '("(rf-first)")
     :doc "Returns a reducing function for a transducer that returns the first item."
     :examples '(
          "(transduce (filter number?) rf-first [false 1 2])"
          "(transduce identity rf-first [nil 1 2])")
     :see-also '(
          "rf-last" "rf-any?" "rf-every?") }

  rf-first

  ([] nil)
  ([x] x)
  ([x y] (reduced y)))


(defn
  ^{ :arglists '("(rf-last)")
     :doc "Returns a reducing function for a transducer that returns the last item."
     :examples '(
          "(transduce (filter number?) rf-last [false 1 2])"
          "(transduce identity rf-last [1 2 1.2])")
     :see-also '(
          "rf-first" "rf-any?" "rf-every?") }

  rf-last

  ([] nil)
  ([x] x)
  ([x y] y))


(defn
  ^{ :arglists '("(rf-any? pred)")
     :doc """
          Returns a reducing function for a transducer that returns true if the
          predicate is true for at least one the items, false otherwise.
          """
     :examples '(
          "(transduce (filter number?) (rf-any? pos?) [true -1 1 2 false])")
     :see-also '(
          "rf-first" "rf-last" "rf-every?") }

  rf-any?

  [pred] (fn
           ([] false)
           ([x] x)
           ([x y] (if (pred y) (reduced true) x))))


(defn
  ^{ :arglists '("(rf-every? pred)")
     :doc """
          Returns a reducing function for a transducer that returns true if the
          predicate is true for all the items, false otherwise.
          """
     :examples '(
          "(transduce (filter number?) (rf-every? pos?) [1 2 3])")
     :see-also '(
          "rf-first" "rf-last" "rf-any?") }

  rf-every?

  [pred] (let [empty_ (volatile true)]
            (fn
              ([] false)
              ([x] x)
              ([x y] (do
                       (let [r (if @empty_ (pred y) (and x (pred y)))]
                         (reset! empty_ false)
                         (if r r (reduced r))))))))


(defn
  ^{ :arglists '("(constantly x)")
     :doc """
          Returns a function that takes any number of arguments and returns
          always the value x.
          """
     :examples '(
          """
          (do
            (def fix (constantly 10))
            (fix 1 2 3)
            (fix 1)
            (fix ))
          """)
     :see-also '("repeat" "repeatedly" "dotimes")  }

  constantly

  [x] (fn [& args] x))


(defn
  ^{ :arglists '("(zipmap keys vals)")
     :doc """
          Returns a map with the keys mapped to the corresponding vals.

          To create a list of tuples from two or more lists use¶
          `(map list '(1 2 3) '(4 5 6))`.
          """
     :examples '(
          "(zipmap [:a :b :c :d :e] [1 2 3 4 5])"
          "(zipmap [:a :b :c] [1 2 3 4 5])") }

  zipmap [keys vals]

  (loop [omap (ordered-map)
         ks (seq keys)
         vs (seq vals)]
     (if (and (not-empty? ks) (not-empty? vs))
        (recur (assoc omap (first ks) (first vs))
               (rest ks)
               (rest vs))
        omap)))


(defn
  ^{ :arglists '("(memoize f)")
     :doc """
          Returns a memoized version of a referentially transparent function.

          Note:¶
          Use memoization for expensive calculations. If used with fast
          calculations it has the opposite effect and can slow it down
          actually!
          """
     :examples '(
          """
          (do
            (def fibonacci
              (memoize
                (fn [n]
                  (cond
                    (<= n 0) 0
                    (< n 2) 1
                    :else (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))))

            (time (fibonacci 25)))
          """,
          """
          (do
            (defn test [a b]
              (println (str "calculating a=" a ", b=" b))
              (+ a b))

            (def test-memo (memoize test))

            (test-memo 1 1)
            (test-memo 1 2)
            (test-memo 1 1)
            (test-memo 1 2)
            (test-memo 1 1))
          """ )
     :see-also '("delay") }

  memoize

  [f]
    (let [mem_ (atom {})]
      (fn [& args]
        (if-let [e (find @mem_ args)]
          (val e)
          (let [ret (apply f args)]
            (swap! mem_ assoc args ret)
            ret)))))


(defn
  ^{ :arglists '("(trampoline f)" "(trampoline f & args)")
     :doc """
          trampoline can be used to convert algorithms requiring mutual
          recursion without stack consumption. Calls f with supplied args,
          if any. If f returns a fn, calls that fn with no arguments, and
          continues to repeat, until the return value is not a fn, then
          returns that non-fn value.

          Note that if you want to return a fn as a final value, you must
          wrap it in some data structure and unpack it after trampoline
          returns.
          """
     :examples '(
          """
          (do
            (defn factorial
              ([n] #(factorial n 1N))
              ([n acc] (if (< n 2)
                       acc
                       #(factorial (dec n) (* acc n)))))

            (trampoline (factorial 20)))
          """ ) }

  trampoline

  ([f]
    (loop [f f]
      (let [ret (f)]
        (if (fn? ret)
          (recur ret)
          ret))))
  ([f & args]
     (trampoline #(apply f args))))


(defn-
  ^{ :arglists '("(walk inner outer form)")
     :doc """
          Traverses form, an arbitrary data structure. inner and outer are
          functions. Applies inner to each element of form, building up a
          data structure of the same type, then applies outer to the result.

          Do not call this function directly use core/postwalk or
          `core/prewalk` instead.
          """ }

  walk [inner outer form]

  (cond
    (list? form) (outer (apply list (map inner form)))
    (map-entry? form) (outer (map-entry (inner (key form)) (inner (val form))))
    (coll? form) (outer (into (empty form) (map inner form)))
    :else (outer form)))


(defn
  ^{ :arglists '("(postwalk f form)")
     :doc """
          Performs a depth-first, post-order traversal of form. Calls f on
          each sub-form, uses f's return value in place of the original.
          """
     :examples '(
          """
          (postwalk (fn [x] (println "Walked:" (pr-str x)) x)
                    '(1 2 {:a 1 :b 2}))
          """)
     :see-also '("prewalk") }

  postwalk [f form]

  (core/walk (partial postwalk f) f form))


(defn
  ^{ :arglists '("(prewalk f form)")
     :doc """
          Performs a depth-last, pre-order traversal of form. Calls f on
          each sub-form, uses f's return value in place of the original.
          """
     :examples '(
          """
          (prewalk (fn [x] (println "Walked:" (pr-str x)) x)
                   '(1 2 {:a 1 :b 2}))
          """)
     :see-also '("postwalk") }

  prewalk [f form]

  (core/walk (partial prewalk f) identity (f form)))


(defn
  ^{ :arglists '("(prewalk-replace smap form)")
     :doc """
          Recursively transforms form by replacing keys in smap with their
          values. Like `replace` but works on any data structure. Does
          replacement at the root of the tree first.
          """
     :examples '(
          "(prewalk-replace {:a 1 :b 2} [:a :b])"
          "(prewalk-replace {:a 1 :b 2} [:a :b :c])"
          "(prewalk-replace {:a 1 :b 2} [:a :b [:a :b] :c])"
          "(prewalk-replace {'x 1 'y 2} '(+ x y))")
     :see-also '("postwalk-replace" "prewalk") }

  prewalk-replace [smap form]
  
  (core/prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))


(defn
  ^{ :arglists '("(postwalk-replace smap form)")
     :doc """
          Recursively transforms form by replacing keys in smap with their
          values. Like `replace` but works on any data structure. Does
          replacement at the leaves of the tree first.

          `postwalk-replace` is the equivalent of *Common Lisp's* `sublis`
          function.
          """
     :examples '(
          "(postwalk-replace {:a 1 :b 2} [:a :b])"
          "(postwalk-replace {:a 1 :b 2} [:a :b :c])"
          "(postwalk-replace {:a 1 :b 2} [:a :b [:a :b] :c])"
          "(postwalk-replace {'x 1 'y 2} '(+ x y))")
     :see-also '("prewalk-replace" "postwalk") }

  postwalk-replace [smap form]
    (core/postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))


(defn
  ^{ :arglists '("(macroexpand-all form)")
     :doc "Recursively expands all macros in the form."
     :examples '(
          "(macroexpand-all '(and true true))",
          "(macroexpand-all '(and true (or true false) true))"
          "(macroexpand-all '(let [n 5] (cond (< n 0) -1 (> n 0) 1 :else 0)))" )
     :see-also '("macroexpand" "defmacro") }

  macroexpand-all [form]

  ;;(core/prewalk (fn [x] (if (list? x) (macroexpand x) x)) form))
  (macroexpand-all* form))


(defn
  ^{ :arglists '("(repl?)")
     :doc "Returns true if running within a REPL."
     :examples '("(repl?)") }

  repl? [] (= :repl *run-mode*))



;; ---------------------------------------------------------------------------
;; taps
;; ---------------------------------------------------------------------------

(defonce ^:private tapset (atom #{}))
(defonce ^:private tapque (queue 1024))

(defonce ^:private tap-loop
  (delay (thread #(loop []
                    (let [t (take! tapque)]
                      (doseq [tap @tapset]
                        (try
                          (tap t)
                          (catch :Exception e)))
                      (recur)))
                 "venice-tap-loop")))


(defn 
  ^{ :arglists '("(add-tap f)")
     :doc """
          adds f, a fn of one argument, to the tap set. This function will be 
          called with anything sent via `tap>`.

          This function may (briefly) block, and will never impede calls to 
          `tap>`, but blocking indefinitely may cause tap values to be dropped.

          Remember f in order to `remove-tap`
          """
     :examples '(
          """
          (add-tap println)
          """)
     :see-also '(
          "remove-tap"
          "clear-taps"
          "tap>") }

  add-tap [f]

  (assert (fn? f))
  (force tap-loop)
  (swap! tapset conj f)
  nil)


(defn 
  ^{ :arglists '("(remove-tap f)")
     :doc """
          Remove f from the tap set.
          """
     :examples '(
          """
          (do
            (add-tap prn)
            (remove-tap prn))
          """)
     :see-also '(
          "add-tap" 
          "tap>") }

  remove-tap [f]

  (assert (fn? f))
  (swap! tapset disj f)
  nil)


(defn 
  ^{ :arglists '("(clear-taps)")
     :doc """
          Removes all tap sets.
          """
     :examples '(
          """
          (do
            (add-tap prn)
            (clear-taps))
          """)
     :see-also '(
          "remove-tap"
          "add-tap" 
          "tap>") }

 clear-taps []
 
 (reset! tapset #{})
 nil)


(defn 
  ^{ :arglists '("(tap> x)")
     :doc """
          Sends x to any taps. Will not block. Returns true if there was room 
          in the queue, false if not (x is dropped).
          """
     :examples '(
          """
          (do
            (add-tap prn)
            (tap> {:foo "hello" :bar 34.5}))
          """)
     :see-also '(
          "add-tap", 
          "remove-tap", 
          "clear-taps") }

  tap> [x]

  (force tap-loop)
  (offer! tapque x))



;; ---------------------------------------------------------------------------
;; registered services  (service registry)
;; ---------------------------------------------------------------------------

(defn
  ^{ :arglists '(
       "(service name method & args)")
     :doc
       """
       Calls a service with the specified name from the Venice's service
       registry.

       Venice's service registry is used with application scripting scenarios
       where multiple external services must be made available to Venice.
       E.g.: the service registry can be used to register an application's
       *Spring Framework* services and make them discoverable by a Venice
       script.

       Example:

       ```
       Venice venice = new Venice();

       venice.getServiceRegistry()
            .register("Calculator", new Calculator())
            .registerServiceDiscovery(new TestServiceDiscovery());

       long r = (Long)venice.eval("(service :Calculator :multiply 10 20)");
       venice.eval("(service :Logger :log (version))");
       ```

       while `Calculator` and `TestServiceDiscovery` are defined as:

       ```
       public static class TestServiceDiscovery implements IServiceDiscovery {
           @Override public Object lookup(final String name) {
               if (name == null) {
                   throw new IllegalArgumentException("A service name must not be null");
               }
               else if (name.equals("Logger")) {
                 return logger;
               }
               else {
                 throw new VncException("Service " + name + " is not registered");
               }
           }
           private final Logger logger = new Logger();
       }

       public class Calculator {
         public long multiply(long v1, long v2) {
           return v1 * v2;
         }
       }

       public static class Logger {
         public void log(String message) {
           System.out.println(message);
         }
       }
       ```
       """
     :examples '(
       "(service :UserService :find \"Smith\" \"John\")")
     :see-also '(
       "service?") }

  service [name method & args]

  ;; Note: the service registry lookup function returns a java.lang.Object
  ;; hence the objects formal type is :java.lang.Object, actually we
  ;; need its real type for Java reflective method invocation under a
  ;; sandbox. `remove-formal-type` solves the problem
  (let [s (remove-formal-type (. *service-registry* :lookup (keyword name)))]
    (apply . s method args)))


(defn
  ^{ :arglists '("(service? name)")
     :doc "Returns true if the named service exists otherwise false "
     :examples '("(service? :UserService")
     :see-also '( "service") }

  service? [name]

  (. *service-registry* :exists (keyword name)))



;; ---------------------------------------------------------------------------
;; message box
;; ---------------------------------------------------------------------------

(defn
  ^{ :arglists '(
        "(print-msg-box type text)")
     :doc
        """
        Prints an info, warning, or error message box.

        Info message are printed to `*out*` while warning and error messages
        are printed `*err*`. The text is wrapped at word boundaries to 70
        chars per line. Linefeeds in the text are honored.

        The type classifies the message and is one of: `:info`, `:warn`, or
        `:error`.
        """
      :examples '(
        "(print-msg-box :info (str/lorem-ipsum :chars 180))" ) }

  print-msg-box [type text]

  (let [[ostream title] (case type
                          :info   [*out* "Info: "   ]
                          :warn   [*err* "Warning: "]
                          :error  [*err* "Error: "  ]
                                  [*out* "Info: "   ])
        horz-line       (apply str (repeat 70 "-"))
        offset          (count title)
        indent          (apply str (repeat offset " "))
        block-len       (- 70 offset)
        block           (str/split-lines (str/wrap text
                                                   :maxlen block-len
                                                   :line-wrap :break-word))]
    (println ostream horz-line)
    (println ostream (str title (first block)))
    (docoll #(println ostream (str indent %)) (rest block))
    (println ostream horz-line)))


;; ---------------------------------------------------------------------------
;; doc support
;; ---------------------------------------------------------------------------

