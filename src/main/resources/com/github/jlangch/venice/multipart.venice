;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Multipart 
;;;;
;;;; RFC:  https://www.rfc-editor.org/rfc/rfc1867


(ns multipart)

(load-module :mimetypes)


(defonce ^:private boundary-value (str (rand-bigint 128)))

(defonce ^:private nl "\r\n")
(defonce ^:private nl-buf (bytebuf-from-string nl))



(defn 
  ^{ :arglists '(
        "(render parts)" )
     :doc
        """
        Renders a map of named parts as *multipart/form-data* format.
        
        The part name must be a string and the part data may be of type:
        * string
        * string ("file:/user/foo/image.png" to reference a file)
        * map (describing a part as :name, :mimetype, :data (string or bytebuf), and an optional charset) elements)
        * io/file
        * all other part data types are converted with `(str data)` to a string

        Returns a bytebuf with all the rendered parts.

        ```
        POST / HTTP/1.1
        HOST: host.example.com
        Connection: Keep-Alive
        Content-Type: multipart/form-data; boundary=12345

        --12345
        Content-Disposition: form-data; name="notes"

        Lorem ipsum ...
        --12345
        Content-Disposition: form-data; name="foo"; filename="foo.json"
        Content-Type: application/json; charset=utf-8

        content of foo.xjson
        --12345
        Content-Disposition: form-data; name="image"; filename="picture.png"
        Content-Type: image/png

        content of picture.jpg
        --12345--
        ```

        See [multipart/form-data](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types#multipartform-data)
        """
     :examples '(
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (->> (m/render { "Part-1" "xxxxxxxxxxx" 
                           "Part-2" "yyyyyyyyyyy"})
               (bytebuf-to-string)
               (println)))
        """,
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (m/render { "Part-1" "xxxxxxxxxxx"
                      "Part-2" "file:/user/foo/image.png"
                      "Part-3" (io/file "/user/foo/image.png")
                      "Part-4" { :filename  "data.xml"
                                 :mimetype  "application/xml"
                                 :charset   :utf-8
                                 :data      "<user><name>foo</name></user>" }})
        """ )
     :see-also '( 
        "multipart/parse"
        "multipart/http-content-type-header" ) }

  render [parts]

  (assert (map? parts))
  (assert (not (empty? parts)))

  (try-with [os (io/bytebuf-out-stream)]
    ;; render parts
    (doseq [[name value] parts] (render-part name value os))
    
    ;; close boundary
    (spit-string os (closing-boundary) nl)
    
    @os))


(defn 
  ^{ :arglists '(
        "(parse buffer boundary)" )
     :doc
        """
        Parses a multipart bytebuf.
        """
     :examples '(
        """
        (do
          (load-module :multipart ['multipart :as 'm])
          (load-module :hexdump ['hexdump :as 'h])

          (defn render []
            (m/render { "Part-1" "xxxxxxxxxxx"
                        "Part-4" { :filename  "data.xml"
                                   :mimetype  "application/xml"
                                   :charset   :utf-8
                                   :data      "<user><name>foo</name></user>" }}))          
          (-> (render)
              (m/parse (m/boundary))))

          ;; Returns a list of part maps:
          ;; ( { :name "Part-1" 
          ;;     :filename nil 
          ;;     :mimetype nil 
          ;;     :charset nil 
          ;;     :data [120 ... 120]  ;; shortened for brevity
          ;;     :data-len 11 } 
          ;;   { :name "Part-4" 
          ;;     :filename "data.xml" 
          ;;     :mimetype "application/xml" 
          ;;     :charset "utf-8" 
          ;;     :data [60 ... 62]   ;; shortened for brevity
          ;;     :data-len 29 })
        """ )
     :see-also '( 
        "multipart/render"
        "multipart/http-content-type-header" ) }
        
  parse [buffer boundary]

  (assert (bytebuf? buffer))
  (assert (string? boundary))
  (assert (pos? (count boundary)))
  
  (map parse-part (parse-parts-buffers buffer boundary)))


(defn 
  ^{ :arglists '(
        "(http-content-type-header)" )
     :doc
        """
        Returns the HTTP content type header value for *multipart/form-data*
        HTTP requests.

        The `multipart/render` function uses this boundary.
        
        E.g:  Content-Type: multipart/form-data; boundary=1234567890N
        """
     :examples '(
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (m/http-content-type-header))
        """ )
     :see-also '( 
        "multipart/render" 
        "multipart/parse" ) }

  http-content-type-header []

  (str "multipart/form-data; boundary=" boundary-value))


(defn boundary [] boundary-value)


;; -----------------------------------------------------------------------------
;; Rendering parts
;; -----------------------------------------------------------------------------

(defn- render-part [name value os]
  (try 
    (assert (string? name))

    ;; open boundary for part
    (spit-string os (part-boundary) nl)

    ;; dispatch to the part renderer
    (cond 
      (file-url? value)   (as-> (. :java.net.URL :new value) f
                                (. f :getPath)
                                (io/file f)
                                (render-file-part name f os))
                                
      (io/file? value)    (render-file-part name value os)

      (map? value)        (render-file-data-part name 
                                                 (:filename value) 
                                                 (core/name (:mimetype value))
                                                 (:charset value) 
                                                 (:data value) 
                                                 os)

      (string? value)     (render-string-part name value os)

      :else               (render-string-part name (str value) os))
  (catch :Exception e  
    (throw (ex :VncException (str "Failed to process multipart item '" name "'") 
                             e)))))


(defn- render-file-part [name file os]
  (assert (string? name))
  (assert (io/file? file))

  (try
    (let [filename (io/file-path file)
          mimetype (core/name (mimetypes/probe-content-type file))
          data     (io/slurp file :binary true)]
      (when (nil? mimetype)
        (throw (ex :VncException (str "Failed to get mimetype for file " filename))))

      (render-file-data-part name filename mimetype nil data os))
    (catch :Exception e  
      (throw (ex :VncException (str "Failed to process file " (io/file-path file)) e)))))


(defn- render-file-data-part [name filename mimetype charset data os]
  (assert (string? filename))
  (assert (string? mimetype))
  (assert (or (nil? charset) (string? charset) (keyword? charset)))
  (assert (or (string? data) (bytebuf? data)))

  (spit-string os (content-disposition-header name (io/file-name filename)) nl)
  (spit-string os (content-type-header mimetype charset) nl)
  (spit-string os nl)
  (if (string? data) (spit-string os data) (spit-bytebuf os data))
  (spit-string os nl))


(defn- render-string-part [name text os]
  (assert (string? name))
  
  (spit-string os (content-disposition-header name) nl)
  (spit-string os nl)
  (spit-string os text nl))


(defn- spit-string [os & s]
  (io/spit-stream os (bytebuf-from-string (apply str s))))


(defn- spit-bytebuf [os buf]
  (io/spit-stream os buf))


(defn- part-boundary []
  (str "--" boundary-value))


(defn- closing-boundary []
  (str "--" boundary-value "--"))


(defn- content-disposition-header
  ([name]
    (str/format "Content-Disposition: form-data; name=%s"
                (dquote name)))

  ([name filename]
    (str/format "Content-Disposition: form-data; name=%s; filename=%s" 
                (dquote name) 
                (dquote filename))))


(defn- content-type-header
  ([content-type]
    (content-type-header content-type nil))

  ([content-type charset]
    (assert (or (nil? charset) (string? charset) (keyword? charset)))
    (if (nil? charset)
      (str/format "Content-Type: %s" content-type)
      (str/format "Content-Type: %s; charset=%s" content-type (name charset)))))


(defn- dquote [s]
  (assert (not (str/contains? "s" "\"")))
  (str/double-quote s))


(defn- file-url? [v]
  (and (string? v) (str/starts-with? v "file:")))



;; -----------------------------------------------------------------------------
;; Parsing parts
;; -----------------------------------------------------------------------------

(defn- parse-parts-buffers [buffer boundary]
  ;;  --boundary<crlf>
  ;;  ...
  ;;  --boundary<crlf>
  ;;  ...
  ;;  --boundary--<crlf>
  (let [part-boundary      (bytebuf-from-string (str "--" boundary nl))
        part-boundary-len  (count part-boundary)
        close-boundary     (bytebuf-from-string (str "--" boundary "--"))]
    (loop [parts [], index 0]
      (let [idx-start      (bytebuf-index-of buffer part-boundary index)
            idx-start-body (+ idx-start part-boundary-len)
            idx-next       (bytebuf-index-of buffer part-boundary idx-start-body)]
        (if (neg? idx-next)
          (let [idx-closing (bytebuf-index-of buffer close-boundary idx-start-body)]
            (if (neg? idx-closing)
              (throw (ex :VncException 
                         "Closing boundary not found while parsing multi-parts buffer"))
              (let [p (extract-part-buffer buffer idx-start-body idx-closing)]
                (conj parts p))))  ;; end - all parts processed
          (let [p (extract-part-buffer buffer idx-start-body idx-next)]
            (recur (conj parts p) idx-next)))))))


(defn- extract-part-buffer [buffer from to]
  ;; if the part buffer ends with "\r\n" remove it
  (let [buf (bytebuf-sub buffer from to)]
    (if (buffer-ends-with? buf nl-buf)
      (bytebuf-sub buf 0 (- (count buf) (count nl-buf)))
      buf)))


(defn- parse-part [buffer]
  ;; ---------------------------------------------------------------------------
  ;; Content-Disposition: form-data; name="foo"; filename="foo.json"
  ;; Content-Type: application/json; charset=utf-8
  ;;
  ;; content of part
  ;; ---------------------------------------------------------------------------

  (let [idx                 0
        disp-buf            (parse-part-string-line buffer idx)
        disp                (str/trim (bytebuf-to-string disp-buf))
        [name filename]     (parse-content-disposition-properties disp)
        idx                 (+ idx (count disp-buf))
        type-buf            (parse-part-string-line buffer idx)
        type                (str/trim (bytebuf-to-string type-buf))
        [mimetype charset]  (parse-content-type-properties type)
        idx                 (+ idx (count type-buf))
        empty-line-buf      (parse-part-empty-line buffer idx)
        idx                 (+ idx (count empty-line-buf))
        data                (bytebuf-sub buffer idx)]
    { :name      name
      :filename  filename
      :mimetype  mimetype
      :charset   charset
      :data-len  (count data)
      :data      data }))


(defn- parse-part-string-line [buffer index]
  (let [idx-nl (bytebuf-index-of buffer nl-buf index)]
    (if (neg? idx-nl) 
      (bytebuf) ;; empty (not found)
      (bytebuf-sub buffer index (+ idx-nl (count nl-buf))))))


(defn- parse-part-empty-line [buffer index]
  (let [idx-nl (bytebuf-index-of buffer nl-buf index)]
    (if (= index idx-nl) 
      nl-buf       ;; crlf (empty line)
      (bytebuf)))) ;; something else (nothing parsed)


(defn- parse-content-disposition-properties [s]
  (when-not (match? (str/lower-case s) "content-disposition:[ ]*form-data;.*")
    (throw (ex :VncException 
                """
                Parts must start "Content-Disposition: form-data" header! \
                Other subtypes than "form-data" are not supported.
                """)))

  (let [cd       (str/trim (str/subs s (count "Content-Disposition:")))
        name     (extract-match-group1 cd #".*form-data;[ ]*name=\"([^\"]+)\".*")
        filename (extract-match-group1 cd #".*form-data;.*[ ]*filename=\"([^\"]+)\"")]
    [name filename]))


(defn- parse-content-type-properties [s]
  (if-not (str/starts-with? (str/lower-case s) "content-type:")
    [nil nil]
    (let [ct                 (str/trim (str/subs s (count "Content-Type:")))
          [mimetype charset] (str/split ct "[ ]*;[ ]*")]
      [mimetype (str/trim (str/strip-start charset "charset="))])))


(defn- extract-match-group1 [s re]
  (let [m (regex/matcher re s)]
    (if (regex/matches? m) (regex/group m 1) nil)))


(defn- buffer-ends-with? [buffer subbuf]
  (let [idx (- (count buffer) (count subbuf))]
    (if (neg? idx)
       false
       (= idx (bytebuf-index-of buffer subbuf idx)))))
