;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Multipart 


(ns multipart)

(load-module :mimetypes)

(import :java.net.URL)
(import :java.io.File)
(import :java.nio.file.Files)
(import :java.nio.file.Path)
(import :java.nio.file.Paths)


(defonce ^:private boundary-value (str (rand-bigint 128)))

(defonce ^:private dash "--")
(defonce ^:private nl "\r\n")
(defonce ^:private disposition "Content-Disposition: form-data")
(defonce ^:private field-name "; name=")
(defonce ^:private file-name "; filename=")
(defonce ^:private content-type "Content-Type: ")


(defn 
  ^{ :arglists '(
        "(render parts)" )
     :doc
        """
        Renders a map of named parts as *multipart/form-data* format.
        
        The part name must be a string and the part data may be of type:
        * string
        * string ("file:/user/foo/image.png" to reference a file)
        * map (describing a part as :name, :mimetype, and :data (string or bytebuf)) elements)
        * io/file
        * all other part data types are converted with `(str data)` to a string

        Returns a bytebuf.
        """
     :examples '(
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (->> (m/render { "Part-1" "xxxxxxxxxxx" 
                           "Part-2" "yyyyyyyyyyy"})
               (bytebuf-to-string)
               (println)))
        """,
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (m/render { "Part-1" "xxxxxxxxxxx"
                      "Part-2" "file:/user/foo/image.png"
                      "Part-3" (io/file "/user/foo/image.png")
                      "Part-4" {:name      "data.xml"
                                :mimetype  "application/xml"
                                :data      "<user><name>foo</name></user>"}})
        """ ) }

  render [data]

  (assert (map? data))
  (assert (not (empty? data)))

  (try-with [os (io/bytebuf-out-stream)]
    (doseq [[name value] data] (render-part name value os))
    @os))


(defn 
  ^{ :arglists '(
        "(http-content-type-header)" )
     :doc
        """
        Returns the HTTP content type header value for *multipart/form-data*
        HTTP requests.
        
        E.g:  Content-Type: multipart/form-data; boundary=**********1234
        """
     :examples '(
        """
        (do
          (load-module :multipart ['multipart :as 'm])

          (m/http-content-type-header))
        """ ) }

  http-content-type-header []

  (str "multipart/form-data; boundary=" boundary-value))


(defn- render-part [name value os]
  (try 
    (assert (string? name))
    
    (cond 
      (file-url? value)   (->as (. :URL :new value) f
                                (. f :getPath)
                                (. :File :new f)
                                (render-file-part name f os))
                                
      (io/file? value)    (render-file-part name value os)

      (map? value)        (render-file-data-part name 
                                                 (:name value) 
                                                 (:mimetype value) 
                                                 (:data value) 
                                                 os)

      (string? value)     (render-string-part name value os)

      :else               (render-string-part name (str value) os))
  (catch :Exception e  
    (throw (ex :VncException (str "Failed to process multipart item " name) 
                             e)))))


(defn- render-file-part [name file os]
  (assert (string? name))
  (assert (io/file? file))

  (try
    (let [v-file-name     (io/file-path file)
          v-file-mimetype (mimetypes/probe-content-type file)
          v-file-data     (. :Files :readAllBytes (. file :toPath))]
      (when (nil? v-file-mimetype)
        (throw (ex :VncException (str "Failed to get mimetype for file " v-file-name))))

      (render-file-data-part name v-file-name v-file-mimetype v-file-data os))
    (catch :Exception e  
      (throw (ex :VncException (str "Failed do process file " v-file-name) e)))))


(defn- render-file-data-part [name v-file-name v-file-mimetype v-file-data os]
  (assert (string? v-file-name))
  (assert (string? v-file-mimetype))
  (assert (or (string? v-file-data) (bytebuf? v-file-data)))

  (io/spit-stream os (bytebuf-from-string (str dash boundary-value nl)))
  (io/spit-stream os (bytebuf-from-string disposition))

  (io/spit-stream os (bytebuf-from-string (str field-name (dquote name) 
                                               file-name (dquote v-file-name) 
                                               nl)))
  (io/spit-stream os (bytebuf-from-string (str content-type  v-file-mimetype nl)))
  (io/spit-stream os (bytebuf-from-string nl))
  (io/spit-stream os (if (string? v-file-data) 
                       (bytebuf-from-string v-file-data) 
                       v-file-data))
  (io/spit-stream os (bytebuf-from-string nl))

  (io/spit-stream os (bytebuf-from-string (str dash boundary-value dash nl))))


(defn- render-string-part [name text os]
  (assert (string? name))
  
  (io/spit-stream os (bytebuf-from-string (str dash boundary-value nl)))
  (io/spit-stream os (bytebuf-from-string disposition))

  (io/spit-stream os (bytebuf-from-string (str field-name (dquote name)  nl)))
  (io/spit-stream os (bytebuf-from-string nl))
  (io/spit-stream os (bytebuf-from-string (str text nl)))

  (io/spit-stream os (bytebuf-from-string (str dash boundary-value dash nl))))


(defn- dquote [s]
  (assert (not (str/contains? "s" "\"")))
  (str/double-quote s))


(defn- file-url? [v]
  (and (string? v) (str/starts-with? v "file:")))
