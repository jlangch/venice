;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; HTTP client for Java8+ based on the JDK HttpUrlConnection


(ns http-client-j8)

(load-module :multipart ['multipart :as 'mp])
(load-module :server-side-events ['server-side-events :as 'sse])


(import :java.net.URL)
(import :java.net.HttpURLConnection)
(import :java.net.HttpsURLConnection)

(import :com.github.jlangch.venice.util.servlet.HttpStatus)

(defonce ^:private hc-user-agent (str/format "Venice HTTP client %s (legacy)" (version)))


(defn
  ^{ :arglists '("(send method uri & options)")
     :doc """
          Send a request

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"} |
          | :body              | An optional body to send with the request¶ \
                                 The body may be of type *string*, *bytebuf*, \
                                 `:java.io.InputStream` |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false. ¶\
                                  In debug mode prints the HTTP request and \
                                  response data  |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type      | The content type |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream. ¶\
                                 If the response content encoding is 'gzip'  \
                                 due to a request header "Accept-Encoding: gzip" \
                                 wrap the data stream with a gzip input \
                                 stream: ¶\
                                 \u00A0\u00A0\u00A0\u00A0\u00A0(io/wrap-is-with-gzip-input-stream (:data-stream response)) ¶\
                                 to uncompress the data. |   
          """ 
     :examples '(
          """
          ;; GET (get)
          ;;
          ;; 1/ Start the example REST Server {Venice}/doc/examples/scripts/rest-webapp.venice
          ;;    (drag & drop the file into a REPL and HIT [RET] to start it)
          ;; 2/ Run the Http Client commands listed in these examples
          ;;    (run the Http Client commands from a 2nd REPL)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers { "Accept" "application/json, text/plain" }
                                    :debug true)
                  status   (:http-status response)]
              (println "Status:" status)
              (println (slurp-response response :json :pretty-print))))
          """,
          """
          ;; POST (create)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :post 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "name" "hanna", 
                                                            "role" "secretary" })
                                    :debug true)
                  status   (:http-status response)]
              (println "Status:" status)
              (println (hc/slurp-response response :json :pretty-print))))
          """,
          """
          ;; PUT (update)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :put 
                                    "http://localhost:8080/employees/1001" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "id"   "1001", 
                                                            "name" "john", 
                                                            "role" "clerk" })
                                    :debug true)
                  status   (:http-status response)]
              (println "Status:" status)
              (println (hc/slurp-response response :json :pretty-print))))
          """,
          """
          ;; DELETE (delete)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :delete 
                                    "http://localhost:8080/employees/1000" 
                                    :headers { "Accept" "text/plain" }
                                    :debug true)
                  status   (:http-status response)]
              (println "Status:" status)
              (println (hc/slurp-response response))))
          """,
          """
          ;; GET over SSL
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            (load-module :java ['java :as 'j])

            (import :com.github.jlangch.venice.util.ssl.CustomHostnameVerifier)
            (import :com.github.jlangch.venice.util.ssl.Server_X509TrustManager)
            (import :com.github.jlangch.venice.util.ssl.TrustAll_X509TrustManager)
            (import :com.github.jlangch.venice.util.ssl.SSLSocketFactory)
            (import :java.security.cert.X509Certificate)

            (defn verify-host [hostname]
               (case hostname
                 "localhost"  true
                 "foo.org"    true
                 false))
 
            (defn check-trust-server  [certs auth-type]
              (doseq [c certs] (. c :checkValidity))
              (any? #(= "Foo" (. (. % :getIssuerDN) :getName)) certs))


            (let [trust-manager-all     (. :TrustAll_X509TrustManager :new)
                  trust-manager-server  (. :Server_X509TrustManager :new (j/as-bipredicate check-trust-server))
                  hostname-verifier     (. :CustomHostnameVerifier :new verify-host)
                  response (hc/send :get 
                                    "https://localhost:8080/employees" 
                                    :headers { "Accept" "application/json, text/plain" }
                                    :hostname-verifier  hostname-verifier
                                    :ssl-socket-factory (. :SSLSocketFactory trust-manager-all)
                                    :debug true)
                  status   (:http-status response)]
              (println "Status:" status)
              (println (hc/slurp-response response))))
          """,
          """
          ;; OAuth blueprint
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])

            (defn get-access-token [api-key api-key-secret]
              (let [encoded-secret (-> (str api-key ":" api-key-secret)
                                       (bytebuf-from-string :utf-8)
                                       (str/encode-base64))
                    response (hc/send :post 
                                      "https://.../oauth2/token" 
                                      :headers { "Accept" "application/json, text/plain"
                                                 "Authorization" (str "Basic " encoded-secret)
                                                 "Content-Type" "application/x-www-form-urlencoded" }
                                      :body "grant_type=client_credentials")
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
                (if (and (= 200 status) (= "application/json" mimetype))
                  (as-> (:data-stream response) v
                        (hc/slurp-json v charset)
                        (get v "access_token"))
                  (throw (ex VncException "Failed to get OAuth access token")))))
            
            (defn list-member [access-token list-id]
              (let [response (hc/send :get 
                                      (str "https://.../1.1/lists/members.json?list_id=" list-id) 
                                      :headers { "Accept" "application/json, text/plain" 
                                                 "Authorization" (str "Bearer "  accessToken)})
                  status   (:http-status response)]
                (println "Status:" status)
                (println (hc/slurp-response response :json :pretty-print)))))
          """ )
     :see-also '(
          "http-client-j8/upload-file"
          "http-client-j8/upload-multipart"
          "http-client-j8/slurp-response" ) }

  send [method uri & options]
  
  (let [opts               (apply hash-map options)
        method             (str/upper-case (name method))
        headers            (:headers opts {})
        body               (:body opts)
        conn-timeout       (:conn-timeout opts)
        read-timeout       (:read-timeout opts)
        follow-redirects   (:follow-redirects opts)
        hostname-verifier  (:hostname-verifier opts)
        ssl-socket-factory (:ssl-socket-factory opts)
        use-caches         (:use-caches opts false)
        user-agent         (:user-agent opts hc-user-agent)
        debug?             (true? (:debug opts false))
                           ;; default headers
        headers            (assoc headers "User-Agent" user-agent)
        headers            (if (not-contains? headers "Accept")
                              (assoc headers "Accept" "text/plain, */*;0.2")
                              headers)]

    (assert (string? method))
    (assert (string? uri))
    (assert (or (map? headers)))
    (assert (or (nil? body) (string? body) (bytebuf? body) (io/in-stream? body)))
    (assert (or (nil? conn-timeout) (long? conn-timeout)))
    (assert (or (nil? read-timeout) (long? read-timeout)))
    (assert (or (nil? follow-redirects) (boolean? follow-redirects)))

    (let [https?          (str/starts-with? (str/lower-case uri) "https:")
          [type encoding] (parse-content-type (get headers "Content-Type"))
          url             (. :URL :new uri)
          con             (. url :openConnection)
          con             (if https? (cast :HttpsURLConnection con)
                                     (cast :HttpURLConnection con))]
      (. con :setRequestMethod method)

      (when https?
        (when (some? hostname-verifier)
          (. con :setHostnameVerifier hostname-verifier))
        (when (some? ssl-socket-factory)
          (. con :setSSLSocketFactory ssl-socket-factory)))

      (when (some? conn-timeout)
        (. con :setConnectTimeout conn-timeout))

      (when (some? read-timeout)
        (. con :setReadTimeout read-timeout))

      (. con :setUseCaches use-caches)

      (doseq [[k v] headers] 
        (. con :setRequestProperty k (str v)))

      (when (some? follow-redirects)
        (. con :setInstanceFollowRedirects follow-redirects))
      
      (when (some? body)
        (. con :setDoOutput true))

      (. con :connect)  ;; establish the connection

      (when debug? 
         (dump-request url headers conn-timeout read-timeout use-caches))

      ;; send body, if we got one
      (when (some? body)
        (let [os (. con :getOutputStream)]
          (cond 
            (string? body)        (spit-string body encoding os debug?)                 
            (bytebuf? body)       (spit-bytebuf body os debug?)
            (io/in-stream? body)  (spit-bytebuf (io/slurp-stream is) os debug?)
            :else                 (throw (ex :VncException 
                                             (str "Invalid " method 
                                                  " request body type"))))))

      ;; handle response
      (let [response (assoc (get-response con) :debug debug?)]
        (when debug? (dump-response response))
        response))))


(defn 
  ^{ :arglists '("(upload-file file uri & options)")
     :doc """
          Upload a file

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"} |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false. ¶\
                                  In debug mode prints the HTTP request and \
                                  response data and info on the uploaded file  |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/upload-file
                                (io/file "/Users/foo/image.png") 
                                "http://localhost:8080/upload" 
                                :headers { "Accept" "text/plain" }
                                :debug true)
                  status   (:http-status response)]
              (println "Status:" status)))
          """ )
     :see-also '(
          "http-client-j8/send"
          "http-client-j8/upload-multipart" ) }

  upload-file [file uri & options]
 
  (assert (io/file? file))
  (assert (string? uri))
 
  (let [opts      (apply hash-map options)
        debug?    (:debug opts false)
        headers   (:headers opts {})
        headers   (assoc headers "Content-Type" (mp/http-content-type-header))
        body      (mp/render {"file" (io/file file)} debug?)
        opts      (dissoc opts :file)
        opts      (assoc opts :headers headers)
        opts      (assoc opts :body body)]
    (when debug? 
      (printf "\nUploading file '%s': %d bytes%n" file (io/file-size file)))
    (apply send :post uri (flatten (seq opts)))))


(defn 
  ^{ :arglists '("(upload-multipart parts uri & options)")
     :doc """
          Upload multiple parts.

          The upload support file parts and generic parts. Any number of parts
          can be uploaded.

          The parts are passed as a map of part data:

          ```
          { ;; a string part 
            "Part-1" "xxxxxxxxxxx"

            ;; a file part
            "Part-2" (io/file "/Users/juerg/Desktop/image.png")

            ;; a x-www-form-urlencoded (generic) part 
            "Part-3" { :mimetype  "application/x-www-form-urlencoded"
                       :charset   :utf-8
                       :data      "color=blue" }

            ;; a generic part
            ;; The charset of a generic part is only required for text based 
            ;; data. When passing binary data the charset can be left out.
            "Part-4" { :filename  "data.xml"
                       :mimetype  "application/xml"
                       :charset   :utf-8
                       :data      "<user><name>foo</name></user>" }})
          ```

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"} |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false. ¶\
                                  In debug mode prints the HTTP request (multipart \
                                  data included) and the response data |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/upload-multipart
                                { "image1" (io/file "/Users/foo/image1.png") 
                                  "image2" (io/file "/Users/foo/image2.png") }                                
                                "http://localhost:8080/upload" 
                                :headers { "Accept" "text/plain" }
                                :debug true)
                  status   (:http-status response)]
              (println "Status:" status)))
          """ )
     :see-also '(
          "http-client-j8/upload-file"
          "http-client-j8/upload-multipart" ) }

  upload-multipart [parts uri & options]
 
  (assert (map? parts))
  (assert (string? uri))
 
  (let [opts      (apply hash-map options)
        debug?    (:debug opts false)
        body      (mp/render parts debug?)
        headers   (:headers opts {})
        headers   (assoc headers "Content-Type" (mp/http-content-type-header))
        opts      (dissoc opts :file)
        opts      (assoc opts :headers headers)
        opts      (assoc opts :body body)]
    (apply send :post uri (flatten (seq opts)))))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn 
 ^{ :arglists '(
         "(slurp-response response & options)")
     :doc """
          Slurps the response data from the response' input stream.

          Returns the data according to the mimetype and charset of the 
          'Content-Type' response header.

          Handles a 'Content-Encoding' transparently. Supports the encodings
          'gzip' and 'deflate'. Other encodings are rejected with an exception.

          | [![width: 20%]]   | [![width: 80%]] |
          | application/xml   | Returns a string according to the content type charset |
          | application/json  | Returns a string according to the content type charset |
          | text/plain        | Returns a string according to the content type charset |
          | text/html         | Returns a string according to the content type charset |
          | text/xml          | Returns a string according to the content type charset |
          | text/csv          | Returns a string according to the content type charset |
          | text/css          | Returns a string according to the content type charset |
          | text/json         | Returns the parsed JSON as a map according to the \
                                content type charset |
          | text/event-stream | Throws an exception. An event stream can not be slurped. \
                                Use the function `process-server-side-events` instead! |
          | else              | Returns a byte buffer |

          Options:

          | [![width: 20%]]    | [![width: 80%]] |
          | :json              | If the response mimetype is 'text/json' parse to \
                                 a Venice data map if the option value is `:data`. \
                                 Return it as pretty printed JSON string if the \
                                 value is `:pretty-print`.  ¶\
                                 Defaults to `:data` |

          """ 
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status response)]
              (println "Status:" status)
              (let [data (slurp-response response)]
                (println "Slurped as:" (type data)))))
          """ )
     :see-also '(
           "http-client-j8/process-server-side-events"
           "http-client-j8/send" ) }

  slurp-response [response & options]

  (assert (some? response))

  (let [opts         (apply hash-map options) 
        json-mode    (:json opts :data)   
        status       (:http-status response)
        mimetype     (:content-type-mimetype response)
        charset      (:content-type-charset response)
        encoding     (parse-content-encoding (:content-encoding response))
        is           (:data-stream response)
        debug?       (true? (:debug response false))
        slurp-plain  (is-slurp-plain-text? mimetype)
        slurp-json   (is-slurp-json? mimetype)
        slurp-binary (not (or slurp-plain slurp-json))]
    (when (= "text/event-stream" mimetype)
      (throw (ex :VncException 
                 """
                  An event stream can not be slurped by this 'slurp-response' \
                  function. Use the function \
                  'http-client-j8/process-server-side-events' instead!
                 """)))
    (when debug?
      (println)
      (println "Slurp response:")
      (println "   status:            " status)
      (println "   mimetype:          " mimetype)
      (println "   charset:           " charset)
      (println "   encoding:          " encoding)
      (println "   slurp-plain:       " slurp-plain)
      (println "   slurp-json:        " slurp-json)
      (println "   slurp-binary:      " slurp-binary)
      (println "   json-mode:         " json-mode)
      (println))

    (cond
      (is-slurp-plain-text? mimetype)  (slurp-as-plain-text is encoding charset)
      (is-slurp-json? mimetype)        (slurp-as-json is encoding charset json-mode)
      :else                            (slurp-as-binary is encoding))))


(defn 
 ^{ :arglists '(
         "(process-server-side-events response handler)")
     :doc """
          Processes server side events (SSE) and calls for every the event 
          handler 'handler'.

          Note: The response must be of the mimetype "text/event-stream"
                otherwise the processor throws an exception!

          The event handler is a two argument function reciving the event as 
          the first argument and the event count as the second argument.

          If the event handler returns the value `:stop` the processer stops
          handling any further events and closes the data stream to signal
          the server not to send any further events and close the server side
          stream as well.

          Server side events are handed as maps to the handler. E.g. :

          ```
          { :id    "1"
            :event "score"
            :data  [ "GOAL Liverpool 1 - 1 Arsenal"
                     "GOAL Manchester United 3 - 3 Manchester City" ] }
          ``` 

          Warning: 
          
          When not used over HTTP/2, SSE suffers from a limitation to \
          the maximum number of open connections, which can be especially \
          painful when opening multiple tabs, as the limit is per browser and \
          is set to a very low number (6). The issue has been marked as \
          "Won't fix" in Chrome and Firefox. This limit is per browser + domain, \
          which means that you can open 6 SSE connections across all of the \
          tabs. 
          
          When using HTTP/2, the maximum number of simultaneous HTTP streams \
          is negotiated between the server and the client (defaults to 100).

          The Java 8 Http Client does not support HTTP/2!
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])

            (let [response (hc/send :get 
                                    "http://localhost:8080/events" 
                                    :headers { "Accept"         "text/event-stream" 
                                               "Cache-Control"  "no-cache"
                                               "Connection"     "keep-alive"}
                                    :conn-timeout 0
                                    :read-timeout 0
                                    :debug true)]
              (println "Status:" (:http-status response))

              ;; process the first 10 events and close the stream
              (hc/process-server-side-events 
                response
                (fn [event cnt]
                  (cond 
                    (nil? event)  (do (println "No more events")
                                      :ok)
                    (= cnt 1)     (do (println "\nConsuming events...\n")
                                      (println "Event: " event)
                                      :ok)
                    (>= cnt 10)   (do (println "Event: " event)
                                      (println "Stopped after receiving 10 events")
                                      :stop)
                    :else         (do (println "Event: " event)
                                      :ok))))))
          """ )
     :see-also '(
           "http-client-j8/slurp-response"
           "http-client-j8/send" ) }

  process-server-side-events [response event-handler]

  (assert (some? response))
  (assert (fn? event-handler))

  (when-not (= "text/event-stream" (:content-type-mimetype response))
    (throw (ex :VncException 
                """
                Server side events can only be processed on a response with \
                mimetype 'text/event-stream'!
                """)))

  (let [is (:data-stream response)
        rd (io/wrap-is-with-buffered-reader is :utf-8)]
    ;; read the streamed events from the response
    (loop [event (sse/read-event rd) event-count 1]
      (if event
        (let [action (event-handler event event-count)]  
          (if (= :stop action)
            (. rd :close)
            (recur (sse/read-event rd) (inc event-count))))
        (event-handler nil event-count)))))  ;; no more events


(defn 
  ^{ :arglists '(
         "(status-ok-range? status)")
     :doc """
          Returns true if the passed HTTP status code is in the range
          of the OK codes (200 ... 299) else false.
          """ 
     :examples '(
          "(http-client-j8/status-ok-range? 200)" )
     :see-also '(
          "http-client-j8/status-redirect-range?"
          "http-client-j8/status-client-range?"
          "http-client-j8/status-server-error-range?" ) }

  status-ok-range? [status] 
  
  (. :HttpStatus :isOkRange status))


(defn 
  ^{ :arglists '(
         "(status-redirect-range? status)")
     :doc """
          Returns true if the passed HTTP status code is in the range
          of the REDIRECT codes (300 ... 399) else false.
          """ 
     :examples '(
          "(http-client-j8/status-redirect-range? 300)" )
     :see-also '(
          "http-client-j8/status-ok-range?"
          "http-client-j8/status-client-range?"
          "http-client-j8/status-server-error-range?" ) }

  status-redirect-range? [status] 
  
  (. :HttpStatus :isRedirectRange status))

(defn 
  ^{ :arglists '(
         "(status-client-range? status)")
     :doc """
          Returns true if the passed HTTP status code is in the range
          of the CLIENT codes (400 ... 499) else false.
          """ 
     :examples '(
          "(http-client-j8/status-client-range? 400)" )
     :see-also '(
          "http-client-j8/status-ok-range?"
          "http-client-j8/status-redirect-range?"
          "http-client-j8/status-server-error-range?" ) }

  status-client-range? [status] 
  
  (. :HttpStatus :isClientRange status))


(defn 
  ^{ :arglists '(
         "(status-oserver-error-range? status)")
     :doc """
          Returns true if the passed HTTP status code is in the range
          of the SERVER ERROR codes (500 ... 599) else false.
          """ 
     :examples '(
          "(http-client-j8/status-server-error-range? 500)" )
     :see-also '(
          "http-client-j8/status-ok-range?"
          "http-client-j8/status-redirect-range?"
          "http-client-j8/status-client-range?" ) }

  status-server-error-range? [status] 
  
  (. :HttpStatus :isServerErrorRange status))


;; -----------------------------------------------------------------------------
;; Helpers
;; -----------------------------------------------------------------------------

(defn- get-response [con]
  (let [status              (long (. con :getResponseCode))
        ok?                 (status-ok-range? status)
        headers             (response-headers con)
        content-type        (get headers "Content-Type")
        [mimetype charset]  (parse-content-type content-type)
        content-encoding    (get headers "Content-Encoding")
        effective-url       (. con :getURL)]  ;; the url after a possible redirect
    (ordered-map
      :http-status            status 
      :http-status-name       (str (. :HttpStatus :of status)) 
      :content-type           content-type
      :content-type-mimetype  mimetype
      :content-type-charset   charset
      :content-encoding       content-encoding
      :content-length         (. con :getContentLengthLong)
      :effective-url          effective-url
      :headers                headers 
      :data-stream            (if ok? (. con :getInputStream) 
                                      (. con :getErrorStream)))))


(defn- parse-content-type [content-type]
   ;; "application/json"                     => ["application/json" :utf-8]
   ;; "application/json; charset=iso-8859-1" => ["application/json" :iso-8859-1]
  (let [[t e]  (as-> (str/trim-to-nil content-type) v
                     (str/split v ";")
                     (map str/trim v))
               ;; default to :utf-8 and strip "charset=" prefix
        e      (keyword (str/strip-start (or e "utf-8") "charset="))] 
    [t e]))


(defn- response-headers [con]
  (->> (. con :getHeaderFields)
       (map-vals #(str/join ", " %))))  ;; just single values


(defn- spit-string [str charset os debug?]
  (when debug? (printf "\nSending request with string body. size: %s chars, charset :%s%n" 
                       (count str) 
                       (name charset)))
  (try-with [pr (io/wrap-os-with-print-writer os charset)]
    (print pr str)
    (flush pr)))


(defn- spit-bytebuf [buf os debug?]
  (when debug? (printf "\nSending request with byte body. size: %s bytes%n" 
                       (count buf)))
  (try-with [os os]
    (io/spit-stream os buf :flush true)))


(defn- dump-request [url headers conn-timeout read-timeout use-caches]
  (println)
  (println     "Dump request:")
  (println     "   url:               " url)
  (println     "   conn-timeout:      " conn-timeout)
  (println     "   read-timeout:      " read-timeout)
  (println     "   use-caches:        " use-caches)
  (println-map "   headers:           " headers))


(defn- dump-response [res]
  (println)
  (println     "Dump response:")
  (println     "   http-status:           " (:http-status res) (str "(" (:http-status-name res) ")"))
  (println     "   content-type:          " (:content-type res))
  (println     "   content-type-mimetype: " (:content-type-mimetype res))
  (println     "   content-type-charset:  " (:content-type-charset res))
  (println     "   content-encoding:      " (:content-encoding res))
  (println     "   content-length:        " (:content-length res))
  (println     "   effective-url:         " (:effective-url res))
  (println-map "   headers:               " (:headers res)))


(defn- println-map [head data]
  (if (or (nil? data) (empty? data))
    (println head "-")
    (let [indent  (str/repeat " " (count head))
          tuples  (into '() data)
          format  (fn [tuple] (str (first tuple) ": " (second tuple)))]
      (println head (format (first tuples)))
      (doseq [t (rest tuples)] (println indent (format t))))))


(defn- parse-content-encoding [encoding]
  (let [enc (str/trim-to-nil encoding)]
    (cond 
      (nil? enc)             :none
      (= "gzip" enc)         :gzip
      (= "deflate" enc)      :deflate
      (str/contains enc ",") :not-supported
      :else                  :not-supported)))


(defn- is-slurp-plain-text? [mimetype]
  (some? (get #{ "application/xml", "text/plain", "text/html", 
                 "text/xml", "text/csv", "text/css" } 
              mimetype)))


(defn- is-slurp-json? [mimetype]
  (or (= "text/json" mimetype) (= "application/json" mimetype)))


(defn- slurp-as-plain-text [is encoding charset]
  (let [charset  (or (str/trim-to-nil charset) :utf-8)
        is       (wrap-is-with-decompressor is encoding)]
    (io/slurp-stream is :binary false :encoding charset)))


(defn- slurp-as-json [is encoding charset json-mode]
   (let [charset  (or (str/trim-to-nil charset) :utf-8)
        is        (wrap-is-with-decompressor is encoding)
        data      (io/slurp-stream is :binary false :encoding charset)]
     (if (= :data json-mode) 
       (json/read-str)
       (-> (json/read-str data)
           (json/write-str)
           (json/pretty-print)))))


(defn- slurp-as-binary [is encoding]
  (let [charset  (or (str/trim-to-nil charset) :utf-8)
        is       (wrap-is-with-decompressor is encoding)]
    (io/slurp-stream is :binary true)))


(defn- wrap-is-with-decompressor [is encoding]
  (case encoding
    :none     is
    :gzip     (io/wrap-is-with-gzip-input-stream is)
    :deflate  (io/wrap-is-with-inflater-input-stream is)
    (throw (ex :VncException (str/format "Unsupported 'Content-Encoding' -> '%s'")
                                          encoding))))

