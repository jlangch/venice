;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; HTTP client for Java8+ based on the JDK HttpUrlConnection


(ns http-client-j8)

(load-module :multipart ['multipart :as 'mp])

(import :java.net.URL)
(import :java.net.HttpURLConnection)
(import :java.net.HttpsURLConnection)

(import :com.github.jlangch.venice.util.servlet.HttpStatus)

(defonce ^:private hc-user-agent (str/format "Venice HTTP client %s (legacy)" (version)))


(defn
  ^{ :arglists '("(send method uri & options)")
     :doc """
          Send a request

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"]} |
          | :body              | An optional body to send with the request¶ \
                                 The body may be of type *string*, *bytebuf*, \
                                 `:java.io.InputStream` |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type      | The content type |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream. ¶\
                                 If the response content encoding is 'gzip'  \
                                 due to a request header "Accept-Encoding: gzip" \
                                 wrap the data stream with a gzip input \
                                 stream: ¶\
                                 \u00A0\u00A0\u00A0\u00A0\u00A0(io/wrap-is-with-gzip-input-stream (:data-stream response)) ¶\
                                 to uncompress the data. |   
          """ 
     :examples '(
          """
          ;; GET (get)
          ;;
          ;; 1/ Start the example REST Server {Venice}/doc/examples/scripts/rest-webapp.venice
          ;;    (drag & drop the file into a REPL and HIT [RET] to start it)
          ;; 2/ Run the Http Client commands listed in these examples
          ;;    (run the Http Client commands from a 2nd REPL)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers { "Accept" "application/json, text/plain" }
                                    :debug true)
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" mimetype))
                (println (hc/slurp-json (:data-stream response) charset))
                (println (hc/slurp-string (:data-stream response) charset)))))
          """,
          """
          ;; POST (create)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :post 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "name" "hanna", 
                                                            "role" "secretary" })
                                    :debug true)
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" mimetype))
                (println (hc/slurp-json (:data-stream response) charset))
                (println (hc/slurp-string (:data-stream response) charset)))))
          """,
          """
          ;; PUT (update)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :put 
                                    "http://localhost:8080/employees/1001" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "id"   "1001", 
                                                            "name" "john", 
                                                            "role" "clerk" })
                                    :debug true)
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" mimetype))
                (println (hc/slurp-json (:data-stream response) charset))
                (println (hc/slurp-string (:data-stream response) charset)))))
          """,
          """
          ;; DELETE (delete)
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/send :delete 
                                    "http://localhost:8080/employees/1000" 
                                    :headers { "Accept" "text/plain" }
                                    :debug true)
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (= "text/plain" mimetype)
                (println (hc/slurp-string (:data-stream response) charset)))))
          """,
          """
          ;; GET over SSL
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            (load-module :java ['java :as 'j])

            (import :com.github.jlangch.venice.util.ssl.CustomHostnameVerifier)
            (import :com.github.jlangch.venice.util.ssl.Server_X509TrustManager)
            (import :com.github.jlangch.venice.util.ssl.TrustAll_X509TrustManager)
            (import :com.github.jlangch.venice.util.ssl.SSLSocketFactory)
            (import :java.security.cert.X509Certificate)

            (defn verify-host [hostname]
               (case hostname
                 "localhost"  true
                 "foo.org"    true
                 false))
 
            (defn check-trust-server  [certs auth-type]
              (doseq [c certs] (. c :checkValidity))
              (any? #(= "Foo" (. (. % :getIssuerDN) :getName)) certs))


            (let [trust-manager-all     (. :TrustAll_X509TrustManager :new)
                  trust-manager-server  (. :Server_X509TrustManager :new (j/as-bipredicate check-trust-server))
                  hostname-verifier     (. :CustomHostnameVerifier :new verify-host)
                  response (hc/send :get 
                                    "https://localhost:8080/employees" 
                                    :headers { "Accept" "application/json, text/plain" }
                                    :hostname-verifier  hostname-verifier
                                    :ssl-socket-factory (. :SSLSocketFactory trust-manager-all)
                                    :debug true)
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" mimetype))
                (println (hc/slurp-json (:data-stream response) charset))
                (println (hc/slurp-string (:data-stream response) charset)))))
          """,
          """
          ;; OAuth blueprint
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])

            (defn get-access-token [api-key api-key-secret]
              (let [encoded-secret (-> (str api-key ":" api-key-secret)
                                       (bytebuf-from-string :utf-8)
                                       (str/encode-base64))
                    response (hc/send :post 
                                      "https://.../oauth2/token" 
                                      :headers { "Accept" "application/json, text/plain"
                                                 "Authorization" (str "Basic " encoded-secret)
                                                 "Content-Type" "application/x-www-form-urlencoded" }
                                      :body "grant_type=client_credentials")
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
                (if (and (= 200 status) (= "application/json" mimetype))
                  (as-> (:data-stream response) v
                        (hc/slurp-json v charset)
                        (get v "access_token"))
                  (throw (ex VncException "Failed to get OAuth access token")))))
            
            (defn list-member [access-token list-id]
              (let [response (hc/send :get 
                                      (str "https://.../1.1/lists/members.json?list_id=" list-id) 
                                      :headers { "Accept" "application/json, text/plain" 
                                                 "Authorization" (str "Bearer "  accessToken)})
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
                 (if (and (= 200 status) (= "application/json" mimetype))
                  (-> (:data-stream response)
                      (hc/slurp-json charset))
                  (throw (ex VncException "Failed to list members"))))))
          """ )
     :see-also '(
          "http-client-j8/upload-file"
          "http-client-j8/upload-multipart"
          "http-client-j8/slurp-string"
          "http-client-j8/slurp-json"
          "http-client-j8/slurp-bytebuf"
          "io/wrap-is-with-gzip-input-stream" ) }

  send [method uri & options]
  
  (let [opts               (apply hash-map options)
        method             (str/upper-case (name method))
        headers            (:headers opts {})
        body               (:body opts)
        conn-timeout       (:conn-timeout opts)
        read-timeout       (:read-timeout opts)
        follow-redirects   (:follow-redirects opts)
        hostname-verifier  (:hostname-verifier opts)
        ssl-socket-factory (:ssl-socket-factory opts)
        use-caches         (:use-caches opts false)
        user-agent         (:user-agent opts hc-user-agent)
        debug?             (true? (:debug opts false))
                           ;; default headers
        headers            (assoc headers "User-Agent" user-agent)
        headers            (if (not-contains? headers "Accept")
                              (assoc headers "Accept" "text/plain, */*;0.2")
                              headers)]

    (assert (string? method))
    (assert (string? uri))
    (assert (or (map? headers)))
    (assert (or (nil? body) (string? body) (bytebuf? body) (io/in-stream? body)))
    (assert (or (nil? conn-timeout) (long? conn-timeout)))
    (assert (or (nil? read-timeout) (long? read-timeout)))
    (assert (or (nil? follow-redirects) (boolean? follow-redirects)))

    (let [https?          (str/starts-with? (str/lower-case uri) "https:")
          [type encoding] (parse-content-type (get headers "Content-Type"))
          url             (. :URL :new uri)
          con             (. url :openConnection)
          con             (if https? (cast :HttpsURLConnection con)
                                     (cast :HttpURLConnection con))]
      (. con :setRequestMethod method)

      (when https?
        (when (some? hostname-verifier)
          (. con :setHostnameVerifier hostname-verifier))
        (when (some? ssl-socket-factory)
          (. con :setSSLSocketFactory ssl-socket-factory)))

      (when (some? conn-timeout)
        (. con :setConnectTimeout conn-timeout))

      (when (some? read-timeout)
        (. con :setReadTimeout read-timeout))

      (. con :setUseCaches use-caches)

      (doseq [[k v] headers] 
        (. con :setRequestProperty k (str v)))

      (when (some? follow-redirects)
        (. con :setInstanceFollowRedirects follow-redirects))
      
      (when (some? body)
        (. con :setDoOutput true))

      (. con :connect)  ;; establish the connection

      (when debug? 
         (dump-request url headers conn-timeout read-timeout use-caches))

      ;; send body, if we got one
      (when (some? body)
        (let [os (. con :getOutputStream)]
          (cond 
            (string? body)        (spit-string body encoding os debug?)                 
            (bytebuf? body)       (spit-bytebuf body os debug?)
            (io/in-stream? body)  (spit-bytebuf (io/slurp-stream is) os debug?)
            :else                 (throw (ex :VncException 
                                             (str "Invalid " method 
                                                  " request body type"))))))

      ;; handle response
      (let [response  (get-response con)]
        (when debug? (dump-response response))
        response))))


(defn 
  ^{ :arglists '("(upload-file file uri & options)")
     :doc """
          Upload a file

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"]} |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/upload-file
                                (io/file "/Users/foo/image.png") 
                                "http://localhost:8080/upload" 
                                :headers { "Accept" "text/plain" }
                                :debug true)
                  status   (:http-status response)]
              (println "Status:" status)))
          """ )
     :see-also '(
          "http-client-j8/send"
          "http-client-j8/upload-multipart" ) }

  upload-file [file uri & options]
 
  (assert (io/file? file))
  (assert (string? uri))
 
  (let [opts      (apply hash-map options)
        debug?    (:debug opts false)
        headers   (:headers opts {})
        headers   (assoc headers "Content-Type" (mp/http-content-type-header))
        body      (mp/render {"file" (io/file file)} debug?)
        opts      (dissoc opts :file)
        opts      (assoc opts :headers headers)
        opts      (assoc opts :body body)]
    (when debug? 
      (printf "\nUploading file '%s': %d bytes%n" file (io/file-size file)))
    (apply send :post uri (flatten (seq opts)))))


(defn 
  ^{ :arglists '("(upload-multipart parts uri & options)")
     :doc """
          Upload multiple parts.

          The upload support file parts and generic parts. Any number of parts
          can be uploaded.

          The parts are passed as a map of part data:

          ```
          { ;; a string part 
            "Part-1" "xxxxxxxxxxx"

            ;; a file part
            "Part-2" (io/file "/Users/juerg/Desktop/image.png")

            ;; a x-www-form-urlencoded (generic) part 
            "Part-3" { :mimetype  "application/x-www-form-urlencoded"
                       :charset   :utf-8
                       :data      "color=blue" }

            ;; a generic part
            ;; The charset of a generic part is only required for text based 
            ;; data. When passing binary data the charset can be left out.
            "Part-4" { :filename  "data.xml"
                       :mimetype  "application/xml"
                       :charset   :utf-8
                       :data      "<user><name>foo</name></user>" }})
          ```

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"]} |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :use-caches         | A boolean indicating whether or not to allow \
                                  caching. Defaults to false |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type-mimetype  | The content type's mimetype. E.g.: "text/plain" |
          | :content-type-charset   | The content type's charset. E.g.: :utf-8 |
          | :content-encoding  | The content transfer encoding (a keyword), if \
                                 available else nil. E.g.: "gzip" |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            
            (let [response (hc/upload-multipart
                                { "image1" (io/file "/Users/foo/image1.png") 
                                  "image2" (io/file "/Users/foo/image2.png") }                                
                                "http://localhost:8080/upload" 
                                :headers { "Accept" "text/plain" }
                                :debug true)
                  status   (:http-status response)]
              (println "Status:" status)))
          """ )
     :see-also '(
          "http-client-j8/upload-file"
          "http-client-j8/upload-multipart" ) }

  upload-multipart [parts uri & options]
 
  (assert (map? parts))
  (assert (string? uri))
 
  (let [opts      (apply hash-map options)
        debug?    (:debug opts false)
        body      (mp/render parts debug?)
        headers   (:headers opts {})
        headers   (assoc headers "Content-Type" (mp/http-content-type-header))
        opts      (dissoc opts :file)
        opts      (assoc opts :headers headers)
        opts      (assoc opts :body body)]
    (apply send :post uri (flatten (seq opts)))))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
         "(slurp-string is)"
         "(slurp-string is charset)")
     :doc """
          Slurps the input stream with the response data into a string. Defaults
          to :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (= 200 status)
                (println (hc/slurp-string (:data-stream response) charset))
                (println (hc/slurp-string (:data-stream response) charset)))))
          """ )
     :see-also '(
          "http-client-j8/slurp-json"
          "http-client-j8/slurp-bytebuf"
          "http-client-j8/send" ) }

  slurp-string 
  
  ([is] (slurp-string is :utf-8))
  ([is charset] (io/slurp-stream is :binary false :encoding (or charset :utf-8))))


(defn 
  ^{ :arglists '(
         "(slurp-json is)"
         "(slurp-json is charset)")
     :doc """
          Slurps the input stream with the response data into JSON. Defaults to 
          :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status response)
                  mimetype (:content-type-mimetype response)
                  charset  (:content-type-charset response)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" mimetype))
                (println (hc/slurp-json (:data-stream res) charset))
                (println (hc/slurp-string (:data-stream res) charset)))))
          """ )
     :see-also '(
          "http-client-j8/slurp-string"
          "http-client-j8/slurp-bytebuf"
          "http-client-j8/send" ) }

  slurp-json

  ([is] (slurp-json is :utf-8))
  ([is charset] (-> (io/slurp-stream is :binary false 
                                        :encoding (or charset :utf-8))
                    (json/pretty-print))))


(defn 
 ^{ :arglists '(
         "(slurp-bytebuf is)")
     :doc """
          Slurps the input stream with the response data into a bytebuf.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [response (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status response)]
              (println "Status:" status)
              (let [data (hc/slurp-bytebuf (:data-stream response))]
                (println "Bytes read:" (count data)))))
          """ )
     :see-also '(
          "http-client-j8/slurp-string"
          "http-client-j8/slurp-json"
          "http-client-j8/send" ) }

  slurp-bytebuf [is]

  (io/slurp-stream is :binary true))



;; -----------------------------------------------------------------------------
;; Helpers
;; -----------------------------------------------------------------------------

(defn- get-response [con]
  (let [status              (long (. con :getResponseCode))
        ok?                 (<= 200 status 299)
        headers             (response-headers con)
        content-type        (get headers "Content-Type")
        [mimetype charset]  (parse-content-type content-type)
        content-encoding    (get headers "Content-Encoding")
        effective-url       (. conn :getURL)]  ;; after a possible redirect
    (ordered-map
      :http-status            status 
      :http-status-name       (str (. :HttpStatus :of status)) 
      :content-type           content-type
      :content-type-mimetype  mimetype
      :content-type-charset   charset
      :content-encoding       content-encoding
      :content-length         (. con :getContentLengthLong)
      :effective-url          effective-url
      :headers                headers 
      :data-stream             (if ok? (. con :getInputStream) 
                                       (. con :getErrorStream)))))


(defn- parse-content-type [content-type]
   ;; "application/json"                     => ["application/json" :utf-8]
   ;; "application/json; charset=iso-8859-1" => ["application/json" :iso-8859-1]
  (let [[t e]  (as-> (str/trim-to-nil content-type) v
                     (str/split v ";")
                     (map str/trim v))
               ;; default to :utf-8 and strip "charset=" prefix
        e      (keyword (str/strip-start (or e "utf-8") "charset="))] 
    [t e]))


(defn- response-headers [con]
  (->> (. con :getHeaderFields)
       (map-vals #(str/join ", " %))))  ;; just single values


(defn- spit-string [str charset os debug?]
  (when debug? (printf "\nSending request with string body. size: %s chars, charset :%s%n" 
                       (count str) 
                       (name charset)))
  (try-with [pr (io/wrap-os-with-print-writer os charset)]
    (print pr str)
    (flush pr)))


(defn- spit-bytebuf [buf os debug?]
  (when debug? (printf "\nSending request with byte body. size: %s bytes%n" 
                       (count buf)))
  (try-with [os os]
    (io/spit-stream os buf :flush true)))


(defn- dump-request [url headers conn-timeout read-timeout use-caches]
  (println)
  (println     "Dump request:")
  (println     "   url:               " url)
  (println     "   conn-timeout:      " conn-timeout)
  (println     "   read-timeout:      " read-timeout)
  (println     "   use-caches:        " use-caches)
  (println-map "   headers:           " headers))


(defn- dump-response [res]
  (println)
  (println     "Dump response:")
  (println     "   http-status:           " (:http-status res))
  (println     "   content-type:          " (:content-type res))
  (println     "   content-type-mimetype: " (:content-type-mimetype res))
  (println     "   content-type-charset:  " (:content-type-charset res))
  (println     "   content-encoding:      " (:content-encoding res))
  (println     "   content-length:        " (:content-length res))
  (println-map "   headers:               " (:headers res)))



(defn- println-map [head data]
  (if (or (nil? data) (empty? data))
    (println head "-")
    (let [indent  (str/repeat " " (count head))
          tuples  (into '() data)
          format  (fn [tuple] (str (first tuple) ": " (second tuple)))]
      (println head (format (first tuples)))
      (doseq [t (rest tuples)] (println indent (format t))))))
