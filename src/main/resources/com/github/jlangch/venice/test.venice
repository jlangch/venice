;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2022 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Unit tests

;;;; (load-module :test)
;;;; (test/deftest add (assert-eq 3 (+ 1 2)))
;;;; (test/run-tests 'user)
;;;; ;; => Testing namespace 'user
;;;; ;; => PASS user/add
;;;; ;; => Ran 1 tests containing 1 assertions.
;;;; ;; => 0 failures, 0 errors.

;;;; (load-module :test)
;;;; (test/deftest add (assert-eq 3 (+ 1 2)))
;;;; (add)
;;;; ;; => PASS user/add

;;;; (load-module :test)
;;;; (test/deftest add (assert-eq 0 (+ 1 2)))
;;;; (test/run-tests 'user)
;;;; ;; => Testing namespace 'user
;;;; ;; => FAIL user/add
;;;; ;; => Test assert failure.
;;;; ;; => Exception in thread "main" AssertionException: Assert failed.
;;;; ;; => Expected: 0
;;;; ;; => Actual:   3
;;;; ;; => Expression:
;;;; ;; => (+ 1 2)
;;;; ;; =>
;;;; ;; => [Callstack]
;;;; ;; =>     at: assert-eq (user: line 1, col 30)
;;;; ;; =>     ...

;;;; This is a Venice port of Clojure's test framework.
;;;; (https://github.com/clojure/clojure/blob/master/src/clj/clojure/test.clj)

;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.


;; -----------------------------------------------------------------------------
;;                      W O R K   I N   P R O G R E S S
;; -----------------------------------------------------------------------------

(ns test)



(def-dynamic *testing-vars* (list))  ; bound to hierarchy of vars being tested

(def-dynamic *report-counters* nil)	 ; bound to a ref of a map in test-ns

(def-dynamic *test-out* *out*)       ; PrintWriter for test reporting output



;; -----------------------------------------------------------------------------
;; P U B L I C   A P I
;; -----------------------------------------------------------------------------

(defmacro
  ^{ :arglists '("(deftest name & body)" )
     :doc """
          Defines a test function with no arguments.

          Note: Actually, the test body goes in the :test metadata on the var,
          and the real function (the value of the var) calls test-var on
          itself.
          """
     :examples '(
          """
          (do
            (load-module :test)

            (ns foo)

            (defn sum [x y] (+ x y))
            (defn mul [x y] (* x y))

            (ns foo-test)

            (test/deftest sum-test []
              (assert-eq 0 (foo/sum 0 0))
              (assert-eq 3 (foo/sum 1 2)))

            (test/deftest mul-test []
              (assert-eq 6 (foo/mul 2 3)))

            (ns bar)
            (test/run-tests 'foo-test))
          """)
     :see-also '("test/run-tests", "test/run-test-var" ) }

  deftest [test-name & body]

  `(def ~(vary-meta test-name assoc :test-fn `(fn [] ~@body)
                                    :test-fn-name (str *ns* "/" test-name))
        (fn [] (test/test-var (var-get ~test-name)))))


(defn
  ^{ :arglists '("(run-tests & namespaces)" )
     :doc """
          Runs all tests in the given namespaces; prints results.
          Returns a map summarizing test results.
          """
     :examples '(
          """
          (do
            (ns foo)
            (load-module :test)

            (test/deftest plus-test []
              (assert-eq 3 (+ 1 2)))

            (test/run-tests 'foo))
          """)
     :see-also '("test/deftest", "test/run-test-var" ) }

  run-tests [& namespaces]

  (when (seq namespaces)
    (let [summary (assoc (apply merge-with + (map test-ns namespaces))
                         :type :summary)]
      (do-report summary)
      summary)))


(defn
  ^{ :arglists '("(run-test-var v)")
     :doc """
          Runs a single test; prints results. Returns a map summarizing the test
          results.
          """
     :examples '(
          """
          (do
            (load-module :test)

            (test/deftest plus-test []
              (assert-eq 3 (+ 1 2)))

            (test/run-test-var plus-test))
          """)
     :see-also '("test/deftest", "test/run-test-var" ) }

  run-test-var [v]

  (when (some? v)
    (binding [*report-counters*  {:test 0, :pass 0, :fail 0, :error 0, :assert 0}]
      (let [ns-sym (symbol (namespace v))]
        (do-report {:type :begin-test-ns, :ns ns-sym})
        (test-var v)
        (do-report {:type :end-test-ns, :ns ns-sym})
        (let [summary (assoc *report-counters* :type :summary)]
          (do-report summary)
          summary)))))



;; -----------------------------------------------------------------------------
;; I M P L E M E N T A T I O N
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(test-ns ns)" )
     :doc "Calls `test-vars` with all vars in the namespace ns" }

  test-ns [ns°]

  (binding [*report-counters*  {:test 0, :pass 0, :fail 0, :error 0, :assert 0}]
    (let [ns-sym (symbol (namespace ns°))]
      (do-report {:type :begin-test-ns, :ns ns-sym})
      (run! test-var (ns-list ns-sym))
      (do-report {:type :end-test-ns, :ns ns-sym})
      *report-counters*)))


(defn
  ^{ :arglists '("(test-var v)" )
     :doc "If v has a function in its :test metadata, calls that function." }

  test-var [v]

  (if-let [test-fn (:test-fn (meta v))]
    (let [test-name (:test-fn-name (meta v))]
      (binding [*testing-vars* (conj *testing-vars* v), *assertions* 0]
        (do-report {:type :begin-test-var, :fn-name test-name, :var v})
        (try (test-fn)
             (do-report {:type :pass, :fn-name test-name, :var v})
             (catch :AssertionException e
               (do-report {:type :fail
                           :fn-name test-name
                           :message "Test assert failure."
                           :ex e}))
             (catch :VncException e
               (do-report {:type :error
                           :fn-name test-name
                           :message "Uncaught exception, not in assertion."
                           :ex e})))
        (do-report {:type :end-test-var, :fn-name test-name, :var v})))
    (println *err* "Unable to resolve" (qualified-name v) "to a test function!")))


(defn
  ^{ :arglists '("(successful? summary)" )
     :doc """
          Returns true if the given test summary indicates all tests
          were successful, false otherwise.
          """ }

  successful? [summary]

  (and (zero? (:fail summary 0))
       (zero? (:error summary 0))))


;; reporting -------------------------------------------------------------------

(defn do-report [m]
  (binding [*out* *test-out*]
    (report m)))

(defn inc-report-counter [name]
  (when *report-counters*
    (set! *report-counters* (update *report-counters* name inc))))

(defn add-report-counter [name count]
  (when *report-counters*
    (set! *report-counters* (update *report-counters* name + count))))

(defmulti report :type)

(defmethod report :default [m]
  (prn m))

(defmethod report :pass [m]
  (inc-report-counter :pass)
  (add-report-counter :assert *assertions*)
  (println "\nPASS" (:fn-name m)))

(defmethod report :fail [m]
  (inc-report-counter :fail)
  (println "\nFAIL" (:fn-name m))
  (println (:message m))
  (println (ex-venice-stacktrace (:ex m))))

(defmethod report :error [m]
  (inc-report-counter :error)
  (println "\nERROR in" (:fn-name m))
  (println (:message m))
  (println (ex-venice-stacktrace (:ex m))))

(defmethod report :summary [m]
  (println "\nRan" (:test m) "tests with" (:assert m) "assertions")
  (println (:fail m) "failures," (:error m) "errors."))

(defmethod report :begin-test-ns [m]
  (println "\nTesting namespace" (str "'" (namespace (:ns m)))))

(defmethod report :begin-test-var [m]
  (inc-report-counter :test))

;; Ignore these message types:
(defmethod report :end-test-ns [m])
(defmethod report :end-test-var [m])
