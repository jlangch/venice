;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice ring
;;;;
;;;; Venice Ring is a port of Clojure's Ring web applications library
;;;; (https://github.com/ring-clojure/ring).


(ns ring)


(import :com.github.jlangch.venice.RingRedirectException
        :com.github.jlangch.venice.VncException
        :com.github.jlangch.venice.util.servlet.IVeniceServlet
        :com.github.jlangch.venice.util.servlet.VeniceServlet
        :com.github.jlangch.venice.util.servlet.FilterOutputStreamCloseCB)


;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(ring/redirect request url)")
     :doc "Redirect to the given URL." }

  redirect [request url]

  (when (ring/debug? request)
        (println (str "Redirect to: " url)))
  (throw (. :RingRedirectException :new url)))


(defn
  ^{ :arglists '("(ring/not-found-response)"
                 "(ring/not-found-response msg)")
     :doc "Create a HTTP Not-Found 404 response with content-type text/html. " }

  not-found-response

  ([] (ring/not-found-response "Not Found"))

  ([msg] { :status 404
           :headers { "Content-Type" "text/html; charset=utf-8" }
           :body """<html><body><p>~(str/escape-html msg)</p></body></html>""" }))


(defn
  ^{ :arglists '("(ring/get-request-parameter req name)")
     :doc """
          Returns the value of the specified request parameter. If the request
          did not include a parameter of the specified name, this method returns
          nil. If there are multiple parameters with the same name, this method
          returns the first parameter in the request.
          """ }

  get-request-parameter [req name]

  (first (get (:parameters req) name)))


(defn
  ^{ :arglists '("(ring/get-request-parameters req name)")
     :doc "Returns all the values of the specified request parameter as a list" }

  get-request-parameters [req name]

  (get (:parameters req) name))


(defn
  ^{ :arglists '("(ring/get-request-header req name)")
     :doc """
          Returns the value of the specified request header. If the request
          did not include a header of the specified name, this method returns
          nil. If there are multiple header with the same name, this method
          returns the first header in the request.
          """  }

  get-request-header [req name]

  (first (get (:headers req) name)))


(defn
  ^{ :arglists '("(ring/get-request-headers req name)")
     :doc "Returns all the values of the specified request header as a list." }

  get-request-headers [req name]

  (get (:headers req) name))


(defn
  ^{ :arglists '("(ring/get-request-header-accept-mimetypes req)")
     :doc """
          Returns all 'Accept' header mime-types of the request as a set.
          Strips off the ratings
          """ }

  get-request-header-accept-mimetypes [req]

  (into #{} (map #(first (str/split % " *; *"))
                 (get (:headers req) "Accept"))))


(defn
  ^{ :arglists '("(ring/debug? req)")
     :doc "Returns true if debugging is turned on else false" }

  debug? [req] (:debug req false))


(defn
  ^{ :arglists '("(ring/html-request? req)")
     :doc "Returns true if the request has content type 'text/html'" }

  html-request? [req]

  (match? (:content-type req) #"text/html(;.*)?"))


(defn
  ^{ :arglists '("(ring/json-request? req)")
     :doc "Returns true if the request has content type 'application/json'" }

  json-request? [req]

  (match? (:content-type req) #"application/json(;.*)?"))



;; -----------------------------------------------------------------------------
;; Multipart utils
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(ring/multipart-request? req)")
     :doc "Returns true if the request is a multipart request 'multipart/form-data'" 
     :see-also '( "ring/parts" "ring/parts-delete-all") }

  multipart-request? [req]

  (match? (:content-type req) #"multipart/form-data(;.*)?"))


(defn
  ^{ :arglists '("(ring/parts req)")
     :doc """
          Returns a list of parts of a multipart HTTP request. 

          A part is map with the fields:

          | [![width: 15%]] | [![width: 85%]] |
          | :name           | The name of the part |
          | :file-name      | The file-name of the part or *nil* if not available |
          | :size           | The size of the file |
          | :content-type   | The content type of the part |
          | :headers        | A map of part's headers. key: header name, \
                              value: list of header values. The header names \
                              are mapped to lower case.Â¶ \
                              Use `(first ("xxxx" :headers))` to get a \
                              single value header | 
          | :in-stream      | The content part as input stream |
          | :delete-fn      | A function that deletes the underlying storage \
                              for a file item, including deleting any \
                              associated temporary disk file. |

          The part list is empty if the request is not a multipart request.
          """
     :see-also '( "ring/multipart-request?" "ring/parts-delete-all") }

  parts [req] (:parts req))


(defn
  ^{ :arglists '("(ring/parts-delete-all req)")
     :doc """
          Safely deletes for all parts the underlying storage for the file 
          items, including deleting any associated temporary disk files.

          Calls the *delete-fn* on every part data map.
          """
     :see-also '( "ring/multipart-request?" "ring/parts" ) }

  parts-delete-all [req] 
  
  (doseq [p (:parts req)]
         (try 
           ((:delete-fn p))  ;; call the part's delete function
           (catch :Exception e))))
 



;; -----------------------------------------------------------------------------
;; Session utils
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(ring/session-invalidate req)")
     :doc "Invalidate the session"
     :see-also '( "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-invalidate [req]

  (if-let [session (:session req)]
    (when (ring/debug? req)
          (println (str "Session invalidated: " (. session :getId))))
    (. session :invalidate)))


(defn
  ^{ :arglists '("(ring/session-clear req)")
     :doc "Removes all attributes from the session"
     :see-also '( "ring/session-invalidate"
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-clear [req]

  (if-let [session (:session req)]
    (->> (. session :getAttributeNames)
         (java-enumeration-to-list)
         (docoll #(. session :removeAttribute %)))))


(defn
  ^{ :arglists '("(ring/session-id req)")
     :doc "Get the session ID"
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-id [req]

  (if-let [session (:session req)]
    (. session :getId)))


(defn
  ^{ :arglists '("(ring/session-set-value req name value)")
     :doc "Sets a value on the session"
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-set-value [req name value]

  ; wrap the Venice datatypes to prevent Java object conversions by
  ; Java Interop. We want the Venice datatype in the session
  (if-let [session (:session req)]
    (. session :setAttribute name (java-wrap value))))


(defn
  ^{ :arglists '("(ring/session-get-value req name)")
     :doc "Get a value from the session"
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-get-value [req name]

  (if-let [session (:session req)]
    (. session :getAttribute name)))


(defn
  ^{ :arglists '("(ring/session-remove-value req name)")
     :doc "Remove a value from the session"
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-last-access-time"
                  "ring/session-creation-time") }

  session-remove-value [req name]

  (if-let [session (:session req)]
    (. session :removeAttribute name)))


(defn
  ^{ :arglists '("(ring/session-last-access-time req)")
     :doc """
          Returns the time (milliseconds since epoch) when this session was 
          last accessed.
          """
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-creation-time") }

  session-last-access-time [req]

  (if-let [session (:session req)]
    (. session :getLastAccessedTime)))


(defn
  ^{ :arglists '("(ring/session-creation-time req)")
     :doc """
          Returns the time (milliseconds since epoch) when this session was 
          created.
          """
     :see-also '( "ring/session-invalidate" 
                  "ring/session-clear" 
                  "ring/session-id"
                  "ring/session-set-value"
                  "ring/session-get-value"
                  "ring/session-remove-value"
                  "ring/session-last-access-time") }

  session-creation-time [req]

  (if-let [session (:session req)]
    (. session :getCreationTime)))



;; -----------------------------------------------------------------------------
;; Middleware
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(ring/mw-identity handler)")
     :doc "Identity, does effectively just delegate to the handler"
     :see-also '( "ring/mw-debug" 
                  "ring/mw-print-uri"
                  "ring/mw-request-counter"
                  "ring/mw-add-session"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-identity [handler]

  (fn [req] (handler req)))


(defn
  ^{ :arglists '("(ring/mw-debug handler option)")
     :doc """
          Turns handler debug flag on the request on/off and then calls
          the handler with the modified request.
          """ 
     :see-also '( "ring/mw-identity"
                  "ring/mw-print-uri"
                  "ring/mw-request-counter"
                  "ring/mw-add-session"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-debug [handler option]

  (let [on (or (nil? option) (== option :on))]
    (fn [req]
      (handler (assoc req :debug on)))))


(defn
  ^{ :arglists '("(ring/mw-print-uri handler)")
     :doc "Prints the URI from the request and then calls the handler" 
     :see-also '( "ring/mw-identity" 
                  "ring/mw-debug"
                  "ring/mw-request-counter"
                  "ring/mw-add-session"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-print-uri [handler]

  (fn [req]
    (when (ring/debug? req)
          (println (str "URI: " (:uri req))))
    (handler req)))


(defn
  ^{ :arglists '("(ring/mw-request-counter handler)")
     :doc """
          Increments the number requests, stores it in the attribute
          'request-counter' in the session, and then calls the handler.
          """ 
     :see-also '( "ring/mw-identity" 
                  "ring/mw-debug" 
                  "ring/mw-print-uri"
                  "ring/mw-add-session"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-request-counter [handler]

  (fn [req]
    (let [id      (ring/session-id req)
          counter (inc (coalesce (ring/session-get-value req "request-counter") 0))]
      (ring/session-set-value req "request-counter" counter)
      (when (ring/debug? req)
            (println (str "Session " id ", request #: " counter))))
    (handler req)))


(defn
  ^{ :arglists '("(ring/mw-add-session handler timeout)")
     :doc """
          Adds the session to the request. If a new session is created
          the given timeout is set as the MaxInactiveInterval. If a
          timeout is not given the session will never timeout.

          Adds the session to the request and then calls the handler
          with the modified request.
          """ 
     :see-also '( "ring/mw-identity" 
                  "ring/mw-debug" 
                  "ring/mw-print-uri"
                  "ring/mw-request-counter"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-add-session [handler timeout]

  (fn [req]
    (let [session (. (:servlet-request req) :getSession true)]
      (when (. session :isNew)
            (when (ring/debug? req)
                  (println (str "Session " (. session :getId) " created")))
            (. session :setMaxInactiveInterval (coalesce timeout -1)))
      (handler (assoc req :session session)))))


(defn
  ^{ :arglists '("(ring/mw-dump-request handler)")
     :doc "Dumps the request and then calls the handler." 
     :see-also '( "ring/mw-identity" 
                  "ring/mw-debug" 
                  "ring/mw-print-uri"
                  "ring/mw-request-counter"
                  "ring/mw-add-session"
                  "ring/mw-dump-response") }

  mw-dump-request [handler]

  (fn [req]
    (ring/dump-request req)
    (handler req)))


(defn
  ^{ :arglists '("(ring/mw-dump-response handler)")
     :doc "Calls the handler and the dumps the handler's response." 
     :see-also '( "ring/mw-identity" 
                  "ring/mw-debug" 
                  "ring/mw-print-uri"
                  "ring/mw-request-counter"
                  "ring/mw-add-session"
                  "ring/mw-dump-request"
                  "ring/mw-dump-response") }

  mw-dump-response [handler]

  (fn [req]
    (let [res (handler req)]
      (ring/dump-response res)
      res)))


;; -----------------------------------------------------------------------------
;; Routing
;; -----------------------------------------------------------------------------


(defn
  ^{ :arglists '("(ring/match-routes routes)")
     :doc """
          Compile the routes and return a function that calls the handler
          matching the URI.

          A route is defined by a HTTP verb, a URI filter and a handle
          function. If multiple routes match the route with the longest
          URI filter will be chosen.
          
          ```
          (def routes [
            [:get    "/**"                   hello-world-handler]
            [:get    "/test/**"              test-handler]
            [:get    "/static/images/*.png"  image-handler]
            
            [:get    "/employees"             get-all-employees]
            [:get    "/employees/:id"         get-employee]
            [:post   "/employees"             create-employee]
            [:put    "/employees/:id"         update-employee]
            [:delete "/employees/:id"         delete-employee] ])
          ```
          
          Routing URI pattern filters:
          
          *  "/**"
          *  "/app/**"
          *  "/static/images/chart.png"
          *  "/static/images/*.png"
          *  "/static/**/*.png"

          A routing handler is single argument function that receives the
          request and returns a response.

          Handler request:

          | [![width: 15%]]     | [![width: 85%]] |
          | :server-port        | The server port. E.g.: 8080 |
          | :server-name        | The server name. E.g.: localhost |
          | :remote-addr        | The remote address. E.g.: "0:0:0:0:0:0:0:1" |
          | :uri                | The request URI. E.g.: "/employees" |
          | :query-string       | The query string |
          | :scheme             | The scheme {:http, :https } |
          | :request-method     | The lower case request method. \
                                  {:get, :post, :put, :delete, :head, :options, \
                                   :trace } |
          | :protocol           | The protocol. E.g. "HTTP/1.1" |
          | :headers            | A map of part's headers. Key: header name, \
                                  value: list of header values. The header \
                                  names are mapped to lower case.Â¶ \
                                  Use `(first ("xxxx" :headers))` to get a \
                                  single value header |
          | :parameters         | A name/value map of the request parameters | 
          | :cookies            | A map of the cookies. Key: cookie name, \
                                  value: the Java servlet cookie object |
          | :content-type       | The content type (may be nil) |
          | :content-length     | The content length |
          | :character-encoding | The character encoding |
          | :ssl-client-cert    | The client certificate, if available |
          | :parts              | A list of parts, empty for non multipart \
                                  requests |
          | :body               | The content part as input stream  |

          Handler response:

          ```
          { :status 400
            :headers { "Content-Type" "text/plain" }
            :body "Not a json request!" }
          ```
          
          Rigging up a Ring WEB App and starting Tomcat:

          ```
          (tc/run-tomcat
            (ring/create-servlet (-> (ring/match-routes routes)  ; >--+
                                                                 ;    |
                                     (ring/mw-dump-request)      ; ^  |
                                     (ring/mw-request-counter)   ; |  |
                                     (ring/mw-add-session 3600)  ; |  |
                                     (ring/mw-print-uri)         ; |  |
                                     (ring/mw-debug :on)))       ; +--+
            {:await? false})
          ```
          """
     :see-also '( "ring/create-servlet") }

  match-routes [routes]

  (let [compiled (ring/compile-routes routes)]
    (fn [req]
      (let [verb       (:request-method req)
            uri        (:uri req)
            req-params (:parameters req)
            route      (ring/get-route verb uri compiled)]
        (if route
          (let [handler    (:handler route)
                uri-params (zipmap (:uri-param-names route '())
                                    ((:uri-param-values route) uri))
                params     (merge req-params uri-params)
                req        (assoc req :parameters params)]
            (when (ring/debug? req)
                  (println (str "Route: " verb " \"" uri "\" -> " (name handler)))
                  (println (str "URI parameters: " uri-params)))
            (handler req))
          (ring/not-found-response))))))


;; -----------------------------------------------------------------------------
;; Ring Servlet
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(ring/create-servlet handler)")
     :doc """
          Create a ring servlet.
          """
     :see-also '( "ring/match-routes") }

  create-servlet [handler]

  (. :VeniceServlet :new
    (proxify :IVeniceServlet
      { :init      (fn [config] nil)
        :destroy   (fn [servlet] nil)
        :doGet     (fn [req res servlet] (ring/handle req res servlet handler))
        :doHead    (fn [req res servlet] (ring/handle req res servlet handler))
        :doPost    (fn [req res servlet] (ring/handle req res servlet handler))
        :doPut     (fn [req res servlet] (ring/handle req res servlet handler))
        :doDelete  (fn [req res servlet] (ring/handle req res servlet handler))
        :getLastModified (fn [req] -1) })))



;; -----------------------------------------------------------------------------
;; Header utils (internal)
;; -----------------------------------------------------------------------------

(def
  ^{ :doc "Pattern for pulling the charset out of the content-type header"
     :see-also '( "ring/charset") }

  regex-charset

  (regex/pattern ".*charset=([^\\s;]+).*"))


(defn
  ^{ :arglists '("(ring/parse-charset text)")
     :doc """
          Parses the charset from a header value

          E.g.: Returns `utf-8` for a content tye header like: 
          `Content-Type: text/html; charset=utf-8`
          """ }

  parse-charset [text]

  (let [m (regex/matcher ring/regex-charset text)]
    (when (regex/matches? m)
      (regex/group m 1))))


(defn-
  ^{ :arglists '("(ring/get-charset res)")
     :doc """
          Gets the character encoding of a Ring response.

          E.g.: Returns `utf-8` for a content tye header like: 
          `Content-Type: text/html; charset=utf-8`
          """ }

  get-charset [res]

  (if-let [content-type (ring/find-header res "Content-Type")]
    (let [m (regex/matcher ring/regex-charset content-type)]
      (when (regex/matches? m)
        (regex/group m 1)))))


(defn-
  ^{ :arglists '("(ring/find-header resp header-name)")
     :doc """
          Looks up a header in a Ring response (or request) case insensitively,
          returning the header map entry, or nil if not present.
          """  }

  find-header [resp header-name]

  (if (java-obj? resp)
    (. resp :getHeader header-name)
    (->> (:headers resp)
         (filter #(str/equals-ignore-case? header-name (key %)))
         (first))))


(defn-
  ^{ :arglists '("(ring/get-cookies req)")
     :doc "Return the HttpServletRequest cookies as a map" }

  get-cookies [req]

  (let [cookies (. req :getCookies)]
    (if cookies
      (reduce (fn [m c] (assoc m (. c :getName) c)) {} cookies)
      {})))


(defn-
  ^{ :arglists '("(ring/dump-request req)")
     :doc "Dumps the request." }

  dump-request [req]

  (println       "Dump request:")
  (println       "   server-port:  " (long (:server-port req)))
  (println       "   server-name:  " (:server-name req))
  (println       "   remote-addr:  " (:remote-addr req))
  (println       "   scheme:       " (:scheme req))
  (println       "   uri:          " (:uri req))
  (println       "   protocol:     " (:protocol req))
  (println       "   query-string: " (:query-string req))
  (println       "   method:       " (:request-method req))
  (println       "   content-type: " (:content-type req))
  (println       "   encoding:     " (:character-encoding req))
  (println       "   context-path: " (:servlet-context-path req))
  (println       "   servlet-path: " (:servlet-path req))
  (println       "   session:      " (ring/session-id req))
  (println-map   "   headers:      " (:headers req))
  (println-map   "   parameters:   " (:parameters req))
  (println-map   "   cookies:      " (map-vals :value (or (:cookies req) {})))
  (println-parts "   parts:        " (:parts req)))


(defn-
  ^{ :arglists '("(ring/dump-response res)")
     :doc "Dumps the response." }

  dump-response [res]

  (println     "Dump response:")
  (println     "   content-type: " (:content-type res))
  (println     "   encoding:     " (:character-encoding res))
  (println     "   status:       " (:status res))
  (println-map "   headers:      " (:headers res))
  (println-map "   cookies:      " (map-vals :value (or (:cookies res) {}))))


(defn- println-map [head data]
  (if (or (nil? data) (empty? data))
    (println head "-")
    (let [indent  (str/repeat " " (count head))
          tuples  (into '() data)
          format  (fn [tuple] (str (first tuple) ": " (second tuple)))]     
      (println head (format (first tuples)))
      (doseq [t (rest tuples)] (println indent (format t))))))


(defn- println-parts [head parts]
  (println head "-")
  (doseq [p parts]
         (println     "      name:            " (:name p))
         (println     "         file-name:    " (:file-name p))
         (println     "         content-type: " (:content-type p))
         (println     "         size:         " (:size p))
         (println-map "         headers:      " (:headers p))))



;; -----------------------------------------------------------------------------
;; Request/Response utils (internal)
;; -----------------------------------------------------------------------------

(defn-
  ^{ :arglists '("(ring/get-headers request)")
     :doc "Creates a name/value map of all the request headers." }

  get-headers [request]

  (reduce
    (fn [headers name]
      (assoc headers
        (str/lower-case name)
        (-> (. request :getHeaders name)
            (java-enumeration-to-list))))
    {}
    (java-enumeration-to-list (. request :getHeaderNames))))


(defn-
  ^{ :arglists '("(ring/get-parameters request)")
     :doc "Creates a name/value map of the request parameters." }

  get-parameters [request]

  (. request :getParameterMap))


(defn-
  ^{ :arglists '("(ring/get-content-length request)")
     :doc "Returns the content length, or nil if there is no content." }

  get-content-length [request]

  (let [length (. request :getContentLength)]
    (if (>= length 0) length nil)))


(defn-
  ^{ :arglists '("(ring/get-client-cert request)")
     :doc "Returns the SSL client certificate of the request, if one exists." }

  get-client-cert [request]

  (first (. request :getAttribute "javax.servlet.request.X509Certificate")))


(defn-
  ^{ :arglists '("(ring/set-response-headers response headers)")
     :doc "Update a HttpServletResponse with a map of headers." }

  set-response-headers [response headers]

  (docoll
    (fn [[key val-or-vals]]
      (if (string? val-or-vals)
          (. response :setHeader key val-or-vals)
          (docoll (fn [val] (. response :setHeader key val)) val-or-vals)))
    headers)
  ; Some headers must be set through specific methods
  (if-let [content-type (get headers "Content-Type")]
    (. response :setContentType content-type)))


(defn- make-output-stream [response  async-context]
  (let [os (. response :getOutputStream)]
    (if (nil? async-context)
      os
      (. :FilterOutputStreamCloseCB :new
        os
        (proxify :Runnable
                 {:run (fn [] (. context :complete))} )))))


(defn- make-blocking-service-method [handler]
  (fn [servlet request response]
    (-<> request
         (ring/build-request-map <>)
         (ring/merge-servlet-keys <> servlet request response)
         (handler <>)
         (ring/update-servlet-response response <>))))


(defn- make-async-service-method [handler]
  (fn [servlet request response]
    (let [async-context (. request :startAsync )]
      (handler
       (-> request
           (ring/build-request-map)
           (ring/merge-servlet-keys servlet request response))
       (fn [response-map]
         (ring/update-servlet-response response async-context response-map))
       (fn [exception]
         (. response :sendError 500 (. exception :getMessage))
         (. async-context :complete ))))))


(defn
  ^{ :arglists '("(ring/make-service-method handler)"
                 "(ring/make-service-method handler options)")
     :doc """
          Turns a handler into a function that takes the same arguments
          and has the same return value as the service method in the
          HttpServlet class.
          """ }
  make-service-method

  ([handler]
   (ring/make-service-method handler {}))

  ([handler options]
   (if (:async? options)
     (ring/make-async-service-method handler)
     (ring/make-blocking-service-method handler))))


(defn- write-body-to-stream [body response output-stream]
  (cond
    (string? body)
        (try-with [os output-stream]
          (if-let [charset (ring/get-charset response)]
            (io/spit-stream os body :flush true :encoding charset)
            (io/spit-stream os body :flush true)))

    (bytebuf? body)
        (try-with [os output-stream]
          (io/spit-stream os body :flush true))

    (instance-of? :java.io.InputStream body)
        (try-with [os output-stream]
          (io/copy-stream body os))

    (instance-of? :java.io.File body)
        (try-with [os output-stream]
          (io/copy-file body os))

    :else
        (try
          (. output-stream :close)
          (finally
            (. :RuntimeException :new
              (str
                "Response stream not supported for body type "
                                  (type body)))))))


(defn-
  ^{ :arglists '("(ring/update-servlet-response response response-map)"
                 "(ring/update-servlet-response response async-context response-map)")
     :doc "Update the HttpServletResponse using a response map." }

  update-servlet-response

  ([response response-map]
   (ring/update-servlet-response response nil response-map))

  ([response async-context response-map]
   (let [{:keys [status headers body]} response-map]
     (when (nil? response)
       (throw (. :NullPointerException :new "HttpServletResponse is nil")))
     (when (nil? response-map)
       (throw (. :NullPointerException :new "Response map is nil")))
     (when status
       (. response setStatus status))
     (ring/set-response-headers response headers)
     (let [output-stream (ring/make-output-stream response async-context)]
       (ring/write-body-to-stream body response-map output-stream)))))


(defn-
  ^{ :arglists '("(ring/build-request-map request)")
     :doc "Create the request map from the HttpServletRequest object." }

  build-request-map [request]

  (try 
    (let [content-type (. request :getContentType)
          multipart?   (match? (or content-type "") #"multipart/form-data(;.*)?")] 

      { :server-port        (. request :getServerPort)
        :server-name        (. request :getServerName)
        :remote-addr        (. request :getRemoteAddr)
        :uri                (. request :getRequestURI)
        :query-string       (. request :getQueryString)
        :scheme             (keyword (. request :getScheme))
        :request-method     (keyword (str/lower-case (. request :getMethod)))
        :protocol           (. request :getProtocol)
        :headers            (ring/get-headers request)
        :parameters         (ring/get-parameters request)
        :cookies            (ring/get-cookies request)
        :content-type       content-type
        :content-length     (ring/get-content-length request)
        :character-encoding (. request :getCharacterEncoding)
        :ssl-client-cert    (ring/get-client-cert request)
        :parts              (if multipart? (into [] (. request :getParts)) '())
        :body               (. request :getInputStream) } )

    (catch [:cause-type :java.lang.IllegalStateException] e
      (let [e (ex-cause e)]
        (if (= (ex-message e) "Unable to process parts as no multi-part configuration has been provided")
          (throw (ex :VncException 
                    """
                    The servlet is not configured for multi-part!

                    Please provide a multi-part configuration to the servlet:
                    
                    { :name                 "fileupload-servlet" 
                      :mapping              "/upload"

                      ;; multi-part configuration
                      :file-upload          true
                      :location             "/tmp"
                      :max-file-size        10485760
                      :max-request-size     10485760
                      :file-size-threshold  -1 } 
                    """)) 
          (throw e))))))


(defn-
  ^{ :arglists '("(ring/map-parts request)")
     :doc "Create a list of part maps from the HttpServletRequest object." }

  map-parts [request]

  (map map-part (. request :getParts)))


(defn- map-part [part]
  { :name         (. part :getName)
    :file-name    (let [v (. part :getHeader "Content-Disposition")
                        m (regex/matcher #".*filename=\"(.*)\"" v)]
                    (when (regex/matches? m)
                      (regex/group m 1)))
    :size         (. part :getSize)
    :content-type (. part :getContentType)
    :headers      (reduce
                    (fn [headers name]
                      (assoc headers
                             (str/lower-case name)
                             (into '() (. request :getHeaders name))))
                    {}
                    (into '() (. part :getHeaderNames)))
    :in-stream    (. part :getInputStream)
    :delete-fn    (fn [] (. part :delete)) })


(defn
  ^{ :arglists '("(ring/part-header-names part)")
     :doc "Gets the header names of the Part."
     :see-also '( "ring/part-name"
                  "ring/part-filename"
                  "ring/part-size"
                  "ring/part-content-type"
                  "ring/part-header"
                  "ring/part-headers"
                  "ring/part-in-stream"
                  "ring/part-delete"
                  "ring/part") }
 
  part-header-names [part] (. part :getHeaderNames))


(defn
  ^{ :arglists '("(ring/part-header part name)")
     :doc "Get the value of the specified mime header as a String." 
     :see-also '( "ring/part-name"
                  "ring/part-filename"
                  "ring/part-size"
                  "ring/part-content-type"
                  "ring/part-header-names"
                  "ring/part-headers"
                  "ring/part-in-stream"
                  "ring/part-delete"
                  "ring/part") }

  part-header [part name] (. part :getHeader name))


(defn
  ^{ :arglists '("(ring/part-headers part name)")
     :doc "Gets the values of the Part header with the given name."
     :see-also '( "ring/part-name"
                  "ring/part-filename"
                  "ring/part-size"
                  "ring/part-content-type"
                  "ring/part-header-names"
                  "ring/part-header"
                  "ring/part-in-stream"
                  "ring/part-delete"
                  "ring/part") }

  part-headers [part name] (into [] (. part :getHeaders name)))


 (defn-
   ^{ :arglists '("(ring/merge-servlet-keys request-map servlet request response)")
      :doc "Associate servlet-specific keys with the request map." }

   merge-servlet-keys [request-map servlet request response]

   (merge request-map
          {:servlet              servlet
           :servlet-request      request
           :servlet-response     response
           :servlet-context      (. servlet :getServletContext)
           :servlet-path         (. request :getServletPath)
           :servlet-context-path (. request :getContextPath) }))


;; -----------------------------------------------------------------------------
;; Routing (internal)
;; -----------------------------------------------------------------------------

(defn uri-matches-regex [regex uri]
  (regex/matches? (regex/matcher regex uri)))


(defn uri-filter-regex [uri-filter]
  ;; handles URIs like:
  ;; "/abc/**/*.png"
  ;;    1) split:     "/abc/" "**" "/" "*" ".png"
  ;;    2) escape:    "\\Q/abc/\\E" "**" "\\Q/\\E" "*" "\\Q.png\\E"
  ;;    3) translate: "\\Q/abc/\\E" ".*" "\\Q/\\E" "[^/]+" "\\Q.png\\E"
  ;;    4) join
  ;;    5) compile pattern
  (-<> uri-filter
       (str/split <> "((?<=[*]{2})|(?=[*]{2}))")
       (map #(if (== "**" %) % (str/split % "((?<=[*])|(?=[*]))")) <>)
       (flatten <>)
       (map #(if (or (== "**" %) (== "*" %)) % (str "\\Q" % "\\E")) <>)
       (map #(if (== "**" %) ".*" %) <>)
       (map #(if (== "*" %) "[^/]+" %) <>)
       (str/join "" <>)
       (regex/pattern <>)))


(defn uri-params-regex [uri-template]
  ;; handles URIs like:
  ;;   /users/:id
  ;;   /users/:id/playlists/:playlistid
  ;;    1) mark:      "/users/:PARAM/playlists/:PARAM"
  ;;    1) split:     "/users/" ":PARAM" "/playlists/" "*" ":PARAM"
  ;;    2) escape:    "\\Q/users/\\E" ":PARAM" " "\\Q/playlists/\\E" ":PARAM"
  ;;    3) translate: "\\Q/users/\\E" "([0-9a-zA-Z_]+)" " "\\Q/playlists/\\E" "([0-9a-zA-Z_]+)"
  ;;    4) join
  ;;    5) compile pattern
  (-<> uri-template
       (str/replace-all <> (regex/pattern ":[0-9a-zA-Z_]+") ":PARAM")
       (str/split <> "((?<=:PARAM)|(?=:PARAM))")
       (map #(if (== ":PARAM" %) % (str/split % "((?<=:PARAM)|(?=:PARAM))")) <>)
       (flatten <>)
       (map #(if (== ":PARAM" %) "([0-9a-zA-Z_]+)" (str "\\Q" % "\\E")) <>)
       (str/join "" <>)
       (regex/pattern <>)))


(defn- get-uri-param-names [uri-template]
  (-<> (regex/pattern ":[0-9a-zA-Z_]+")
       (regex/matcher <> uri-template)
       (regex/find-all <>)
       (map #(keyword %) <>)))


(defn- get-uri-param-values [uri-regex uri]
  (rest (regex/matches uri-regex uri)))


(defn compile-route-filter-uri [route]
  { :verb (first route)
    :uri (second route)
    :uri-regex (ring/uri-filter-regex (second route))
    :uri-param-names '()
    :uri-param-values (fn [uri] '())
    :len (count (second route))
    :handler (third route) })


(defn compile-route-params-uri [route]
  (let [regex (ring/uri-params-regex (second route))]
    { :verb (first route)
      :uri (second route)
      :uri-regex regex
      :uri-param-names (ring/get-uri-param-names (second route))
      :uri-param-values (fn [uri] (ring/get-uri-param-values regex uri))
      :len (count (second route))
      :handler (third route) }))


(defn compile-routes [routes]
 (map
   (fn [route]
       (if (str/contains? (second route) ":")
         (ring/compile-route-params-uri route)
         (ring/compile-route-filter-uri route)))
   routes))


(defn- priority-route [routes]
  (if (empty? routes)
    nil
    (last (sort #(compare (:len %1) (:len %2)) routes))))


(defn- get-route [verb uri routes]
  (ring/priority-route
    (filter (fn [route]
                (and (== verb (:verb route))
                     (ring/uri-matches-regex (:uri-regex route) uri)))
      routes)))


(defn
  ^{ :doc """
          Bootstrap the handler chain. Builds the request from then
          HttpServletRequest and calls the handler with the request.
          Builds the HttpServletResponse from the handler's response.
          Sends a not-found HTTP response if the handler returned a
          nil response. Sends a redirect if a handler raises a
          RingRedirectException. In case of any other exception sends
          an internal-error (HTTP status 500) response.
          """ }

  handle [req res servlet handler]

  (try
    (let [ring_req (-> req
                       (ring/build-request-map)
                       (ring/merge-servlet-keys servlet req res))
          ring_res (handler ring_req)]
      (if ring_res
        (do (ring/set-response-headers res (dissoc (:headers ring_res)))
            (ring/write-body-to-stream (:body ring_res) res (. res :getOutputStream)))
        (do (ring/send-not-found res))))
    (catch :RingRedirectException ex
      (ring/send-redirect req res (:redirectUri ex)))
    (catch :VncException ex
      (. ex :printVeniceStackTrace)
      (ring/send-error res))
    (catch :Exception ex
      (. ex :printStackTrace)
      (ring/send-error res))))



;; -----------------------------------------------------------------------------
;; Request/Response functions
;; -----------------------------------------------------------------------------

(defn- send-redirect [req res redirect-uri]
  (. res :sendRedirect (str (. req :getContextPath) redirect-uri)))


(defn- send-not-found [res]
  (. res :setStatus 404)
  (. res :setContentType "text/html; charset=utf-8")
  (-> (. res :getWriter)
      (. :println (html-box-page "Not Found"
                                 "the requested webpage was not found"))))


(defn- send-error [res]
  (. res :setStatus 500)
  (. res :setContentType "text/html; charset=utf-8")
  (-> (. res :getWriter)
      (. :println (html-box-page "Internal Error"
                                 "the request processing failed"))))


(defn html-box-page [title message]
  """
  <html>
    <head>
      <title>Tomcat/Ring</title>
      <style>
        body    {font-family: Arial, Helvetica, sans-serif;}
        .box    {margin-top: 120px; padding: 100px; text-align: center; background-color: #f8f8f8;}
        .title  {color: #cccccc; font-size: 90px;}
        .msg    {margin-top: 20px; color: #999999; font-size: 36px;}
      </style>
    </head>
    <body>
      <div class="box">
        <div class="title">~(str/escape-html (str title))</div>
        <div class="msg">~(str/escape-html (str message))</div>
      </div>
    </body>
  </html>
  """)
