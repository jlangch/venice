;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2025 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; A super simple logger

(ns logger)


(def linefeed (str/platform-lf))


;; -----------------------------------------------------------------------------
;; Logger
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(console-logger)",
          "(console-logger formatter)")
     :doc """
          Create a console logger with either the default log message formatter
          or a custom formatter.

          The console logger has the fix id `:console`
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; create the console logger
            (logger/console-logger)

            ;; get the :console logger
            (def log-console (logger/logger :console))

            ;; log some messages
            (log-console :info "test message")
            (log-console :info "kermit" "test message")
            (log-console :info "kermit" "test message" (ex :VncException "test exception")))
          """
          """
          (do
            (load-module :logger)

            ;; custom formatter
            (defn custom-formatter [level principal msg exc]
              (let [ex-msg (logger/format-ex exc)]
                (str/format "%s [%s] [%s] %s%n"
                            (time/format (time/local-date-time) "yyyy-MM-dd HH:mm:ss.SSS") 
                            (logger/format-level level)
                            (if (keyword? principal) (name principal) (str principal))
                            (if (nil? ex-msg) msg (str msg logger/linefeed ex-msg)))))

            ;; create the console logger with a custom formatter
            (logger/console-logger custom-formatter)

            ;; get the :console logger
            (def log-console (logger/logger :console))

            ;; log some messages
            (log-console :info "test message")
            (log-console :info "kermit" "test message")
            (log-console :info "kermit" "test message" (ex :VncException "test exception")))
          """)
     :see-also '(
          "logger/logger"
          "logger/file-logger"
          "logger/format-level"
          "logger/format-ex") }

  console-logger 

  ([] (console-logger nil))

  ([formatter]
    { :pre [(or (nil? formatter) (fn? formatter))] }
    (let [fmt             (coalesce formatter format-msg)
          level-threshold (volatile :debug)
          mutex           0]
      (register-logger
        { :id         :console
          :type       :console
          :formatter  fmt
          :level      level-threshold
          :handler    (fn [level principal msg exc] 
                        { :pre [(some? (level #{:debug :info :warn :error :fatal}))] }
                        (when (can-log? level @level-threshold)
                          (spit-to-stdout mutex (format fmt level principal msg exc))))
          :rotate     (fn [] false) } )
      nil)))


(defn 
  ^{ :arglists '(
          "(file-logger id file & options)")
     :doc """
          Create a file logger. The logger is identified by it's ID.

          Arguments:

          | id      | The mandatory logger ID. ID's are of type keyword |
          | file    | The mandatory file to log to. The parent dir must exist |

          Options:

          | :max-size n    | The max size of the file in bytes. If the size is \
                             reached, the file will be truncated at a line boundary \
                             to max size. -1 means there is no limit in size.Â¶\
                             The max size can be specified as a number like 20000 \
                             or a number with a unit like :20KB, :20MB, or :2GB|
          | :formatter f   | A custom formatter. Maybe `nil` to use the default \
                             formatter |
          | :rotate-mode k | A file rotation mode {:none, :daily, :montly}. \
                             Defaults to :none|
          | :rotate-dir f  | The file rotation directory. The directory must be \
                             specified and must exist if the rotate mode is :daily \
                             or :monthly. `nil` is passed for mode :none |
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; create the file loggers
            (logger/file-logger :venice "/data/logs/venice.log")
            (logger/file-logger :database "/data/logs/database.log" :max-size :20MB)

            ;; get the loggers
            (def log-venice (logger/logger :venice))
            (def log-database (logger/logger :database))

            ;; log some messages
            (log-venice :info "test message")
            (log-venice :info "kermit" "test message")
            (log-venice :info "kermit" "test message" (ex :VncException "test exception"))
            (log-database :info "test message"))
          """
          """
          (do
            (load-module :logger)

            ;; create the rotating file logger
            (logger/file-logger :venice 
                                "/data/logs/venice.log" 
                                :max-size :20MB 
                                :rotate-mode :daily 
                                :rotate-dir "/data/logs/archive")

            ;; get the logger
            (def log (logger/logger :venice))

            ;; log some messages
            (log :info "test message")
            (log :info "kermit" "test message")
            (log :info "kermit" "test message" (ex :VncException "test exception")))
          """
          """
          (do
            (load-module :logger)

            ;; custom formatter
            (defn custom-formatter [level principal msg exc]
              (let [ex-msg (logger/format-ex exc)]
                (str/format "%s [%s] [%s] %s%n"
                            (time/format (time/local-date-time) "yyyy-MM-dd HH:mm:ss.SSS") 
                            (logger/format-level level)
                            (if (keyword? principal) (name principal) (str principal))
                            (if (nil? ex-msg) msg (str msg logger/linefeed ex-msg)))))

            ;; create the file logger with a custom formatter
            (logger/file-logger :venice "/data/logs/venice.log" 
                                        :formatter custom-formatter)

            ;; get the :venice logger
            (def log (logger/logger :venice))

            ;; log some messages
            (log :info "test message")
            (log :info "kermit" "test message")
            (log :info "kermit" "test message" (ex :VncException "test exception")))
          """)
     :see-also '(
          "logger/logger"
          "logger/console-logger"
          "logger/format-level"
          "logger/format-ex") }

  file-logger [id file & options] 

  (let [opts                (apply hash-map options)
        max-size            (:max-size opts -1)
        max-size-hysteresis (:max-size-hysteresis opts 10) ;; default 10%
        formatter           (:formatter opts)
        rotate-mode         (:rotate-mode opts :none)
        rotate-dir          (:rotate-dir opts)]

    (validate-file-logger-args id file max-size max-size-hysteresis 
                               formatter rotate-mode rotate-dir)

    (let [max-size        (convert-to-bytes max-size)
          max-size        (if (pos? max-size) (max 100 max-size) -1)    ;; -1, 100, 101, ...
          max-size-hyst   (- 100 (clamp max-size-hysteresis 0 30))
          max-size-hyst   (if (pos? max-size) (* (/ max-size 100) max-size-hyst) -1) ;; hystersis
          fmt             (coalesce formatter format-msg)
          level-threshold (volatile :debug)
          mutex           0
          trunc-err-msg   (format fmt :error :system  "Failed to truncate log file" nil)]
      (register-logger
        { :id                 id
          :type               :file
          :file               (io/file file)
          :max-size           max-size 
          :max-size-hystersis max-size-hyst
          :formatter          fmt
          :rotate-mode        rotate-mode
          :rotate-dir         rotate-dir
          :level              level-threshold
          :handler            (fn [level principal msg exc] 
                                { :pre [(some? (level #{:debug :info :warn :error :fatal}))] }
                                (when (can-log? level @level-threshold)
                                  (spit-to-file mutex
                                                file 
                                                (format fmt level principal msg exc) 
                                                max-size 
                                                max-size-hyst
                                                trunc-err-msg)))
          :rotate             (fn [] 
                                (case rotate-mode
                                  :none    nil
                                  :daily   (rotate-log-by-day mutex id file rotate-dir)
                                  :monthly (rotate-log-by-month mutex id file rotate-dir)
                                  nil)) } )
      nil)))


(defn 
  ^{ :arglists '(
          "(logger id)")
     :doc """
          Returns the logger with the specified ID.

          The returned logger is a function with 2, 3, and 4 arguments to log 
          messages.

          2-arg log fn: `(fn [level msg] ...)` 

          3-arg log fn: `(fn [level principal msg] ...)`

          4-arg log fn: `(fn [level principal msg exc] ...)`

          The logger supports the levels :debug, :info, :warn, :error, and :fatal 

          If there is no logger with the specified id returns the default
          :console logger. 
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; create a file logger
            (logger/file-logger :venice "/data/logs/venice.log")

            ;; get the logger
            (def log (logger/logger :venice))

            ;; log some messages
            (log :info "test message")
            (log :info "kermit" "test message")
            (log :info "kermit" "test message" (ex :VncException "test")))
          """)
     :see-also '(
          "logger/console-logger"
          "logger/file-logger"
          "logger/format-level"
          "logger/format-ex") }

  logger [id]

  { :pre [(keyword? id)] }
  (let [l (id @loggers (default-logger))
        h (:handler l)]
    (fn ([]                        (h :info nil "" nil))
        ([msg]                     (h :info nil (str msg) nil))
        ([level msg]               (h level nil msg nil))
        ([level principal msg]     (h level principal msg nil))
        ([level principal msg exc] (h level principal msg exc)))))


(defn level
  ^{ :arglists '(
          "(level id)"
          "(level id new-level)")
     :doc """
          Returns or sets the log level of logger with the specified ID.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            (println (logger/level :console)) ;; get log level

            (logger/level :console :warn)  ;; set log level

            (println (logger/level :console))) ;; get log level
          """)
     :see-also '(
          "logger/level-all") }

  ([id]      
    (if-let [l (id @loggers)] @(:level l)))

  ([id new-level]
    { :pre [(some? (new-level #{:debug :info :warn :error :fatal}))] }
    (if-let [l (id @loggers)] (reset! (:level l) new-level))))


(defn 
  ^{ :arglists '(
          "(level-all new-level)")
     :doc """
          Sets the log level of all registered loggers.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            (println (logger/level :console)) ;; get log level

            (logger/level-all :warn)  ;; set log level

            (println (logger/level :console))) ;; get log level
          """)
     :see-also '(
          "logger/level") }

  level-all [new-level]

  { :pre [(some? (new-level #{:debug :info :warn :error :fatal}))] }
  (doseq [l (vals @loggers)] (reset! (:level l) new-level)))


(defn- can-log? [level-msg level-logger]
   (if (= level-logger :debug)  
     true
     (>= (level-msg levels) (level-logger levels))))


(defn- register-logger [logger]
  (swap! loggers assoc (:id logger) logger)

  ;; lazy start the rotation scheduler
  (when (and @auto-start-rotation-scheduler? (requires-rotation?))
    (start-rotation-scheduler)))


(defn- default-logger []
  (:console @loggers))


(defn- validate-file-logger-args [id file max-size max-size-hysteresis formatter rotate-mode rotate-dir]
  (let [err-msg "Failed to create file logger ~{id}!"]
    (assert (keyword? id) 
            "~{err-msg} The id must be a keyword!")
    (assert (or (string? file) (io/file? file)) 
            "~{err-msg} The file must be a string or an io/file!")
    (assert (io/exists-dir? (io/file-parent file)) 
            "~{err-msg} The files's parent directory does not exist!")
    (assert (or (long? max-size) (keyword? max-size)) 
            "~{err-msg} The max-size must be a long or a keyword (:10MB, : 2GB)!")
    (assert (long? max-size-hysteresis) 
            "~{err-msg} The max-size-hysteresis must be a long!")
    (assert (or (nil? formatter) (fn? formatter)) 
            "~{err-msg} The formatter must be nil or a function!")
    (assert (and (keyword? rotate-mode) (rotate-mode #{:none :daily :monthly})) 
            "~{err-msg} The rotate-mode must be a keyword {:none :daily :monthly}!")
    (assert (or (nil? rotate-dir) (string? rotate-dir) (io/file? rotate-dir)) 
            "~{err-msg} The rotate-dir must be nil, a string or a io/file!")
    (when (rotate-mode #{:daily :monthly})
      (assert (some? rotate-dir)
              "~{err-msg} The rotate-dir must not be nil with a rotate mode :daily or :monthly!")
      (assert (io/exists-dir? rotate-dir)
              "~{err-msg} The rotate-dir does not exist!"))))



;; -----------------------------------------------------------------------------
;; Log file rotation
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(rotation-scheduler-running?)")
     :doc """
          Returns `true` if a rotation scheduler is running else `false`. 

          The scheduler is started when the first file logger that has file
          rotation enabled is created!
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            (logger/file-logger :venice "/logs/venice.log" 
                                        :rotate-mode :daily 
                                        :rotate-dir "/logs/archive")

            ;; check after creation of the first file logger with file rotation
            (logger/rotation-scheduler-running?))
          """)
     :see-also '(
          "logger/enable-auto-start-rotation-scheduler"
          "logger/start-rotation-scheduler"
          "logger/rotate"
          "logger/rotate-all"
          "logger/requires-rotation?") }

  rotation-scheduler-running? []

  (deref rotation-scheduler-started?))


(defn 
  ^{ :arglists '(
          "(enable-auto-start-rotation-scheduler activate)")
     :doc """
          Enables or disables the auto starting of the rotation scheduler. 
          Default is deactivated. 

          If enabled, the scheduler starts when the first rotating file logger 
          is created. As long as no rotating file logger exists, the scheduler 
          remains inactive to conserve resources.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; disable auto start (auto start is enabled by default)
            (logger/enable-auto-start-rotation-scheduler false)

            (logger/file-logger :venice "/logs/venice.log"
                                        :rotate-mode :daily 
                                        :rotate-dir "/logs/archive")

            (def log (logger/logger :venice))

            (log :info "test message 1")
            (log :info "test message 2"))
          """)
     :see-also '(
          "logger/rotation-scheduler-running?"
          "logger/start-rotation-scheduler"
          "logger/rotate"
          "logger/rotate-all"
          "logger/requires-rotation?") }

  enable-auto-start-rotation-scheduler [activate]

  (reset! auto-start-rotation-scheduler? activate)
  
  ;; start the scheduler if rotating file loggers have been created early
  (when (and activate (requires-rotation?))
    (start-rotation-scheduler)))


(defn 
  ^{ :arglists '(
          "(start-rotation-scheduler)")
     :doc """
          Manually start the rotation scheduler. 

          Note: Consider to use `(logger/enable-auto-start-rotation-scheduler true)`
          instead of manually starting the scheduler.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; disable auto start (auto start is enabled by default)
            (logger/enable-auto-start-rotation-scheduler false)

            ;; start the scheduler manually
            (logger/start-rotation-scheduler)

            (logger/file-logger :venice "/logs/venice.log" 
                                        :rotate-mode :daily 
                                        :rotate-dir "/logs/archive")

            (def log (logger/logger :venice))

            (log :info "test message 1")
            (log :info "test message 2"))
          """)
     :see-also '(
          "logger/rotation-scheduler-running?"
          "logger/enable-auto-start-rotation-scheduler"
          "logger/rotate"
          "logger/rotate-all"
          "logger/requires-rotation?") }
  
  start-rotation-scheduler []

  ;; start the scheduler just once!
  (if (compare-and-set! rotation-scheduler-started? false true)
    (do
      (cron/schedule-at-round-times-in-day
          rotate-all
          (. :java.time.Duration :ofMinutes 10)    ;; sync period
          (. :java.time.Duration :ofHours 24))     ;; schedule period
      true)
    false)) 


(defn 
  ^{ :arglists '(
          "(rotate id)")
     :doc """
          Manually rotates the log file of the logger with the ID 'id' if the 
          logger has file rotation enabled.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; disable auto start (auto start is enabled by default)
            (logger/enable-auto-start-rotation-scheduler false)

            (logger/file-logger :venice "/logs/venice.log"
                                        :rotate-mode :daily
                                        :rotate-dir "/logs/archive")

            (def log (logger/logger :venice))

            (log :info "test message 1")
            (log :info "test message 2")

            ;; rotate the :venice logger manually
            (logger/rotate :venice))
          """)
     :see-also '(
          "logger/rotation-scheduler-running?"
          "logger/enable-auto-start-rotation-scheduler"
          "logger/start-rotation-scheduler"
          "logger/rotate-all"
          "logger/requires-rotation?") }

  rotate [id]

  { :pre [(keyword? id)] }
  (let [l (id @loggers (default-logger))
        r (:rotate l)]
    (r)))


(defn 
  ^{ :arglists '(
          "(rotate-all)")
     :doc """
          Manually rotates the log files of all loggers that have file rotation 
          enabled.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; disable auto start (auto start is enabled by default)
            (logger/enable-auto-start-rotation-scheduler false)

            (logger/file-logger :venice "/logs/venice.log"
                                        :rotate-mode :daily
                                        :rotate-dir "/logs/archive")

            (def log (logger/logger :venice))

            (log :info "test message 1")
            (log :info "test message 2")

            ;; rotate all loggers manually
            (logger/rotate-all))
          """)
     :see-also '(
          "logger/rotation-scheduler-running?"
          "logger/enable-auto-start-rotation-scheduler"
          "logger/start-rotation-scheduler"
          "logger/rotate"
          "logger/requires-rotation?") }

  rotate-all []

  (doseq [r (map :rotate (vals @loggers))] (try (r) (catch :Exception ex))))


(defn 
  ^{ :arglists '(
          "(requires-rotation?)")
     :doc """
          Returns `true` if there is at least on logger that has log file 
          rotation enabled. 
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            ;; disable auto start (auto start is enabled by default)
            (logger/enable-auto-start-rotation-scheduler false)

            (logger/file-logger :venice "/logs/venice.log"
                                        :rotate-mode :daily
                                        :rotate-dir "/logs/archive")

            (def log (logger/logger :venice))

            (log :info "test message 1")
            (log :info "test message 2")

            (logger/requires-rotation?))
          """)
     :see-also '(
          "logger/rotation-scheduler-running?"
          "logger/enable-auto-start-rotation-scheduler"
          "logger/start-rotation-scheduler"
          "logger/rotate"
          "logger/rotate-all") }

  requires-rotation? []

  (->> (vals @loggers)
       (map :rotate-mode)
       (filter #(or (= % :daily) (= % :monthly)))
       (not-empty?)))


(defn- rotate-log-by-day [mutex id file archive-dir]
  (locking mutex 
      (try
        (let [prev-day      (time/minus (time/local-date) :days 1)
              archive-base  (str/format "%s-%d-%02d-%02d" 
                                        (io/file-basename file) 
                                        (time/year prev-day)
                                        (time/month prev-day)
                                        (time/day-of-month prev-day))]
          (rotate-log id file archive-dir archive-base))
        (catch :Exception e 
               (let [log (id logger)]
                 (log :error :system (str "Log daily rotation failed. " (ex-message e)))
                 false)))))


(defn- rotate-log-by-month [mutex id file archive-dir]
  (if (first-day-of-month?)
    (locking mutex 
      (try
        (let [prev-day      (time/minus (time/local-date) :days 1)
              archive-base  (str/format "%s-%d-%02d" 
                                        (io/file-basename file) 
                                        (time/year prev-day) 
                                        (time/month prev-day))]
          (rotate-log id file archive-dir archive-base))
        (catch :Exception e 
            (let [log (id logger)]
              (log :error :system (str "Log monthly rotation failed. " (ex-message e)))
              false))))
    (let [log (logger id)]
      (log :debug :system "No monthly log file rotation today")
      false)))



(defn- rotate-log [id file archive-dir archive-base]
  (when (not (io/exists-dir? archive-dir))
    (throw (ex :VncException "The archive dir ~{archive-dir} does not exist!")))
  (if (io/exists-file? file)
    (loop [x 0]
      (when (> x 50)   ;; set an upper limit
        (throw (ex :VncException "Too many archive index files!")))
      (let [suffix  (if (zero? x) ".log" (str/format "-r%02d.log" x))
            archive (io/file archive-dir (str archive-base suffix))
            log     (logger id)]
        (if (io/exists-file? archive)
          (recur (inc x))
          (do 
            (io/move-file file archive)
            (log :info :system "Rotated log file")
            true))))
    false))



;; -----------------------------------------------------------------------------
;; Formatter
;; -----------------------------------------------------------------------------

(defn format [formatter level principal msg exc]
  (try
    (formatter level principal msg exc)
    (catch :Exception e "[Failed to format the log message]")))


(defn format-msg [level principal msg exc]
  (let [ex-msg (format-ex exc)]
    (str/format "%s|%s|%s|%s%n"
                (time/format (time/local-date-time) "yyyy-MM-dd HH:mm:ss.SSS") 
                (format-level level)
                (if (keyword? principal) (name principal) (str principal))
                (if (nil? ex-msg) msg (str msg linefeed ex-msg)))))


(defn 
  ^{ :arglists '(
          "(format-level level)")
     :doc """
          Formats a log level. level mus be a keyword!
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            (logger/format-level :info)
            (logger/format-level :warn))
          """) }

  format-level [level]

  (if (keyword? level)
    (str/upper-case (name level))
    "???"))


(defn 
  ^{ :arglists '(
          "(format-ex e)")
     :doc """
          Formats an exception. The exception my be a Venice exception or a
          Java exception. 
          
          Returns a Venice stack trace in the former case and a Java stack trace 
          in the ladder.
          """ 
     :examples '(
          """
          (do
            (load-module :logger)

            (logger/format-ex (ex :VncException "test")))
          """) }

  format-ex [e]

  (cond
    (nil? e)       nil
    (ex-venice? e) (ex-venice-stacktrace e)
    (ex? e)        (ex-java-stacktrace e)
    :else.         nil))



;; -----------------------------------------------------------------------------
;; Util
;; -----------------------------------------------------------------------------

(defn first-day-of-month? [] 
  (time/first-day-of-month? (time/local-date-time)))

(defn spit-to-stdout [mutex text]
  (locking mutex (print text)))

(defn spit-to-file [mutex file text max-size max-size-hyst truncate-err-msg]
  (locking mutex
    (io/spit file text :append true)
    (when (and (pos? max-size) (> (io/file-size file) max-size))
      (try
        (io/truncate-from-start-keep-lines file max-size-hyst)
        (catch :Exception ex (io/spit file truncate-err-msg :append true))))))

(defn convert-to-bytes [value]
  (let [err-msg "Invalid size value '~{value}'! Use 20000, 10MB, 2GB, ..."]
    (cond
      (long? value)     
          value
      (keyword? value)  
          (let [s (name value)]
            (cond 
              (match? s "^[1-9][0-9]*B$")   (long (str/strip-end s "B"))
              (match? s "^[1-9][0-9]*KB$")  (* (long (str/strip-end s "KB")) 1024)
              (match? s "^[1-9][0-9]*MB$")  (* (long (str/strip-end s "MB")) 1024 1024)
              (match? s "^[1-9][0-9]*GB$")  (* (long (str/strip-end s "GB")) 1024 1024 1024)
              :else (throw (ex :VncException err-msg))))
      :else 
          (throw (ex :VncException err-msg)))))



;; -----------------------------------------------------------------------------
;; Main
;; -----------------------------------------------------------------------------

(def- levels { :debug 0, :info 1, :warn 2, :error 3, :fatal 4 })

;; if true, start a rotation scheduler implicitely if a logger with file
;; rotation has been registered
(def- auto-start-rotation-scheduler? (atom true))

;; a map of all registered loggers (key: id, value: data map)
(def loggers (atom {}))

;; if true the rotation scheduler has been started 
(def- rotation-scheduler-started? (atom false))

;; register a default console logger
(console-logger nil)
