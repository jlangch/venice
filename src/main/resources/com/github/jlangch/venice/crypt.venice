;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2025 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Venice crypt functions


(ns crypt)

(import :java.util.Base64)
(import :java.security.MessageDigest)
(import :java.security.spec.AlgorithmParameterSpec)

(import :javax.crypto.Cipher)
(import :javax.crypto.SecretKey)
(import :javax.crypto.SecretKeyFactory)
(import :javax.crypto.spec.PBEKeySpec)
(import :javax.crypto.spec.IvParameterSpec)
(import :javax.crypto.spec.PBEParameterSpec)
(import :javax.crypto.spec.GCMParameterSpec)
(import :javax.crypto.spec.SecretKeySpec)
(import :javax.net.ssl.SSLServerSocketFactory)

(import :com.github.jlangch.venice.util.crypt.Encryptor_AES256_GCM)
(import :com.github.jlangch.venice.util.crypt.Encryptor_AES256_CBC)
(import :com.github.jlangch.venice.util.crypt.Encryptor_ChaCha20_BouncyCastle)
(import :com.github.jlangch.venice.util.crypt.Encryptor_ChaCha20)
(import :com.github.jlangch.venice.util.crypt.FileHasher)



;; -----------------------------------------------------------------------------
;; Hashing
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '(
          "(crypt/md5-hash data)"
          "(crypt/md5-hash data salt)")
     :doc """
          Hashes a string or a bytebuf using MD5 with an optional salt.

          Note: MD5 is not safe any more use PBKDF2 to hash passwords!
          """
     :examples (list
          """
          (-> (crypt/md5-hash "hello world")
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/md5-hash "hello world" "-salt-")
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/md5-hash "hello world")
              (str/encode-base64))
          """ )
     :see-also '(
          "crypt/sha1-hash"
          "crypt/sha512-hash"
          "crypt/pbkdf2-hash" ) }

  crypt/md5-hash

  ([data] (hash "MD5" data nil))
  ([data salt] (hash "MD5" data salt)))


(defn
  ^{ :arglists '(
          "(crypt/sha1-hash data)"
          "(crypt/sha1-hash data salt)")
     :doc "Hashes a string or a bytebuf using SHA1 with an optional salt."
     :examples (list
          """
          (-> (crypt/sha1-hash "hello world")
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/sha1-hash "hello world" "-salt-")
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/sha1-hash "hello world")
              (str/encode-base64))
          """ )
     :see-also '(
          "crypt/md5-hash"
          "crypt/sha512-hash"
          "crypt/pbkdf2-hash" )  }

  crypt/sha1-hash

  ([data] (hash "SHA-1" data nil))
  ([data salt] (hash "SHA-1" data salt)))


(defn
  ^{ :arglists '(
          "(crypt/sha512-hash data)"
          "(crypt/sha512-hash data salt)")
     :doc "Hashes a string or a bytebuf using SHA512 with an optional salt."
     :examples (list
          """
          (let [s (-> (crypt/sha512-hash "hello world")
                      (str/bytebuf-to-hex :upper))]
            (str (str/nfirst s 32) "..." (str/nlast s 32)))
          """,
          """
          (let [s (-> (crypt/sha512-hash "hello world" "-salt-")
                      (str/bytebuf-to-hex :upper))]
            (str (str/nfirst s 32) "..." (str/nlast s 32)))
          """,
          """
          (let [s (-> (crypt/sha512-hash "hello world")
                      (str/encode-base64))]
            (str (str/nfirst s 32) "..." (str/nlast s 32)))
          """ )
     :see-also '(
          "crypt/md5-hash"
          "crypt/sha1-hash"
          "crypt/pbkdf2-hash" )  }

  crypt/sha512-hash

  ([data] (hash "SHA-512" data nil))
  ([data salt] (hash "SHA-512" data salt)))


(defn
  ^{ :arglists '(
          "(crypt/pbkdf2-hash data salt)"
          "(crypt/pbkdf2-hash data salt iterations key-length)")
     :doc """
          Hashes a string using PBKDF2. iterations defaults to 1000,
          key-length defaults to 256.
          """
     :examples (list
          """
          (-> (crypt/pbkdf2-hash "hello world" "-salt-")
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/pbkdf2-hash "hello world" "-salt-" 1000 256)
              (str/bytebuf-to-hex :upper))
          """,
          """
          (-> (crypt/pbkdf2-hash "hello world" "-salt-")
              (str/encode-base64))
          """ )
     :see-also '(
          "crypt/md5-hash"
          "crypt/sha1-hash"
          "crypt/sha512-hash" )  }

  crypt/pbkdf2-hash

  ([text salt]
    (crypt/pbkdf2-hash text salt 1000 256))

  ([text salt iterations key-length]
    (assert (string? text)
            "The passed text must be a string")
    (assert (or (string? salt) (nil? salt))
            "The passed salt must be either a string or nil")
    (assert (or (long? iterations) (int? iterations))
            "The passed iterations must be either a long or an integer")
    (assert (or (long? key-length) (int? key-length))
            "The passed key-length must be either a long or an integer")
    (try
      (let [spec (. :PBEKeySpec :new
                    text
                    (if (nil? salt) (bytebuf) (bytebuf-from-string salt :UTF-8))
                    iterations
                    key-length)]
        (-> (. :SecretKeyFactory :getInstance "PBKDF2WithHmacSHA512")
            (. :generateSecret spec)
            (. :getEncoded)))
      (catch :Exception ex
             (throw (ex :VncException "Failed to compute PBKDF2 hash." ex))))))



;; -----------------------------------------------------------------------------
;; Encryption / decryption
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(crypt/encryptor-aes-256-gcm passphrase & opts)")
     :doc """
          Returns an encryptor function for AES 256 GCM encrypting/decrypting
          binary buffers or files.

          Options:

          | :key-salt arr        | An optional salt to generate the key.¶\
                                  E.g.: (bytebuf [ 43 195  99 118 231 225 142  76 \
                                                  132 194 129 237 158  12  12 203]|
          | :key-iterations n    | An optional iteration count to generate the key.¶\
                                   Defaults to 3000. |
          | :efficient-mem-use b | If `true` efficently use memory in encryption \
                                   (less memory allocation).¶\
                                   Defaults to `false`. |

          *IV* is random and unique for every call of the encryptor function.
                   
          While encrypting data the random *IV* is written to the start of the 
          encrypted data and read before decrypting the data
 
          ```
              AES256-GCM      
           AES/GCM/NoPadding  
          +-----------------+ 
          |     iv  (12)    | 
          +-----------------+ 
          |     data (n)    | 
          +-----------------+ 
          ```
          """
     :examples (list
          """
          ;; File
          (do
            (load-module :crypt) 
            (load-module :hexdump)
            (let [file-in       (io/temp-file "test-", ".data")
                  file-encoded  (io/temp-file "test-", ".data.enc")
                  file-decoded  (io/temp-file "test-", ".data.dec")
                  encryptor     (crypt/encryptor-aes-256-gcm "secret")]
              (io/delete-file-on-exit file-in file-encoded file-decoded)
              (io/spit file-in "1234567890")
              (encryptor :encrypt file-in file-encoded true)
              (encryptor :decrypt file-encoded file-decoded true)
              (println (hexdump/dump (io/slurp file-encoded :binary true)))))
          """,
          """
          ;; Byte buffer
          (do
            (load-module :crypt) 
            (let [buf-in      (bytebuf-from-string "1234567890")
                  encryptor   (crypt/encryptor-aes-256-gcm "secret")
                  buf-encoded (encryptor :encrypt buf-in)
                  buf-decoded (encryptor :decrypt buf-encoded)]
              (println (bytebuf-to-string buf-decoded))))
          """,
          """
          ;; Text (Base64 ecoded as either :Standard or :UrlSafe)
          (do
            (load-module :crypt) 
            (let [text        "1234567890"
                  encryptor   (crypt/encryptor-aes-256-gcm "secret")
                  encoded     (encryptor :encrypt text :Standard)
                  decoded     (encryptor :decrypt encoded :Standard)]
              (println decoded)))
          """) 
     :see-also '(
          "crypt/encryptor-chacha20-bouncycastle"
          "crypt/encryptor-chacha20" ) }

  encryptor-aes-256-gcm [passphrase & opts]

  (let [key-salt              (:key-salt opts)
        key-iterations        (:key-iterations opts)
        efficient-mem-use     (:efficient-mem-use opts false)
        e                     (if (or key-salt key-iterations)
                                 (. :Encryptor_AES256_GCM  
                                    :create passphrase key-salt key-iterations efficient-mem-use)
                                 (. :Encryptor_AES256_GCM 
                                    :create passphrase efficient-mem-use))]
    (fn encryptor
      ([mode in] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (bytebuf? in) "in arg must be a bytebuf")
          (. e mode in))
      ([mode in base64-schema] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (string? in) "in arg must be a bytebuf")
          (assert (get #{:Standard :UrlSafe} base64-schema) "base64 schema arg must be a :Standard or :UrlSafe}")
          (. e mode in base64-schema))
      ([mode in out overwrite?] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (io/file? in) "in arg must be a io/file")
          (assert (io/file? out) "out arg must be a io/file")
          (assert (boolean? overwrite?) "overwrite? arg must be a boolean")
          (. e mode in out overwrite?)))))

(defn encryptor-aes-256-gcm-supported? []
   (. :Encryptor_AES256_GCM :supported))



(defn 
  ^{ :arglists '(
          "(crypt/encryptor-aes-256-cbc passphrase & opts)")
     :doc """
          Returns an encryptor function for AES 256 CBC encrypting/decrypting
          binary buffers or files.

          **DO NOT USE this cipher AES CBC in production!**

          **AES CBC with PKCS5Padding padding scheme can lead to padding oracle attacks.**

          Options:

          | :key-salt arr            | An optional salt to generate the key.¶\
                                       E.g.: (bytebuf [ 43 195  99 118 231 225 142  76 \
                                                       132 194 129 237 158  12  12 203]|
          | :key-iterations n        | An optional iteration count to generate the key.¶\
                                       Defaults to 3000.   |
          | :custom-iv arr           | An optional custom IV bytebuf (12 bytes).¶\
                                       E.g.: (bytebuf [ 01 195  33 118 44 225 142  76 158  12  12 203]¶\
                                       Without custom-iv a new random IV is generated for \
                                       every encryption call|
          | :custom-iv-add-to-data b | If `true` add the custom IV to the encrypted data|                                

          *IV* is random and unique for every call of encryptor function.
                   
          While encrypting data the random *IV* is written to the start of the 
          encrypted data and read before decrypting the data
 
          ```
              AES256-CBC               AES256-CBC            AES256-CBC
          AES/CBC/PKCS5Padding    AES/CBC/PKCS5Padding    AES/CBC/PKCS5Padding
              random IV            custom ID, added       custom ID, not added
          +------------------+    +------------------+    +------------------+
          |      iv  (16)    |    |      iv  (16)    |    |      data (n)    |
          +------------------+    +------------------+    +------------------+
          |      data (n)    |    |      data (n)    |
          +------------------+    +------------------+
          ```
          """
     :examples (list
          """
          ;; File
          (do
            (load-module :crypt) 
            (load-module :hexdump)
            (let [file-in       (io/temp-file "test-", ".data")
                  file-encoded  (io/temp-file "test-", ".data.enc")
                  file-decoded  (io/temp-file "test-", ".data.dec")
                  encryptor     (crypt/encryptor-aes-256-cbc "secret")]
              (io/delete-file-on-exit file-in file-encoded file-decoded)
              (io/spit file-in "1234567890")
              (encryptor :encrypt file-in file-encoded true)
              (encryptor :decrypt file-encoded file-decoded true)
              (println (hexdump/dump (io/slurp file-encoded :binary true)))))
          """,
          """
          ;; Byte buffer
          (do
            (load-module :crypt) 
            (let [buf-in    (bytebuf-from-string "1234567890")
                  encryptor (crypt/encryptor-aes-256-cbc "secret")
                  buf-encoded (encryptor :encrypt buf-in)
                  buf-decoded (encryptor :decrypt buf-encoded)]
              (println (bytebuf-to-string buf-decoded))))
          """,
          """
          ;; Text (Base64 ecoded as either :Standard or :UrlSafe)
          (do
            (load-module :crypt) 
            (let [text        "1234567890"
                  encryptor   (crypt/encryptor-aes-256-cbc "secret")
                  encoded     (encryptor :encrypt text :Standard)
                  decoded     (encryptor :decrypt encoded :Standard)]
              (println decoded)))
          """) 
     :see-also '(
          "crypt/encryptor-chacha20-bouncycastle"
          "crypt/encryptor-chacha20" ) }

  encryptor-aes-256-cbc [passphrase & opts]

  (let [key-salt              (:key-salt opts)
        key-iterations        (:key-iterations opts)
        custom-iv             (:custom-iv opts)
        custom-iv-add-to-data (coalesce (:custom-iv-add-to-data opts) false)
        e                     (if (or key-salt key-iterations custom-iv)
                                 (. :Encryptor_AES256_CBC  
                                    :create passphrase 
                                            key-salt key-iterations
                                            custom-iv custom-iv-add-to-data )
                                 (. :Encryptor_AES256_CBC 
                                    :create passphrase))]
    (fn encryptor
      ([mode in] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (bytebuf? in) "in arg must be a bytebuf")
          (. e mode in))
      ([mode in base64-schema] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (string? in) "in arg must be a bytebuf")
          (assert (get #{:Standard :UrlSafe} base64-schema) "base64 schema arg must be a :Standard or :UrlSafe}")
          (. e mode in base64-schema))
      ([mode in out overwrite?] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (io/file? in) "in arg must be a io/file")
          (assert (io/file? out) "out arg must be a io/file")
          (assert (boolean? overwrite?) "overwrite? arg must be a boolean")
          (. e mode in out overwrite?)))))

(defn encryptor-aes-256-cbc-supported? []
   (. :Encryptor_AES256_CBC :supported))


(defn 
  ^{ :arglists '(
          "(crypt/encryptor-chacha20-bouncycastle passphrase & opts)")
     :doc """
          Returns an encryptor function for ChaCha20 BouncyCastle 
          encrypting/decryptingbinary buffers or files.
          
          Requires the BouncyCastle libraries on the classpath.

          Options:

          | :key-salt arr     | An optional salt to generate the key.¶\
                                E.g.: (bytebuf [ 43 195  99 118 231 225 142  76 \
                                                132 194 129 237 158  12  12 203]|
          | :key-iterations n | An optional iteration count to generate the key.¶\
                                Defaults to 3000.   |

          Warning: files encrypted with ChaCha20 BouncyCastle cannot be
          by ChaCha20 from the Java VM (and vice versa) due to different initial
          counter handling and IV sizes

          The ChaCha family of ciphers are an oder of magnitude more efficient 
          on servers that do not provide hardware acceleration. Apple Silicon
          does not seem to have AES hardware acceleration probably due to its 
          RISC nature. 

          *IV*, *Nonce* and *Counter* are random and unique for every 
          call of encryptor function.
          
          While encrypting a file the *IV*, *Nonce* and *Counter* are written 
          to the start of the encrypted data and read before decrypting the 
          data:
 
          ```
          ChaCha20 Bouncy Castle    
          +--------------------+
          |        iv (8)      |
          +--------------------+
          |      nonce (12)    |
          +--------------------+
          |     counter (4)    | 
          +--------------------+
          |      data (n)      | 
          +--------------------+
          ```
          """
     :examples (list
          """
          ;; File
          (do
            (load-module :crypt) 
            (load-module :hexdump)
            (let [file-in       (io/temp-file "test-", ".data")
                  file-encoded  (io/temp-file "test-", ".data.enc")
                  file-decoded  (io/temp-file "test-", ".data.dec")
                  encryptor     (crypt/eencryptor-chacha20-bouncycastle "secret")]
              (io/delete-file-on-exit file-in file-encoded file-decoded)
              (io/spit file-in "1234567890")
              (encryptor :encrypt file-in file-encoded true)
              (encryptor :decrypt file-encoded file-decoded true)
              (println (hexdump/dump (io/slurp file-encoded :binary true)))))
          """,
          """
          ;; Byte buffer
          (do
            (load-module :crypt) 
            (let [buf-in    (bytebuf-from-string "1234567890")
                  encryptor (crypt/encryptor-chacha20-bouncycastle "secret")
                  buf-encoded (encryptor :encrypt buf-in)
                  buf-decoded (encryptor :decrypt buf-encoded)]
              (println (bytebuf-to-string buf-decoded))))
          """,
          """
          ;; Text (Base64 ecoded as either :Standard or :UrlSafe)
          (do
            (load-module :crypt) 
            (let [text        "1234567890"
                  encryptor   (crypt/encryptor-chacha20-bouncycastle "secret")
                  encoded     (encryptor :encrypt text :Standard)
                  decoded     (encryptor :decrypt encoded :Standard)]
              (println decoded)))
          """) 
     :see-also '(
          "crypt/encryptor-aes-256-gcm"
          "crypt/encryptor-chacha20"
          "crypt/add-bouncy-castle-provider"
          "crypt/provider?" ) }

  encryptor-chacha20-bouncycastle [passphrase & opts]

  (let [key-salt        (:key-salt opts)
        key-iterations  (:key-iterations opts)
        e               (if (or key-salt key-iterations)
                          (. :Encryptor_ChaCha20_BouncyCastle :create passphrase key-salt key-iterations)
                          (. :Encryptor_ChaCha20_BouncyCastle :create passphrase))]
    (when-not (. :Encryptor_ChaCha20 :isSupported)
      (throw (ex :VncException "BouncyCastle Crypto algorithm ChaCha20 is not available!")))
    (fn encryptor
      ([mode in] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (bytebuf? in) "in arg must be a bytebuf")
          (. e mode in))
      ([mode in base64-schema] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (string? in) "in arg must be a bytebuf")
          (assert (get #{:Standard :UrlSafe} base64-schema) "base64 schema arg must be a :Standard or :UrlSafe}")
          (. e mode in base64-schema))
      ([mode in out overwrite?] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (io/file? in) "in arg must be a io/file")
          (assert (io/file? out) "out arg must be a io/file")
          (assert (boolean? overwrite?) "overwrite? arg must be a boolean")
          (. e mode in out overwrite?)))))

(defn encryptor-chacha20-bouncycastle-supported? []
   (. :Encryptor_ChaCha20_BouncyCastle :supported))


(defn 
  ^{ :arglists '(
          "(crypt/encryptor-chacha20 passphrase & opts)")
     :doc """
          Returns an encryptor function for ChaCha20 encrypting/decrypting
          binary buffers or files.
          
          Requires Java11+.

          Options:

          | :key-salt arr     | An optional salt to generate the key.¶\
                                E.g.: (bytebuf [ 43 195  99 118 231 225 142  76 \
                                                132 194 129 237 158  12  12 203]|
          | :key-iterations n | An optional iteration count to generate the key.¶\
                                Defaults to 3000.   |

          Warning: files encrypted with ChaCha20 BouncyCastle cannot be
          by ChaCha20 from the Java VM (and vice versa) due to different initial
          counter handling and IV sizes

          The ChaCha family of ciphers are an oder of magnitude more efficient 
          on servers that do not provide hardware acceleration. Apple Silicon
          does not seem to have AES hardware acceleration probably due to its 
          RISC nature. 

          *IV*, *Nonce* and/or *Counter* are random and unique for every 
          call of the encryptor function.
          
          While encrypting a file the *IV*, *Nonce* and *Counter* are written 
          to the start of the encrypted data and read before decrypting the 
          data:
 
          ```
                ChaCha20        
          +--------------------+
          |       iv (12)      |
          +--------------------+
          |      nonce (12)    |
          +--------------------+
          |     counter (4)    | 
          +--------------------+
          |      data (n)      | 
          +--------------------+
          ```
          """
     :examples (list
          """
          ;; File
          (do
            (load-module :crypt) 
            (load-module :hexdump)
            (let [file-in       (io/temp-file "test-", ".data")
                  file-encoded  (io/temp-file "test-", ".data.enc")
                  file-decoded  (io/temp-file "test-", ".data.dec")
                  encryptor     (crypt/encryptor-chacha20 "secret")]
              (io/delete-file-on-exit file-in file-encoded file-decoded)
              (io/spit file-in "1234567890")
              (encryptor :encrypt file-in file-encoded true)
              (encryptor :decrypt file-encoded file-decoded true)
              (println (hexdump/dump (io/slurp file-encoded :binary true)))))
          """,
          """
          ;; Byte buffer
          (do
            (load-module :crypt) 
            (let [buf-in    (bytebuf-from-string "1234567890")
                  encryptor (crypt/encryptor-chacha20 "secret")
                  buf-encoded (encryptor :encrypt buf-in)
                  buf-decoded (encryptor :decrypt buf-encoded)]
              (println (bytebuf-to-string buf-decoded))))
          """,
          """
          ;; Text (Base64 ecoded as either :Standard or :UrlSafe)
          (do
            (load-module :crypt) 
            (let [text        "1234567890"
                  encryptor   (crypt/encryptor-chacha20 "secret")
                  encoded     (encryptor :encrypt text :Standard)
                  decoded     (encryptor :decrypt encoded :Standard)]
              (println decoded)))
          """) 
     :see-also '(
          "crypt/encryptor-aes-256-gcm"
          "crypt/encryptor-chacha20-bouncycastle" ) }

  encryptor-chacha20 [passphrase & opts]

  (let [key-salt        (:key-salt opts)
        key-iterations  (:key-iterations opts)
        e               (if (or key-salt key-iterations)
                          (. :Encryptor_ChaCha20 :create passphrase key-salt key-iterations)
                          (. :Encryptor_ChaCha20 :create passphrase))]
    (when-not (. :Encryptor_ChaCha20 :isSupported)
      (throw (ex :VncException "Java Crypto algorithm ChaCha20 is not available!")))
    (fn encryptor
      ([mode in] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (bytebuf? in) "in arg must be a bytebuf")
          (. e mode in))
      ([mode in base64-schema] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (string? in) "in arg must be a bytebuf")
          (assert (get #{:Standard :UrlSafe} base64-schema) "base64 schema arg must be a :Standard or :UrlSafe}")
          (. e mode in base64-schema))
      ([mode in out overwrite?] 
          (assert (get #{:encrypt :decrypt} mode) "mode arg must be :encrypt or :decrypt")
          (assert (io/file? in) "in arg must be a io/file")
          (assert (io/file? out) "out arg must be a io/file")
          (assert (boolean? overwrite?) "overwrite? arg must be a boolean")
          (. e mode in out overwrite?)))))

(defn encryptor-chacha20-supported? []
   (. :Encryptor_ChaCha20 :supported))



;; -----------------------------------------------------------------------------
;; File hashing
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '(
          "(crypt/hash-file algorithm salt file)")
     :doc """
          Computes a hash for a file. The hash is used together with the 
          function `crypt/verify-file-hash` to detect file modifications.

          Returns the hash Base64 encoded.

          The functions uses the fast MD5 hash algorithm.

          The arg 'file' may be a:
          
          * string file path, e.g: "/temp/foo.json"
          * bytebuf
          * `java.io.File`, e.g: `(io/file "/temp/foo.json")`
          * `java.io.InputStream`
 
          Supported hash algorithms:

          * MD5 (default)
          * SHA-1
          * SHA-512

          MD5 is the fastest hash algorithm and precise enough to detect file
          changes.
         """
     :examples (list
          """
          (do
            (load-module :crypt) 
            (let [file (io/temp-file "test-", ".data")
                  data (bytebuf-allocate-random 1000)] 
              (io/delete-file-on-exit file)
              (io/spit file data)
              (crypt/hash-file "SHA-256" "-salt-" file))) 
          """) 
     :see-also '(
          "crypt/verify-file-hash" ) }

  hash-file [algorithm salt file]

  (assert (string? algorithm) "The algorithm must be a string")
  (assert (string? salt) "The salt must be a string")
  (. :FileHasher :hashFile algorithm salt (io/slurp file :binary true)))


(defn 
  ^{ :arglists '(
          "(crypt/verify-file-hash algorithm salt file hash)")
     :doc """
          Verifies a file against a hash (Base64 encoded). Returns true if the
          file's actual hash is equal to the given hash otherwise false.
 
          The arg 'file' may be a: 

          * string file path, e.g: "/temp/foo.json"
          * bytebuf
          * `java.io.File`, e.g: `(io/file "/temp/foo.json")`
          * `java.io.InputStream`

          Supported hash algorithms:

          * MD5
          * SHA-1
          * SHA-512

          Warning: The MD5 hash function’s security is considered to be 
          severely compromised. Collisions can be found within seconds, 
          and they can be used for malicious purposes. 
          """
     :examples (list
          """
          (do
            (load-module :crypt) 
            (let [file (io/temp-file "test-", ".data")
                  data (bytebuf-allocate-random 1000)
                  salt "salt"] 
              (io/delete-file-on-exit file)
              (io/spit file data)
              (let [hash (crypt/hash-file "SHA-256" "-salt-" file)]
                (crypt/verify-file-hash "SHA-256" "-salt-" file hash))))
          """) 
     :see-also '(
          "crypt/hash-file" ) }

  verify-file-hash [algorithm salt file hash]

  (assert (string? algorithm) "The algorithm must be a string")
  (assert (string? salt) "The salt must be a string")
  (assert (string? hash) "The hash must be a string")
  (. :FileHasher :verifyFileHash algorithm salt (io/slurp file :binary true) hash))



;; -----------------------------------------------------------------------------
;; Ciphers
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '(
          "(crypt/max-key-size algorithm)")
     :doc """
          Returns the max allowed key size
          """
     :examples (list
          """
          (do
            (load-module :crypt)
            (crypt/max-key-size "AES"))
          """ ) }

  crypt/max-key-size [algorithm]

  (. :Cipher :getMaxAllowedKeyLength algorithm))


(defn
  ^{ :arglists '(
          "(crypt/ciphers)",
          "(crypt/ciphers opt)")
     :doc """
          Returns a list of the ciphers the Java VM supports

          Argument opt

          | :default   | returns the names of the cipher suites which are \
                         enabled by default. |
          | :available | returns the names of the cipher suites which could be \
                         enabled for use on an SSL connection created by this \
                         `SSLServerSocketFactory`. |
          """
     :examples (list
          """
          (do
            (load-module :crypt)
            (crypt/ciphers :default))
          """,
          """
          (do
            (load-module :crypt)
            (crypt/ciphers :available))
          """,
          """
          (do
            (load-module :crypt)
            (docoll println (crypt/ciphers :available)))
          """ ) }

  crypt/ciphers

  ([] (crypt/ciphers :available))

  ([opt]  (let [ssf    (cast :SSLServerSocketFactory
                             (. :SSLServerSocketFactory :getDefault))
                method (if (== opt :default)
                          :getDefaultCipherSuites
                          :getSupportedCipherSuites)]
            (sort (. ssf method)))))


(defn
  ^{ :arglists '(
          "(crypt/provider? name)")
     :doc """
          Returns true if the Java security provider with name exists, else 
          false.
          """
     :examples (list
          """
          (do
            (load-module :crypt)

            ;; BouncyCastle provider available?
            (crypt/provider? "BC"))  
          """ )
     :see-also '( 
          "crypt/add-bouncy-castle-provider" ) }

  crypt/provider? [name]

  (some? (. :java.security.Security :getProvider name)))
  


(defn
  ^{ :arglists '(
          "(crypt/add-bouncy-castle-provider)")
     :doc """
          Adds the BouncyCastle provider to the Java security.
          """
     :examples (list
          """
          (do
            (load-module :crypt)
            (crypt/add-bouncy-castle-provider))
          """ ) 
     :see-also '( 
          "crypt/provider?" ) }

  crypt/add-bouncy-castle-provider []

  (. :Encryptor_ChaCha20_BouncyCastle :addBouncyCastleProvider))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn- to-bytes [data]
  (if (string? data) (bytebuf-from-string data :UTF-8) data))



(defn- crypt/hash

  ([algorithm data]
    (hash algorithm data nil))

  ([algorithm data salt]
    (assert (or (string? data) (bytebuf? data))
            "The passed data must be either a string or a bytebuf")
    (assert (or (string? salt) (bytebuf? salt) (nil? salt))
            "The passed salt must be either a string, a bytebuf or nil")
    (try
      (let [md (. :MessageDigest :getInstance algorithm)]
        (. md :reset)
        (when (some? salt)
          (. md :update (to-bytes salt)))
        (. md :update (to-bytes data))
        (. md :digest))
      (catch :Exception ex
             (throw (ex :VncException
                        (str "Failed to compute " algorithm " hash.")
                        ex))))))
