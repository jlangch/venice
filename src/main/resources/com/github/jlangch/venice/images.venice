;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Image functions

(ns images)

(import :java.awt.Color
        :java.awt.Graphics
        :java.awt.Graphics2D
        :java.awt.Image
        :java.awt.RenderingHints
        :java.awt.Transparency
        :java.awt.color.ColorSpace
        :java.awt.geom.AffineTransform
        :java.awt.geom.Rectangle2D
        :java.awt.image.AreaAveragingScaleFilter
        :java.awt.image.BufferedImage
        :java.awt.image.BufferedImageOp
        :java.awt.image.ColorConvertOp
        :java.awt.image.ColorModel
        :java.awt.image.ConvolveOp
        :java.awt.image.ImagingOpException
        :java.awt.image.IndexColorModel
        :java.awt.image.Kernel
        :java.awt.image.RasterFormatException
        :java.awt.image.RescaleOp)

(import :javax.imageio.ImageIO
        :javax.imageio.stream.FileImageInputStream
        :javax.imageio.spi.IIORegistry
        :javax.imageio.spi.ImageWriterSpi)


;; -----------------------------------------------------------------------------
;; Constants
;; -----------------------------------------------------------------------------

(def TYPE_INT_RGB  (. :BufferedImage :TYPE_INT_RGB))
(def TYPE_INT_ARGB (. :BufferedImage :TYPE_INT_ARGB))
(def OPAQUE        (. :Transparency :OPAQUE))



;; -----------------------------------------------------------------------------
;; Imaging operators
;; -----------------------------------------------------------------------------

(def convolve-op-antialias (. :ConvolveOp 
                                 :new 
                                 (. :Kernel :new 3 3 [ 0.00F, 0.08F, 0.00F, 
                                                       0.08F, 0.68F, 0.08F,
					                                             0.00F, 0.08F, 0.00F ])
                                 (. :ConvolveOp :EDGE_NO_OP)
                                 nil))

(def rescale-op-darker (. :RescaleOp  :new 0.9F 0 nil))

(def rescale-op-brighter (. :RescaleOp  :new 1.1F 0 nil))

(def color-space-gray (. :ColorSpace :getInstance (. :ColorSpace :CS_GRAY)))
(def color-convert-op-grayscale (. :ColorConvertOp :new color-space-gray nil))





;; -----------------------------------------------------------------------------
;; Load / Save
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(load file)") 
     :doc """
          Loads an image from a `:java.io.File`, a `:java.io.InputStream`, or a 
          `:java.net.URL`.
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/load (io/file \"/Users/foo/apple.png\")))
          """)
     :see-also '(
          "images/save" ) }

  load [f]

  (assert (or (io/file? f) 
              (instance-of? :java.io.InputStream f)
              (instance-of? :java.net.URL f)))

  (try 
    (. :ImageIO :read f)
    (catch :Exception e
      (throw (ex :VncException "Faled to load image" e)))))


(defn 
  ^{ :arglists '(
          "(save img format-name f)") 
     :doc """
          Saves an image to 'java.io.File' or an ':java.io.OutputStream'.

          Supported formats:  :png, :jpg, :jpeg, :gif, :bmp
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/save img :png (io/file \"/Users/foo/apple.png\")))
          """) 
     :see-also '(
          "images/load"
          "images/list-supported-file-formats" ) }

  save [img format-name f]

  (assert (instance-of? :Image img))
  (assert (or (string? format-name) (keyword? format-name)))
  (assert (or (io/file? f) (instance-of? :java.io.OutputStream f)))

  (try 
    (. :ImageIO :write img (name type) type f)
    (catch :Exception e
      (throw (ex :VncException "Failed to write image" e)))))



;; -----------------------------------------------------------------------------
;; Image properties
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(dimension f)") 
     :doc """
          Returns the images dimensions as a vector [width height]. 'f' may 
          be a `:java.io.File` or a `:java.awt.Image`.

          Note: Do not load a file first to get the dimension, passing a
                `:java.io.File` is much faster!
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/dimension (io/file \"/Users/foo/apple.png\")))
          """ ) }

  dimension [f]

  (assert (or (io/file? f) (instance-of? :Image f)))

  (if (instance-of? :Image f)
    [(. f :getWidth) (. f :getHeight)] ;; return dimensions
    (let [suffix    (io/file-ext f)
          iterators (. :ImageIO :getImageReadersBySuffix suffix)]
      (let [dim (loop [readers (java-iterator-to-list iterators)]
                  (if-let [reader (first readers)]
                    (if-let [d (read-dimension reader f)]
                      d  ;; return dimensions
                      (recur (rest readers)))))]  ;; try with next reader
        (if dim
          dim
          (throw (ex :VncException 
                     (str "Cannot get image dimensions for unknown image " 
                          f))))))))


(defn- read-dimension [img-reader file]
  (try-with [is (. :FileImageInputStream :new file)]
    (. img-reader :setInput is)
    ;; return dimensions
    [(. img-reader :getWidth  (. img-reader :getMinIndex))
     (. img-reader :getHeight (. img-reader :getMinIndex))]
  (catch :Exception e nil)  ;; this reader does not match the image type
  (finally (. img-reader :dispose))))



;; -----------------------------------------------------------------------------
;; Rotate / Flip
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(rotate img angle)") 
     :doc """
          Rotates an image by 0째, 90째, 180째, or 270째 clockwise. 
          Returns a new image.
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/rotate img 90))
          """ ) }

  rotate [img angle]

  (assert (instance-of? :Image img))
  (assert (and (long? angle) (contains? #{0, 90, 180, 270} angle)))

  (let [width   (. img :getWidth)
        height  (. img :getHeight)
        tx      (. :AffineTransform :new)]
    (case angle
      90      (let [new-width  height
                    new-height width]
			          (. tx :translate new-width 0)
			          (. tx :quadrantRotate 1)
                (transform img tx new-width new-height))

      180     (let [new-width  width
                    new-height height]
			           (. tx :translate 0 new-height)
			           (. tx :quadrantRotate 2)
                 (transform img tx new-width new-height))

      270     (let [new-width  height
                    new-height width]
			          (. tx :translate new-width 0)
			          (. tx :quadrantRotate 3)
                (transform img tx new-width new-height))

      img)))

(defn 
  ^{ :arglists '(
          "(flip img mode)") 
     :doc """
          Flips an image vertically or horizontally. Returns a new image.

          Mode is either :vertical or :horizontal.
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/flip img :vertical))
          """ ) }

  flip [img mode]

  (assert (instance-of? :Image img))
  (assert (and (keyword? mode) (contains? #{:vertical :horizontal} mode)))

  (let [width   (. img :getWidth)
        height  (. img :getHeight)
        tx      (. :AffineTransform :new)]
    (case mode
      :vertical   (do (. tx :translate 0 height)
                      (. tx :scale -1.0 1.0)
                      (transform img tx width height))

      :horizontal (do (. tx :translate width 0)
                      (. tx :scale 1.0 -1.0)
                     (transform img tx width height))
      img)))


(defn- transform [img tx width height]
  (assert (instance-of? :Image img))
  (assert (and (long? width) (pos? width)))
  (assert (and (long? height) (pos? height)))

  (let [result (create-derived-image img width height)
        g2d    (. result :createGraphics)]
	  (. g2d :drawImage img tx nil)
		(. g2d :dispose)
    result))



;; -----------------------------------------------------------------------------
;; Apply image OPs
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(apply-ops img ops)") 
     :doc """
          Applies one or multiple image operators (:java.awt.image.BufferedImageOp)
          to the image.  Returns a new image.
          """
     :examples '(
          """
          (do
            (load-module :images)
            (let [op-brighter (. :RescaleOp :new 1.1F 0 nil)]
              (images/apply img [op-brighter])))
          """ ) }

  apply-ops [img ops]

  (assert (instance-of? :Image img))
  (assert (sequential? ops))
  (assert (not-empty? ops))
  (assert (every? #(instance-of :BufferedImageOp) ops))

  (let [src (if (is-rgb-or-argb-image img) img (copy-to-derived-image img))]
    (loop [src        src
           ops        (filter some? ops)
           reassigned false]
      (let [op            (first ops) 
            result-bounds (. :op :getBounds2D src)]
        (when (nil? result-bounds)
           (throw (ex :VncException (str "BufferedImageOp[" op "] get bounds returned nil."))))
        (let [w      (long (. result-bounds :getWidth))
              h      (long (. result-bounds :getHeight))
              dest   (create-derived-image src w h)
              result (. op :filter src dest)]
          (when reassigned (. src :flush))
          (if (empty? ops)
            result
            (recur result (rest ops) true)))))))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(supported-file-formats)") 
     :doc """
          Returns a list of the suppported file formats of this Java VM.
          """
     :examples '(
          """
          (do
            (load-module :images)
            (images/supported-file-formats))
          """ ) }

  supported-file-formats []

  (let [registry (. :IIORegistry :getDefaultInstance)]
    (->> (. registry :getServiceProviders (class :ImageWriterSpi) false)
         (java-iterator-to-list)
         (map #(. % :getFormatNames)))))


;; -----------------------------------------------------------------------------
;; Internals
;; -----------------------------------------------------------------------------

(defn-  create-derived-image 
  ([src]
    (create-derived-image (. img :getWidth) (. img :getHeight)))

  ([src width height]
    (assert (instance-of? :Image src))
    (assert (and (long? width) (pos? width)))
    (assert (and (long? height) (pos? height)))
  
    (let [transparency (. src :getTransparency)
          type        (if (== transparency OPAQUE) TYPE_INT_RGB TYPE_INT_ARGB)]
      (. :BufferedImage :new width height type))))


(defn- copy-to-derived-image [img]
  (let [width        (. img :getWidth)
        height       (. img :getHeight)
        transparency (. img :getTransparency)
        type         (if (== transparency OPAQUE) TYPE_INT_RGB TYPE_INT_ARGB)
        dest         (. :BufferedImage :new width height type)
        gd           (. result :getGraphics)]
 
    (. gd :drawImage img 0 0 nil)
		(. gd :dispose)
    dest))


(defn- is-rgb-or-argb-image [img]
  (contains? #{TYPE_INT_RGB, TYPE_INT_ARGB} (. img :getType)))
