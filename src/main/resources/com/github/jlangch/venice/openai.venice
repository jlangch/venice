;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; OpenAI client without any dependencies on 3rd party libraries


(ns openai)

(load-module :http-client-j8 ['http-client-j8 :as 'hc])
(load-module :ansi)


;; =============================================================================
;; =                                                                           =
;; =                     W O R K   I N   P R O G R E S S                       =
;; =                                                                           =
;; =============================================================================


;; -----------------------------------------------------------------------------
;; MODELS 
;; -----------------------------------------------------------------------------

;; see https://platform.openai.com/docs/models/continuous-model-upgrades

(def gpt-4o        "gpt-4o")           ;; GPT-4o, 128'000 tokens
(def gpt-4-turbo   "gpt-4.0-turbo")    ;; GPT-4 Turbo with Vision, 128'000 tokens
(def gpt-4         "gpt-4")            ;; GPT-4, 8'192 tokens
(def gpt-3.5-turbo "gpt-3.5-turbo")    ;; GPT-3.5, 16'385 tokens

(def dall-e-3      "dall-e-3")         ;; DALL-E 3
(def dall-e-2      "dall-e-2")         ;; DALL-E 2

(def tts-1         "tts-1")            ;; Text-to-speech 1
(def tts-1-hd      "tts-1-hd")         ;; Text-to-speech 1 HD

(def whisper-1     "whisper-1")        ;; Whisper, general-purpose speech recognition

(def text-embedding-3-large  "text-embedding-3-large")   ;; Text embedding, dimension 3'072
(def text-embedding-3-small  "text-embedding-3-small")   ;; Text embedding, dimension 1'536
(def text-embedding-ada-002  "text-embedding-ada-002")   ;; Text embedding, dimension 1'536


(defonce audio-voices #{:alloy, :echo, :fable, :onyx, :nova, :shimmer})
(defonce audio-formats #{:mp3, :opus, :aac, :flac, :wav, :pcm})

(defonce audio-mimetypes {  "audio/aac"    "aac"
                            "audio/flac"   "flac"
                            "audio/mpeg"   "mp3"
                            "audio/mpega"  "mpega"
                            "audio/mp4"    "mp4"
                            "audio/m4a"    "m4a"
                            "audio/opus"   "opus"
                            "audio/ogg"    "ogg"
                            "audio/pcm"    "pcm"
                            "audio/wav"    "wav"
                            "audio/webm"   "webm" })



;; -----------------------------------------------------------------------------
;; CHAT COMPLETIONS 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(chat-completion prompt & options)" )
     :doc """
          Runs a chat completion.

          To run the request asynchronously just wrap it in a `future` and
          deref it, when the result is required.

          ¶*Parameter «prompt»*

          A prompt is either a simple string like:

          ```
          "Who won the world series in 2020?"
          ```

          or a list of prompt messages:

          ```
          [ {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": "Who won the world series in 2020?"},
            {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
            {"role": "user", "content": "Where was it played?"} ]
          ```

          Using prompt roles:

          | [![width: 15%]] | [![width: 85%]] |
          | *system*    | Allows to specify the way the model answers questions. ¶\
                          Classic example: "You are a helpful assistant." |
          | *user*      | Equivalent to the queries made by the user. |
          | *assistant* | Assistent roles are the model's responses, based on the user messages. |


          ¶*Parameter request «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "gpt-4o". Defaults \
                                to "gpt-4o". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:gpt-4o`, `:gpt-4-turbo`, ...  |
          | :tools            | a list of tools. e.g.: function definitions (see OpenAI api for details) |
          | :tool-choice      | a tool choice. e.g.: function definitions (see OpenAI api for details) ¶\
                                This forces the model to use a specific function: ¶\
                                `{:type "function", :function {:name "get_n_day_weather_forecast"}` |
          | :chat-opts        | An optional map of OpenAI chat request options \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :temperature 0.2 }`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/chat/create) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "chats=v2"} |
          | :uri              | An OpenAI chat completion URI. E.g.: \
                                "https://api.openai.com/v1/chat/completions". ¶\
                                Defaults  to "https://api.openai.com/v1/chat/completions" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          Tools options (a Venice map) for passing a function definition:

          ```
          [ 
            { :type "function" 
              :function {
                  :name "get_current_weather"
                  :description "Get the current weather"
                  :parameters {
                      :type "object"
                      :properties {
                          :location {
                              :type "string"
                              :description "The city and state, e.g. San Francisco, CA"
                          }
                          :format {
                              :type "string"
                              :enum ["celsius", "fahrenheit"]
                              :description "The temperature unit to use. Infer this from the users location."
                          }
                      }
                      :required ["location", "format"]
                  } 
              } 
            }
          ]
          ```

          ¶*Return value*

          Returns a map with the response data:*

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :message        | The final chat completion message if the OpenAI \
                              server returned the HTTP status `HTTP_OK`, else `nil` |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |
          
          ¶
          See:
          * [OpenAI Chat Completions API](https://platform.openai.com/docs/guides/text-generation/chat-completions-api)¶
          * [OpenAI API Reference](https://platform.openai.com/docs/api-reference/chat/create)
          * [OpenAI API Messages](https://platform.openai.com/docs/api-reference/chat/create#chat-create-messages)
          * [OpenAI API Functions](https://platform.openai.com/docs/guides/function-calling)
          * [OpenAI API Functions Cookbook](https://cookbook.openai.com/examples/how_to_call_functions_with_chat_models)
          * [OpenAI API Examples](https://platform.openai.com/examples)
          * [OpenAI API Examples Prompts](https://platform.openai.com/examples?category=code)
          """ 
     :examples '(
          """
          ;; print the full OpenAI response message
          (do
            (load-module :openai)

            (let [prompt    \"\"\"
                            Count to 10, with a comma between each number and no newlines. 
                            E.g., 1, 2, 3, ...
                            \"\"\"
                  response  (openai/chat-completion prompt 
                                                    :model :gpt-4o)]
              (println "Status:  " (:status response))
              (println "Mimetype:" (:mimetype response))
              (if (=  (:status response) 200)
                (println "Message:" (openai/pretty-print-json (:data response)))
                (println "Error:"   (:data response)))))
          """,
          """
          ;; print only the OpenAI response message content
          (do
            (load-module :openai)

            (let [prompt    \"\"\"
                            Count to 10, with a comma between each number and no newlines. 
                            E.g., 1, 2, 3, ...
                            \"\"\"
                  response  (openai/chat-completion prompt
                                                    :model :gpt-4o)]
              (openai/assert-response-http-ok response)
              (println "Message:" (-> (:data response)
                                      (openai/chat-extract-response-message-content)
                                      (pr-str)))))
          """,
          """
          ;; Dealing with prompt options
          (do
            (load-module :openai)

            (let [prompt      [ { :role     "system"
                                  :content  \"\"\"
                                            You will be provided with statements, and your task 
                                            is to convert them to standard English.
                                            \"\"\" }
                                { :role     "user"
                                  :content  "She no went to the market." } ]
                   response    (openai/chat-completion prompt 
                                                      :model :gpt-4o
                                                      :chat-opts { :temperature 0.7
                                                                   :max_tokens 64
                                                                   :top_p 1 } )]
              (openai/assert-response-http-ok response)
              (println "Message:" (-> (:data response)
                                      (openai/chat-extract-response-message-content)
                                      (openai/pretty-print-json)))))
            """ )
     :see-also '( 
          "openai/chat-completion-streaming"
          "openai/chat-extract-response-message-content"
          "openai/pretty-print-json" ) }

  chat-completion [prompt & options]

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/chat/completions")
        model           (to-model (:model opts) :gpt-4o)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        tools           (:tools opts)
        _               (validate-tools tools)
        tool-choice     (:tool_choice opts)
        _               (validate-tool-choice tool-choice)
        chat-opts       (or (:chat-opts opts) (:prompt-opts opts)) ;; deprecated :prompt-opts
        body            (build-chat-prompt model prompt chat-opts
                                           tools tool-choice {:stream false})
        debug?          (:debug opts false)
        _               (when debug? (dump-prompt body))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body (json/write-str body)
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))


(defn 
 ^{ :arglists '(
          "(chat-completion-streaming prompt handler & options)" )
     :doc """
          Runs a chat completion in streaming mode.

          Processes OpenAI server side events (SSE) and calls for every event the
          handler 'handler'.


          ¶*Parameter «prompt»*

          A prompt is either a simple string like:

          ```
          "Who won the world series in 2020?"
          ```

          or a list of prompt messages:

          ```
          [ {"role": "system", "content": "You are a helpful assistant."},
            {"role": "user", "content": "Who won the world series in 2020?"},
            {"role": "assistant", "content": "The Los Angeles Dodgers won the World Series in 2020."},
            {"role": "user", "content": "Where was it played?"} ]
          ```

          ¶*Parameter «handler»*
       
          The event handler is a three argument function:
          
          ```
          (defn handler [delta accumulated status] ...)
          ```
         
          Handler arguments:

          | [![width: 15%]] | [![width: 85%]]                  |
          | *delta*       | the delta message sent with the event |
          | *accumulated* | the accumulated message|
          | *type*        | the notification type: ¶\
                            \u00A0\u00A0 `:opened` - streaming started ¶\
                            \u00A0\u00A0 `:data` - streamed event ¶\
                            \u00A0\u00A0 `:done` - streaming done by the server |

          ¶*Parameter request «options»*
 
          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "gpt-4o". Defaults \
                                to "gpt-4o". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:gpt-4o`, `:gpt-4-turbo`, ...  |
          | :sync             | if *true* runs the request syncronously and waits \
                                until the full message response is available. ¶\
                                if *false* runs the request asyncronously and \
                                returns immediately with the response :data \
                                field holding a `future` that can be deref'd  \
                                (with an optional timeout) to get the full \
                                message. ¶\
                                Defaults to *true* |
          | :chat-opts        | An optional map of OpenAI chat request options \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :temperature 0.2 }`. ¶\
                                E.g. `{ :stream_options { :include_usage true } }. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/chat/create) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "chats=v2"} |
          | :uri              | An OpenAI chat completion URI. E.g.: \
                                "https://api.openai.com/v1/chat/completions". ¶\
                                Defaults  to "https://api.openai.com/v1/chat/completions" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |
 
          ¶*Return value*

          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :message        | The final chat completion message if the OpenAI \
                              server returned the HTTP status `HTTP_OK`, else `nil` |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data field contains the chat completion \
                              message and token usage:  ¶\
                              {:message "1234" :usage nil }  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |
          
          ¶*Note: The streaming mode does not support functions!*
 
          See:
          * [OpenAI Chat Completions API](https://platform.openai.com/docs/guides/text-generation/chat-completions-api)¶
          * [OpenAI API Reference](https://platform.openai.com/docs/api-reference/chat/create)
          * [OpenAI API Messages](https://platform.openai.com/docs/api-reference/chat/create#chat-create-messages)
          * [OpenAI API Examples](https://platform.openai.com/examples)
          * [OpenAI API Examples Prompts](https://platform.openai.com/examples?category=code)
          """ 
     :examples '(
          """
          ;; synchronous
          ;; prints the arriving events asynchronously, the response is only
          ;; returned when the final message is available or the request is bad
          (do
            (load-module :openai)
          
            (let [prompt    \"\"\"
                            Count to 10, with a comma between each number and no newlines. 
                            E.g., 1, 2, 3, ...
                            \"\"\"
                  handler   (fn [delta accumulated status]
                              (case status
                                :opened  (println "Started...")
                                :data    (println "Delta:" (pr-str delta))
                                :done    (println "Completed.")))
                  response  (openai/chat-completion-streaming 
                                prompt 
                                handler 
                                :model :gpt-4o
                                :sync true
                                :chat-opts { :temperature 0.1 
                                             :stream_options { :include_usage true } })]
              (openai/assert-response-http-ok response)
              (let [data (:data response)]
                (println "Usage:  " (pr-str (:usage data)))
                (println "Message:" (pr-str (:message data))))))
          """,
          """
          ;; asynchronous
          ;; prints the arriving events asynchronously, returns the response
          ;; immediately with the data  `(:data response)` as a future that can 
          ;; be deref'd to get the final message.
          (do
            (load-module :openai)
          
            (let [prompt    \"\"\"
                            Count to 10, with a comma between each number and no newlines. 
                            E.g., 1, 2, 3, ...
                            \"\"\"
                  handler   (fn [delta accumulated status]
                              (case status
                                :opened  (println "Started...")
                                :data    (println "Delta:" (pr-str delta))
                                :done    (println "Completed.")))
                  response  (openai/chat-completion-streaming 
                                prompt 
                                handler 
                                :model :gpt-4o
                                :sync false
                                :chat-opts { :temperature 0.1 
                                             :stream_options { :include_usage true } } )]
              (openai/assert-response-http-ok response)
              (let [data @(:data response)]
                (println "Usage:  " (pr-str (:usage data)))
                (println "Message:" (pr-str (:message data))))))
          """ )
     :see-also '( 
          "openai/chat-completion"
          "openai/chat-process-streaming-events" ) }

  chat-completion-streaming [prompt handler & options]

  (assert (fn? handler))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/chat/completions")
        model           (to-model (:model opts) :gpt-4o)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        sync?           (:sync opts true)
        chat-opts       (or (:chat-opts opts) (:prompt-opts opts)) ;; deprecated :prompt-opts
        body            (build-chat-prompt model prompt chat-opts 
                                           nil nil {:stream true})
        debug?          (:debug opts false)
        _               (when debug? (dump-prompt body))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body (json/write-str body)
                          :debug debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
    (if (and (= "text/event-stream" (:content-type-mimetype response))
             (= (:http-status response) 200))
     
      (let [fr (openai/chat-process-streaming-events response handler :debug debug?)]
        (assoc result :data (if sync? @fr fr)))
      (assoc result :data (hc/slurp-response response :json-parse-mode :pretty-print)))))



;; -----------------------------------------------------------------------------
;; IMAGES
;; -----------------------------------------------------------------------------

;; https://medium.com/intermerz/prompt-design-f%C3%BCr-dall-e-fotorealismus-emulation-der-realit%C3%A4t-31af8939ee1c

(defn 
  ^{ :arglists '(
          "(image-create prompt response-format & options)" )
     :doc """
          Create images.

          ¶*Parameter «prompt»*

          ```
          "A portrait of a dog in a library, Sigma 85mm f/1.4"
          ```

          ¶*Parameter «response-format»*

          The format in which the generated images are returned

          * `:url`
          * `:b64_json`

          Note: URLs are only valid for 60 minutes after the image has been generated.

          ¶*Parameter request «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "dall-e-3". Defaults \
                                to "dall-e-3". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:dall-e-2`, `:dall-e-3`, ...  |
          | :image-opts       | An optional map of OpenAI image request options \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :style "vivid" :size "1024x1024", :quality "hd" :n 1 }`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/images/create) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "images=v2"} |
          | :uri              | An OpenAI chat completion URI. E.g.: \
                                "https://api.openai.com/v1/images/generations". ¶\
                                Defaults  to "https://api.openai.com/v1/images/generations" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Image Guide](https://platform.openai.com/docs/guides/images/usage)
          * [OpenAI Image API](https://platform.openai.com/docs/api-reference/images)
          """ 
     :examples '(
          """
          ;; :url => print the full OpenAI response message
          (do
            (load-module :openai)

            (let [prompt    "A portrait of a dog in a library, Sigma 85mm f/1.4"
                  response  (openai/image-create prompt 
                                                 :url
                                                 :model :dall-e-3
                                                 :image-opts {:quality "hd"})]
              (openai/assert-response-http-ok response)
              (println "Response:" (openai/pretty-print-json (:data response)))))
          """,
          """
          ;; :b64_json => print the full OpenAI response message
          (do
            (load-module :openai)

            (let [prompt    "A portrait of a dog in a library, Sigma 85mm f/1.4"
                  response  (openai/image-create prompt 
                                                 :b64_json
                                                 :model :dall-e-3
                                                 :image-opts {:quality "hd"})]
              (openai/assert-response-http-ok response)
              (println "Response:" (openai/pretty-print-json (:data response)))))
          """,
          """
          ;; :url => save the image
          (do
            (load-module :openai)
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])

            (let [prompt    "A portrait of a dog in a library, Sigma 85mm f/1.4"
                  response  (openai/image-create prompt 
                                                 :url
                                                 :model :dall-e-3
                                                 :image-opts {:quality "hd"})]
              (openai/assert-response-http-ok response)
              (let [data       (:data (:data response))
                    img-data   (first data) ;; 1st image data
                    url        (:url img-data)
                    _          (println "Downloading image...")
                    img        (openai/image-download url "image-1")
                    file       (str "./" (:name img))]
                (io/spit file (:data img))
                (println "Saved image to:" file))))
          """,
          """
          ;; :b64_json => save the image
          (do
            (load-module :openai)
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])

            (let [prompt    "A portrait of a dog in a library, Sigma 85mm f/1.4"
                  response  (openai/image-create prompt 
                                                 :b64_json
                                                 :model :dall-e-3
                                                 :image-opts {:quality "hd"})]
              (openai/assert-response-http-ok response)
              (let [data       (:data (:data response))
                    img-data   (first data) ;; 1st image data   
                    img        (->> (get img-data :b64_json)
                                    (str/decode-base64))
                    file       "./image-2.png"]
                (io/spit file img)
                (println "Saved image to:" file))))
          """ )
     :see-also '( 
          "openai/image-variants"
          "openai/image-edits"
          "openai/pretty-print-json"
          "openai/image-download" ) }

  image-create [prompt response-format & options]

  (assert (string? prompt)
          "The prompt must be a string")
  (assert (or (= response-format :url) (= response-format :b64_json))
          "The response-format value must be :url or :b64_json")

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/images/generations")
        model           (to-model (:model opts) :dall-e-3)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        image-opts      (or (:image-opts opts) (:prompt-opts opts) {}) ;; deprecated :prompt-opts
        body            (build-image-prompt model prompt image-opts
                                            {:response_format response-format})
        debug?          (:debug opts false)
        _               (when debug? (dump-prompt body))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body (json/write-str body)
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(image-variants image response-format & options)" )
     :doc """
          Create image variants. 
          
          It only supports "dall-e-2". The quality of the variants is poor.
          Looks like OpenAI is giving it up.

          ¶*Parameter «image»*

          The image to create variants from.

          ¶*Parameter «response-format»*

          The format in which the generated images are returned

          * `:url`
          * `:b64_json`

          Note: URLs are only valid for 60 minutes after the image has been generated.

          ¶*Parameter request «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "dall-e-2". Defaults \
                                to "dall-e-2". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:dall-e-2`, `:dall-e-3`, ...  |
          | :image-opts       | An optional map of OpenAI image request options \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :size "1024x1024", :n 1 }`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/images/createVariation) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "images=v2"} |
          | :uri              | An OpenAI chat completion URI. E.g.: \
                                "https://api.openai.com/v1/images/variations". ¶\
                                Defaults  to "https://api.openai.com/v1/images/variations" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Image Guide](https://platform.openai.com/docs/guides/images/usage)
          * [OpenAI Image API](https://platform.openai.com/docs/api-reference/images)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
  
            (defn create-image [img-file]
              (println "Requesting image...")
              (let [prompt    "A portrait of a dog in a library, Sigma 85mm f/1.4"
                    response  (openai/image-create prompt :b64_json
                                                   :model :dall-e-3
                                                   :image-opts {:size "1024x1024", :quality "hd"})]
                (openai/assert-response-http-ok response)
                (let [data       (:data (:data response))
                      img-data   (first data) ;; 1st image data   
                      img        (->> (get img-data :b64_json)
                                      (str/decode-base64))]
                  (io/spit img-file img)
                  (println "Saved image to:" img-file))))

            (defn create-image-variant [img-file img-variant-file]
              (println "Requesting image variant...")
              (let [img       (io/slurp img-file :binary true)
                    response  (openai/image-variants img
                                                     :b64_json
                                                     :model :dall-e-3
                                                     :image-opts {:size "1024x1024", :n 1})]
                (openai/assert-response-http-ok response)
                (let [data       (:data (:data response))
                      img-data   (first data) ;; 1st image data   
                      img        (->> (get img-data :b64_json)
                                      (str/decode-base64))]
                  (io/spit img-variant-file img)
                  (println "Saved variant to:" img-variant-file))))

            (create-image "./image-variant-1.png")            ;; create an image
            (create-image-variant "./image-variant-1.png"
                                  "./image-variant-2.png"))  ;; create a variant of the image
          """ )
     :see-also '( 
          "openai/image-create"
          "openai/image-edits"
          "openai/pretty-print-json"
          "openai/image-download" ) }

  image-variants [image response-format & options]

  (assert (bytebuf? image))
  (assert (or (= response-format :url) (= response-format :b64_json))
          "The response-format value must be :url or :b64_json")

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/images/variations")
        model           (to-model (:model opts) :dall-e-2)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        image-opts      (or (:image-opts opts) (:prompt-opts opts) {}) ;; deprecated :prompt-opts
        param-parts     (->> (merge { ;; :model  model   ;; OpenAI rejects a model!!
                                      :response_format response-format} 
                                    image-opts)
                              (map-keys-and-vals-to-string))
        img-part        { "image"  { :filename  "image.png"
                                     :mimetype  "image/png"
                                     :data      image } }
        multi-parts     (merge img-part param-parts)
        debug?          (:debug opts false)
        _               (when debug? (println "\nMultiparts:") (prn multi-parts))
        response        (hc/upload-multipart 
                          multi-parts 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(image-edits image mask prompt response-format & options)" )
     :doc """
          Edits an image. 
          
          ¶*Parameter «image»*

          The image to edit.
          
          ¶*Parameter «mask»*

          The mask image.
          
          ¶*Parameter «prompt»*

          A text description of the desired image.

          ¶*Parameter «response-format»*

          The format in which the generated images are returned

          * `:url`
          * `:b64_json`

          Note: URLs are only valid for 60 minutes after the image has been generated.

          ¶*Parameter request «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "dall-e-2". Defaults \
                                to "dall-e-2". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:dall-e-2`, `:dall-e-3`, ...  |
          | :image-opts       | An optional map of OpenAI image request options \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :size "1024x1024", :n 1 }`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/images/createEdit) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "images=v2"} |
          | :uri              | An OpenAI chat completion URI. E.g.: \
                                "https://api.openai.com/v1/images/edits". ¶\
                                Defaults  to "https://api.openai.com/v1/images/edits" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Image Guide](https://platform.openai.com/docs/guides/images/usage)
          * [OpenAI Image API](https://platform.openai.com/docs/api-reference/images)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
            (load-module :images)
  
            (defn create-image [prompt img-file]
              (println "Requesting image...")
              (let [response  (openai/image-create prompt 
                                                   :b64_json
                                                   :model :dall-e-3
                                                   :image-opts {:size "1024x1024", :quality "hd"})]
                (openai/assert-response-http-ok response)
                (let [data       (:data (:data response))
                      img-data   (first data) ;; 1st image data   
                      img        (->> (get img-data :b64_json)
                                      (str/decode-base64))]
                  (io/spit img-file img)
                  (println "Saved image to:" img-file))))
  
            (defn create-image-mask [img-file mask-file]
              (println "Creating mask...")
              (let [img    (->> (images/load (io/file img-file))
                                (images/convert-to-rgba))
                    [w h]  (images/dimension img)
                    g2d    (images/g2d img)]
                (. g2d :setComposite (. :java.awt.AlphaComposite :Clear))
                (images/fg-color g2d images/white)
                (images/fill-circle g2d (/ w 2) (/ h 2) (/ w 4))
                (images/dispose g2d)
                (images/save img :png (io/file mask-file))
                (println "Saved mask to:" mask-file)))

            (defn create-image-edit [prompt img-file mask-file result-file]
              (println "Requesting image edit...")
              (let [response  (openai/image-edits (io/slurp img-file :binary true)
                                                  (io/slurp mask-file :binary true)
                                                  prompt 
                                                  :b64_json
                                                  :model :dall-e-2
                                                  :image-opts {:size "1024x1024", :n 1})]
                (openai/assert-response-http-ok response)
                (let [data       (:data (:data response))
                      img-data   (first data) ;; 1st image data   
                      img        (->> (get img-data :b64_json)
                                      (str/decode-base64))]
                  (io/spit result-file img)
                  (println "Saved edited image to:" result-file))))

            ;; create the initial image
            (create-image "A sunlit indoor lounge area with a large pool at the center of the image"
                          "./image-edit-source.png") 

            ;; derive an image with a mask at the center for placing the flamingo 
            (create-image-mask "./image-edit-source.png"
                               "./image-edit-mask.png") 

            ;; place the flamingo in the mask area at the center
            (create-image-edit "A sunlit indoor lounge area with a pool containing a flamingo"
                               "./image-edit-source.png"
                               "./image-edit-mask.png"
                               "./image-edit-result.png"))
          """ )
     :see-also '( 
          "openai/image-create"
          "openai/image-variants"
          "openai/pretty-print-json"
          "openai/image-download" ) }

  image-edits [image mask prompt response-format & options]

  (assert (bytebuf? image))
  (assert (bytebuf? mask))
  (assert (string? prompt))
  (assert (or (= response-format :url) (= response-format :b64_json))
          "The response-format value must be :url or :b64_json")

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/images/edits")
        model           (to-model (:model opts) :dall-e-2)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        image-opts      (or (:image-opts opts) (:prompt-opts opts) {}) ;; deprecated :prompt-opts
        param-parts     (->> (merge { ;; :model  model   ;; OpenAI rejects a model!!
                                      :prompt prompt
                                      :response_format response-format} 
                                    image-opts)
                             (map-keys-and-vals-to-string))
        img-parts       { "image"  { :filename  "image.png"
                                     :mimetype  "image/png"
                                     :data      image }
                          "mask"   { :filename  "mask.png"
                                     :mimetype  "image/png"
                                     :data      mask } }
        multi-parts     (merge img-parts param-parts)
        debug?          (:debug opts false)
        _               (when debug? (println "\nMultiparts:") (prn multi-parts))
        response        (hc/upload-multipart 
                          multi-parts 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))




;; -----------------------------------------------------------------------------
;; AUDIO
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(audio-speech-generate text voice response-format & options)" )
     :doc """
          Generates audio from the input text.

          ¶*Parameter «text»*

          ```
          "The quick brown fox jumped over the lazy dog."
          ```

          ¶*Parameter «voice»*

          The voice to use when generating the audio. 

          * `:alloy`
          * `:echo`
          * `:fable`
          * `:onyx`
          * `:nova`
          * `:shimmer`

          ¶*Parameter «response-format»*

          The format in which the generated images are returned

          * `:mp3`  (mimetype: audio/mpeg)
          * `:opus` (mimetype: audio/opus)
          * `:aac`  (mimetype: audio/aac)
          * `:flac` (mimetype: audio/flac)
          * `:wav`  (mimetype: audio/wav)
          * `:pcm`  (mimetype: audio/pcm)

          ¶*Parameter request «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "tts-1". Defaults \
                                to "tts-1". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:tts-1`, `:tts-1-hd`, ...  |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :audio-opts       | An optional map of OpenAI audio options. \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :speed 1.0 }`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/audio/createSpeech) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "audio=v2"} |
          | :uri              | An OpenAI audio speech URI. E.g.: \
                                "https://api.openai.com/v1/audio/speech". ¶\
                                Defaults  to "https://api.openai.com/v1/audio/speech" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Audio API](https://platform.openai.com/docs/api-reference/audio)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [text      "The quick brown fox jumped over the lazy dog."
                  response  (openai/audio-speech-generate text
                                                          :alloy
                                                          :mp3
                                                          :model :tts-1
                                                          :audio-opts { :speed 1.0 })]
              (openai/assert-response-http-ok response)
              (let [audio     (:data response)
                    size      (/ (count audio) 1024.0)
                    file-ext  (openai/audio-file-ext (:mimetype response))
                    file      (str "./audio." file-ext)]
                (printf "Saving audio (%.1fKB) to: %s%n" size file)
                (io/spit file audio))))
          """ )
     :see-also '( 
          "openai/audio-speech-transcribe"
          "openai/audio-speech-translate"
          "openai/audio-file-ext" ) }

  audio-speech-generate [text voice response-format & options]

  (assert (string? text)
          "The 'text' must be a string")
  (assert (contains? audio-voices voice)
          "The 'voice' must be one of: ~(pr audio-voices)")
  (assert (contains? audio-formats response-format)
          "The 'response-format' must be one of: ~(pr audio-formats)")

  (let [opts            (apply hash-map options)
        _               (assert (or (nil? (:audio-opts  opts)) (map? (:audio-opts  opts))))
        uri             (:uri opts "https://api.openai.com/v1/audio/speech")
        model           (to-model (:model opts) :tts-1)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        body            (merge { :model model
                                 :input text
                                 :voice voice
                                 :response_format response-format}
                               (get opts :audio-opts {}))
        debug?          (:debug opts false)
        _               (when debug? (dump-prompt body))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body (json/write-str body)
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(audio-speech-transcribe data audio-type response-format & options)" )
     :doc """
          Transcribes audio into the input language.

          ¶*Parameter «data»*

          The audio data (a byte buffer)

          ¶*Parameter «audio-type»*

          The audio type

          * `:flac`   (mimetype: audio/flac)
          * `:mp3`    (mimetype: audio/mpeg)
          * `:mp4`    (mimetype: audio/mp4)
          * `:m4a`    (mimetype: audio/m4a)
          * `:mpega`  (mimetype: audio/mpega)
          * `:ogg`    (mimetype: audio/ogg)
          * `:wav`    (mimetype: audio/wav)
          * `:webm`   (mimetype: audio/webm)

          ¶*Parameter «response-format»*

          The format in which the transcribed text is returned

          * `:json`
          * `:text`
          * `:srt`
          * `:verbose_json`
          * `:vtt`

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "whisper-1". Defaults \
                                to "whisper-1". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:whisper-1`,...  |
          | :audio-opts       | An optional map of OpenAI audio options. \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :language "en", :temperature 0, :timestamp_granularities "word"}`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/audio/createTranscription) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "audio=v2"} |
          | :uri              | An OpenAI audio speech URI. E.g.: \
                                "https://api.openai.com/v1/audio/transcriptions". ¶\
                                Defaults  to "https://api.openai.com/v1/audio/transcriptions" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Audio API](https://platform.openai.com/docs/api-reference/audio)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (defn generate-mp3-audio [text]
              (let [response  (openai/audio-speech-generate text
                                                            :alloy
                                                            :mp3
                                                            :model :tts-1)]
                (openai/assert-response-http-ok response)
                (:data response)))

            (let [text       "The quick brown fox jumped over the lazy dog."
                  audio-data (generate-mp3-audio text)
                  response   (openai/audio-speech-transcribe audio-data 
                                                             :mp3 
                                                             :json)]
              (openai/assert-response-http-ok response)
              (println (:text (:data response)))))
          """,
          """
          (do
            (load-module :openai)

            (defn generate-mp3-audio [text]
              (let [response  (openai/audio-speech-generate text
                                                            :alloy
                                                            :mp3
                                                            :model :tts-1)]
                (openai/assert-response-http-ok response)
                (:data response)))

            (let [text       "The quick brown fox jumped over the lazy dog."
                  audio-data (generate-mp3-audio text)
                  audio-opts { :language "en"    ;; ISO-639-1 
                               :temperature 0
                               :timestamp_granularities "word" }
                  response   (openai/audio-speech-transcribe audio-data 
                                                             :mp3 
                                                             :verbose_json 
                                                             :audio-opts audio-opts)]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/audio-speech-generate"
          "openai/audio-speech-translate"
          "openai/audio-file-ext" ) }

  audio-speech-transcribe [data audio-type response-format & options]

  (assert (bytebuf? data)
          "The 'data' must be a bytebuf")
  (assert (keyword? audio-type)
          "The 'audio-type' must a keyword. E.g.: :mp3")
  (assert (keyword? response-format)
          "The 'response-format' must a keyword. E.g.: :json, :verbose_json")

  (let [opts            (apply hash-map options)
        _               (assert (or (nil? (:audio-opts  opts)) (map? (:audio-opts  opts))))
        uri             (:uri opts "https://api.openai.com/v1/audio/transcriptions")
        model           (to-model (:model opts) :whisper-1)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        param-parts     (->> (merge { :model model
                                      :response_format response-format } 
                                    (:audio-opts opts))
                             (map-keys-and-vals-to-string))
        audio-mimetype  (audio-mimetype audio-type)
        audio-filext    (audio-file-ext audio-mimetype)
        file-part       { "file"  { :filename  (str "audio." audio-filext)
                                    :mimetype  audio-mimetype
                                    :data      data } }
        multi-parts     (merge file-part param-parts)
        debug?          (:debug opts false)
        _               (when debug? (println "\nMultiparts:") (prn multi-parts))
        response        (hc/upload-multipart 
                          multi-parts 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(audio-speech-translate data audio-type response-format & options)" )
     :doc """
          Translates audio into English.

          ¶*Parameter «data»*

          The audio data (a byte buffer)

          ¶*Parameter «audio-type»*

          The audio type

          * `:flac`   (mimetype: audio/flac)
          * `:mp3`    (mimetype: audio/mpeg)
          * `:mp4`    (mimetype: audio/mp4)
          * `:m4a`    (mimetype: audio/m4a)
          * `:mpega`  (mimetype: audio/mpega)
          * `:ogg`    (mimetype: audio/ogg)
          * `:wav`    (mimetype: audio/wav)
          * `:webm`   (mimetype: audio/webm)

          ¶*Parameter «response-format»*

          The format in which the transcribed text is returned

          * `:json`
          * `:text`
          * `:srt`
          * `:verbose_json`
          * `:vtt`

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :model            | An OpenAI model. E.g.: "whisper-1". Defaults \
                                to "whisper-1". ¶\
                                The model can also be passed as a keyword. E.g.: \
                                `:whisper-1`,...  |
          | :audio-opts       | An optional map of OpenAI audio options. \
                                Map keys can be keywords or strings. ¶\
                                E.g. `{ :temperature 0, :prompt "....."}`. ¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/audio/createTranslation) |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "audio=v2"} |
          | :uri              | An OpenAI audio speech URI. E.g.: \
                                "https://api.openai.com/v1/audio/translations". ¶\
                                Defaults  to "https://api.openai.com/v1/audio/translations" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Audio API](https://platform.openai.com/docs/api-reference/audio)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (defn generate-mp3-audio [text]
              (let [response  (openai/audio-speech-generate text
                                                            :alloy
                                                            :mp3
                                                            :model :tts-1)]
                (openai/assert-response-http-ok response)
                (:data response)))

            (let [text       "Der schnelle braune Fuchs sprang über den faulen Hund."
                  audio-data (generate-mp3-audio text)
                  response   (openai/audio-speech-translate audio-data 
                                                            :mp3 
                                                            :json)]
              (openai/assert-response-http-ok response)
              (println (:text (:data response)))))
          """ )
     :see-also '( 
          "openai/audio-speech-generate"
          "openai/audio-speech-transcribe"
          "openai/audio-file-ext" ) }

  audio-speech-translate [data audio-type response-format & options]

  (assert (bytebuf? data)
          "The 'data' must be a bytebuf")
  (assert (keyword? audio-type)
          "The 'audio-type' must a keyword. E.g.: :mp3")
  (assert (keyword? response-format)
          "The 'response-format' must a keyword. E.g.: :json, :verbose_json")

  (let [opts            (apply hash-map options)
        _               (assert (or (nil? (:audio-opts  opts)) (map? (:audio-opts  opts))))
        uri             (:uri opts "https://api.openai.com/v1/audio/translations")
        model           (to-model (:model opts) :whisper-1)
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        param-parts     (->> (merge { :model model
                                      :response_format response-format } 
                                    (:audio-opts opts))
                             (map-keys-and-vals-to-string))
        audio-mimetype  (audio-mimetype audio-type)
        audio-filext    (audio-file-ext audio-mimetype)
        file-part       { "file"  { :filename  (str "audio." audio-filext)
                                    :mimetype  audio-mimetype
                                    :data      data } }
        multi-parts     (merge file-part param-parts)
        debug?          (:debug opts false)
        _               (when debug? (println "\nMultiparts:") (prn multi-parts))
        response        (hc/upload-multipart 
                          multi-parts 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
   (assoc result :data  (hc/slurp-response response 
                                           :json-parse-mode :data 
                                           :json-key-fn keyword))))



;; -----------------------------------------------------------------------------
;; FILES
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(file-upload file-data file-name file-mimetype purpose & options)" )
     :doc """
          Upload a file that can be used across various endpoints. Individual 
          files can be up to 512 MB, and the size of all files uploaded by one
          organization can be up to 100 GB.

          ¶*Parameters file*

          «file-data»      The file data, a `bytebuf`
          «file-name»      The file name. E.g.: "product-indo-pdf"
          «file-mimetype»  The file mimetype. E.g.: "application/pdf"
          
          ¶*Parameter «purpose»*

          Purpose is one of "assistants", "vision", "batch", "fine-tune"

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "files=v2"} |
          | :uri              | An OpenAI files URI. E.g.: \
                                "https://api.openai.com/v1/files". ¶\
                                Defaults  to "https://api.openai.com/v1/files" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Files API](https://platform.openai.com/docs/api-reference/files)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [file      "https://raw.githubusercontent.com/jlangch/venice/master/doc/pdfs/fonts-example.pdf"
                  response  (openai/file-upload  (io/download file :binary true)
                                                 "example.pdf"
                                                 "application/pdf" 
                                                 "assistants")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/file-list"
          "openai/file-retrieve"
          "openai/file-delete"
          "openai/file-retrieve-content" ) }

  file-upload [file-data file-name file-mimetype purpose & options]

  (assert (bytebuf? file-data))
  (assert (string? file-name))
  (assert (string? file-mimetype))
  (assert (string? purpose))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/files")
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        parts           { "file"    { :filename  file-name
                                      :mimetype  file-mimetype
                                      :data      file-data }
                          "purpose" purpose }
        debug?          (:debug opts false)
        _               (when debug? (println "\nMultiparts:") (prn parts))
        response        (hc/upload-multipart 
                          parts 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(file-list purpose & options)" )
     :doc """
          Returns a list of files that belong to the user's organization.
          
          ¶*Parameter «purpose»*

          The optional purpose is one of `nil`, "assistants", "vision", "batch", 
          "fine-tune"

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "files=v2"} |
          | :uri              | An OpenAI files URI. E.g.: \
                                "https://api.openai.com/v1/files?purpose={purpose}". ¶\
                                Defaults  to "https://api.openai.com/v1/files?purpose={purpose}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Files API](https://platform.openai.com/docs/api-reference/files)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/file-list nil)]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """,
          """
          (do
            (load-module :openai)

            (let [response  (openai/file-list "assistants")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/file-upload"
          "openai/file-retrieve"
          "openai/file-delete"
          "openai/file-retrieve-content" ) }

  file-list [purpose & options]

  (assert (or (nil? purpose) (string? purpose)))

  (let [opts            (apply hash-map options)
        purpose         (str/trim-to-nil purpose)
        uri             (if (some? purpose)   ;; OMG OpenAI - why no empty purpose?
                           (-> (:uri opts "https://api.openai.com/v1/files?purpose={purpose}")
                               (str/replace-all "{purpose}" (str/encode-url purpose)))
                           "https://api.openai.com/v1/files")
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(file-retrieve file-id & options)" )
     :doc """
          Returns information about a specific file.
          
          ¶*Parameter «file-id»*

          The ID of the file to use for this request.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "files=v2"} |
          | :uri              | An OpenAI files URI. E.g.: \
                                "https://api.openai.com/v1/files/{file-id}". ¶\
                                Defaults  to "https://api.openai.com/v1/files/{file-id}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Files API](https://platform.openai.com/docs/api-reference/files)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/file-retrieve "file-uo1oroO3MMRFwRAypupJX0pO")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/file-upload"
          "openai/file-list"
          "openai/file-delete"
          "openai/file-retrieve-content" ) }

  file-retrieve [file-id & options]

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/files/{file-id}")
        uri             (str/replace-all uri "{file-id}" (str/encode-url file-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(file-delete file-id & options)" )
     :doc """
          Delete a file.
          
          ¶*Parameter «file-id»*

          The ID of the file to use for this request.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "files=v2"} |
          | :uri              | An OpenAI files URI. E.g.: \
                                "https://api.openai.com/v1/files/{file-id}". ¶\
                                Defaults  to "https://api.openai.com/v1/files/{file-id}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Files API](https://platform.openai.com/docs/api-reference/files)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/file-delete "file-uo1oroO3MMRFwRAypupJX0pO")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/file-upload"
          "openai/file-list"
          "openai/file-retrieve"
          "openai/file-retrieve-content" ) }

  file-delete [file-id & options]

  (assert (string? file-id))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/files/{file-id}")
        uri             (str/replace-all uri "{file-id}" (str/encode-url file-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :delete 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(file-retrieve-content file-id & options)" )
     :doc """
          Returns the contents of the specified file.
          
          ¶*Parameter «file-id»*

          The ID of the file to use for this request.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "files=v2"} |
          | :uri              | An OpenAI files URI. E.g.: \
                                "https://api.openai.com/v1/files/{file-id}/content". ¶\
                                Defaults  to "https://api.openai.com/v1/files/{file-id}/content" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message.  ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Files API](https://platform.openai.com/docs/api-reference/files)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/file-retrieve-content "file-uo1oroO3MMRFwRAypupJX0pO")]
              (openai/assert-response-http-ok response)
              (let [data       (:data response)
                    file       "./example.pdf"]
                (io/spit file data)
                (prn "Saved to:" file))))
          """ )
     :see-also '( 
          "openai/file-upload"
          "openai/file-list"
          "openai/file-retrieve"
          "openai/file-delete" ) }

  file-retrieve-content [file-id & options]

  (assert (string? file-id))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/files/{file-id}/content")
        uri             (str/replace-all uri "{file-id}" (str/encode-url file-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers { "Content-Type" "application/json"
                                     "Authorization" (str "Bearer " openai-api-key)}
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))



;; -----------------------------------------------------------------------------
;; MODELS
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(model-list & options)" )
     :doc """
          Returns a list of the currently available models, and provides basic 
          information about each one such as the owner and availability.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "models=v2"} |
          | :uri              | An OpenAI models URI. E.g.: \
                                "https://api.openai.com/v1/models". ¶\
                                Defaults  to "https://api.openai.com/v1/models" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/models)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/model-list)]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/model-retrieve"
          "openai/model-delete" ) }

  model-list [& options]

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/models")
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn
  ^{ :arglists '(
          "(model-retrieve model & options)" )
     :doc """
          Retrieves a model instance, providing basic information about the model 
          such as the owner and permissioning.

          ¶*Parameter «model»*

          The ID of the model to use for this request

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "models=v2"} |
          | :uri              | An OpenAI models URI. E.g.: \
                                "https://api.openai.com/v1/models/{model}". ¶\
                                Defaults  to "https://api.openai.com/v1/models/{model}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/models)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/model-retrieve "gpt-4o")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/model-list"
          "openai/model-delete" ) }

  model-retrieve [model & options]
  
  (assert (string? model))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/models/{model}")
        uri             (str/replace-all uri "{model}" (str/encode-url model))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn
  ^{ :arglists '(
          "(model-delete model & options)" )
     :doc """
          Deletes a model instance.

          ¶*Parameter «model»*

          The ID of the model to use for this request
          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "models=v2"} |
          | :uri              | An OpenAI models URI. E.g.: \
                                "https://api.openai.com/v1/models/{model}". ¶\
                                Defaults  to "https://api.openai.com/v1/models/{model}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/models)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/model-delete "xyz")]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/model-list"
          "openai/model-retrieve" ) }

  model-delete [model & options]
  
  (assert (string? model))

  (let [opts            (apply hash-map options)
        uri             (:uri opts "https://api.openai.com/v1/models/{model}")
        uri             (str/replace-all uri "{model}" (str/encode-url model))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :delete 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))




;; -----------------------------------------------------------------------------
;; ASSISTANTS (core)
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(assistant-create name model & options)" )
     :doc """
          Create an assistant with a model and instructions.

          ¶*Parameter «name»*

          The name of the assistant. The maximum length is 256 characters.

          ¶*Parameter «model»*

          ID of the model to use. E.g.:  `:gpt-4o`

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :description      | The description of the assistant. The maximum length is \
                                512 characters. |
          | :instructions     | The system instructions that the assistant uses. \
                                The maximum length is 256,000 characters.|
          | :tools            | A list of tool enabled on the assistant. There can be a \
                                maximum of 128 tools per assistant. Tools can be of \
                                types "code_interpreter", "file_search", or "function". |
          | :tool-resources   | A set of resources that are used by the assistant's tools. \
                                The resources are specific to the type of tool. For example, \
                                the code_interpreter tool requires a list of file IDs, while \
                                the file_search tool requires a list of vector store IDs. |
          | :assistant-opts   | A map of additional assistant options like "metadata", \
                                "temperature", "top_p", "response_format".¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/assistants/createAssistant)|
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/assistants". ¶\
                                Defaults  to "https://api.openai.com/v1/assistants" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/assistants)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/assistant-create 
                                "Math Tutor"
                                :gpt-4o
                                :instructions \"\"\"
                                              You are a personal math tutor. When asked a question, 
                                              write and run Python code to answer the question.
                                              \"\"\"
                                :tools [ { "type" "code_interpreter" } ]
                                :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/assistant-create"
          "openai/assistant-list"
          "openai/assistant-retrieve"
          "openai/assistant-delete" ) }

  assistant-create [name model & options]

  (assert (string? name))
  (assert (or (keyword? model) (string? model)))

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/assistants"
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            (merge { :model           model
                                 :name            name
                                 :description     (:description opts)
                                 :instructions    (:instructions opts)
                                 :tools           (:tools opts)
                                 :tool_resources  (:tool-resources opts) }
                               (:assistant-opts opts))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(assistant-list & options)" )
     :doc """
          Returns a list of assistants.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :limit            | A limit on the number of objects to be returned. \
                                Limit can range between 1 and 100, and the default is 20. |
          | :order            | Sort order by the created_at timestamp of the objects. \
                                "asc" for ascending order and "desc" for descending order. |
          | :after            | A cursor for use in pagination. after is an object ID that defines \
                                your place in the list. For instance, if you make a list request \
                                and receive 100 objects, ending with obj_foo, your subsequent call \
                                can include after=obj_foo in order to fetch the next page of the \
                                list. |
          | :before           | A cursor for use in pagination. before is an object ID that \
                                defines your place in the list. For instance, if you make a list \
                                request and receive 100 objects, ending with obj_foo, your \
                                subsequent call can include before=obj_foo in order to fetch the \
                                previous page of the list. |
         | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/assistants". ¶\
                                Defaults  to "https://api.openai.com/v1/assistants" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/assistants)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/assistant-list :limit 10
                                                   :order "asc"
                                                   :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/assistant-create"
          "openai/assistant-list"
          "openai/assistant-retrieve"
          "openai/assistant-delete" ) }

  assistant-list [& options]

  (let [opts            (apply hash-map options)
        query-params    { "limit"  (:limit opts)
                          "order"  (:order opts)
                          "after"  (:after opts)
                          "before" (:before opts) }
        query-string    (->> (map-vals str query-params)
                             (filter-kv (fn [k v] (not (str/blank? v))))
                             (map (fn [[k v]] (str k "=" v)))
                             (str/join "&"))
        uri             (str "https://api.openai.com/v1/assistants"
                             (if (empty? query-string) nil (str "?" query-string)))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body nil
                          :debug  debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(assistant-retrieve assistant-id & options)" )
     :doc """
          Retrieves an assistant.

          ¶*Parameter «assistant-id»*

          The ID of the assistant to retrieve.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/assistants/{assistant-id}". ¶\
                                Defaults  to "https://api.openai.com/v1/assistants/{assistant-id}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/assistants)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/assistant-retrieve "asst_abc123"
                                                       :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/assistant-create"
          "openai/assistant-list"
          "openai/assistant-retrieve"
          "openai/assistant-delete" ) }

  assistant-retrieve [assistant-id & options]

  (assert (string? assistant-id))

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/assistants/{assistant-id}"
        uri             (str/replace-all uri "{assistant-id}" (str/encode-url assistant-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            nil
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(assistant-modify assistant-id & options)" )
     :doc """
          Modifies an assistant.

          ¶*Parameter «name»*

          The name of the assistant. The maximum length is 256 characters.

          ¶*Parameter «model»*

          ID of the model to use. E.g.:  `:gpt-4o`

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :name             | The name of the assistant. The maximum length is \
                                256 characters. |
          | :model            | The  ID of the model to use. E.g.: `:gpt-4o` |
          | :description      | The description of the assistant. The maximum length is \
                                512 characters. |
          | :instructions     | The system instructions that the assistant uses. \
                                The maximum length is 256,000 characters.|
          | :tools            | A list of tool enabled on the assistant. There can be a \
                                maximum of 128 tools per assistant. Tools can be of \
                                types "code_interpreter", "file_search", or "function". |
          | :tool-resources   | A set of resources that are used by the assistant's tools. \
                                The resources are specific to the type of tool. For example, \
                                the code_interpreter tool requires a list of file IDs, while \
                                the file_search tool requires a list of vector store IDs. |
          | :assistant-opts   | A map of additional assistant options like "metadata", \
                                "temperature", "top_p", "response_format".¶\
                                See: [OpenAI Request Options](https://platform.openai.com/docs/api-reference/assistants/createAssistant)|
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/assistants". ¶\
                                Defaults  to "https://api.openai.com/v1/assistants" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/assistants)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/assistant-create 
                                :instructions \"\"\"
                                              You are an HR bot, and you have access to files to answer 
                                              employee questions about company policies. Always 
                                              response with info from either of the files.
                                              \"\"\"
                                :tools [ { "type" "file_search" } ]
                                :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/assistant-create"
          "openai/assistant-list"
          "openai/assistant-retrieve"
          "openai/assistant-delete" ) }

  assistant-modify [assistant-id & options]

  (assert (string? assistant-id))

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/assistants/{assistant-id}"
        uri             (str/replace-all uri "{assistant-id}" (str/encode-url assistant-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            (->> (merge { :model           (:model opts)
                                      :name            (:name opts)
                                      :description     (:description opts)
                                      :instructions    (:instructions opts)
                                      :tools           (:tools opts)
                                      :tool_resources  (:tool-resources opts) }
                                     (:assistant-opts opts))
                             (filter-kv (fn [k v] (not (str/blank? v)))))
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(assistant-delete assistant-id & options)" )
     :doc """
          Delete an assistant.

          ¶*Parameter «assistant-id»*

          The ID of the assistant to delete.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/assistants/{assistant-id}". ¶\
                                Defaults  to "https://api.openai.com/v1/assistants/{assistant-id}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/assistants)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/assistant-delete "asst_abc123"
                                                     :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/assistant-create"
          "openai/assistant-list"
          "openai/assistant-retrieve"
          "openai/assistant-delete" ) }

  assistant-delete [assistant-id & options]

  (assert (string? assistant-id))

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/assistants/{assistant-id}"
        uri             (str/replace-all uri "{assistant-id}" (str/encode-url assistant-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            nil
        response        (hc/send :delete 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))



;; -----------------------------------------------------------------------------
;; ASSISTANTS (threads)
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(thread-create & options)" )
     :doc """
          Create a thread that assistants can interact with.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :messages         | A list of messages  |
          | :tool-resources   | A set of resources that are made available to the assistant's \
                                tools in this thread. The resources are specific to the type of \
                                tool. For example, the code_interpreter tool requires a list of \
                                file IDs, while the file_search tool requires a list of vector \
                                store IDs.|
          | :metadata         | Set of 16 key-value pairs that can be attached to an object. \
                                This can be useful for storing additional information about the \
                                object in a structured format. Keys can be a maximum of 64 \
                                characters long and values can be a maxium of 512 characters \
                                long. |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/threads". ¶\
                                Defaults  to "https://api.openai.com/v1/threads" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/threads)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/thread-create 
                                :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/thread-create"
          "openai/thread-retrieve" ) }

  thread-create [& options]

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/assistants"
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            { :messages        messages
                          :tool_resources  (:tool-resources opts)
                          :metadata        metadata }
        response        (hc/send :post 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))


(defn 
  ^{ :arglists '(
          "(thread-retrieve thread-id & options)" )
     :doc """
          Retrieves a thread.

          ¶*Parameter thread-id»*

          The ID of the thread to retrieve.

          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :openai-api-key   | An optional OpenAI API Key. As default the key is read \
                                from the environment variable "OPENAI_API_KEY". |
          | :headers          | Additional headers. E.g.: {"OpenAI-Beta" "assistants=v2"} |
          | :uri              | An OpenAI assistants URI. E.g.: \
                                "https://api.openai.com/v1/threads/{thread-id}". ¶\
                                Defaults  to "https://api.openai.com/v1/threads/{thread-id}" |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the HTTP request and response data |

          ¶*Return value*
           
          Returns a map with the response data:

          | [![width: 15%]] | [![width: 85%]]                  |
          | :status         | The HTTP status (a long)         |
          | :mimetype       | The content type's mimetype      |
          | :headers        | A map of headers. key: header name, value: list \
                              of header values |
          | :data           | If the response HTTP status is `HTTP_OK` \
                              the data fields contains the chat completion \
                              message. ¶\
                              If the response HTTP status is not `HTTP_OK` \
                              the data fields contains an error message \
                              formatted as plain or JSON string. |

          See:
          * [OpenAI Models API](https://platform.openai.com/docs/api-reference/threads)
          """ 
     :examples '(
          """
          (do
            (load-module :openai)

            (let [response  (openai/thread-retrieve "thread_abc123"
                                                    :headers { "OpenAI-Beta" "assistants=v2" })]
              (openai/assert-response-http-ok response)
              (prn (:data response))))
          """ )
     :see-also '( 
          "openai/thread-create"
          "openai/thread-retrieve" ) }

  thread-retrieve [thread-id & options]

  (assert (string? thread-id))

  (let [opts            (apply hash-map options)
        uri             "https://api.openai.com/v1/threads/{thread-id}"
        uri             (str/replace-all uri "{thread-id}" (str/encode-url thread-id))
        openai-api-key  (or (:openai-api-key opts) (openai-api-key-from-env))
        _               (validate-openai-api-key openai-api-key)
        debug?          (:debug opts false)
        body            nil
        response        (hc/send :get 
                          uri
                          :headers (openai-api-headers "application/json" 
                                                       openai-api-key
                                                       (:headers opts))
                          :body    (json/write-str body)
                          :debug   debug?)
        result          { :status   (:http-status response)
                          :mimetype (:content-type-mimetype response)
                          :headers  (:headers response) } ]
     (assoc result :data  (hc/slurp-response response 
                                             :json-parse-mode :data 
                                             :json-key-fn keyword))))




;; -----------------------------------------------------------------------------
;; ASSISTANTS (messages)
;; -----------------------------------------------------------------------------




;; -----------------------------------------------------------------------------
;; ASSISTANTS (runs)
;; -----------------------------------------------------------------------------




;; -----------------------------------------------------------------------------
;; ASSISTANTS (run steps)
;; -----------------------------------------------------------------------------




;; -----------------------------------------------------------------------------
;; FINETUNING
;; -----------------------------------------------------------------------------






;; -----------------------------------------------------------------------------
;; Public utils
;; -----------------------------------------------------------------------------

(defn 
 ^{ :arglists '(
          "(chat-process-streaming-events response handler & options)")
     :doc """
          Processes OpenAI server side events (SSE) and calls for every event 
          the passed handler function.
          
          Returns a `future`. This gives the caller the choice to synchronously
          or asynchronously process the events from the OpenAI server.
          
          Note: The response from the server must be of the mimetype 
                "text/event-stream" otherwise the processor throws an exception!
          
          ¶The event handler is a three argument function:
          
          `(defn handler [delta accumulated status] ...)`
          
          | *delta*       | the delta message sent with the event |
          | *accumulated* | the accumulated message |
          | *type*        | the notification type: ¶\
                            \u00A0\u00A0 `:opened` - streaming started ¶\
                            \u00A0\u00A0 `:data` - streamed event ¶\
                            \u00A0\u00A0 `:done` - streaming done by the server |


          ¶*Parameter «options»*

          | [![width: 15%]]   | [![width: 85%]] |
          | :debug            | An optional debug flag (true/false). Defaults \
                                to false. ¶\
                                In debug mode prints the streaming response data |
          """
     :examples '(
          """
          (do
            (load-module :openai)
            (load-module :http-client-j8 ['http-client-j8 :as 'hc])
          
            (let [api-key   (system-env "OPENAI_API_KEY")
                  content   \"\"\"
                            Count to 10, with a comma between each number and no newlines. 
                            E.g., 1, 2, 3, ...
                            \"\"\"
                  body      { :model    :gpt-4o
                              :messages [ { :role   "user" 
                                            :content content  } ]
                              :stream   true } 
                  response  (hc/send :post 
                              "https://api.openai.com/v1/chat/completions"
                              :headers { "Content-Type" "application/json"
                                         "Authorization" (str "Bearer " api-key)}
                              :body (json/write-str body)
                              :debug false)]
              (println "Status:" (:http-status response))
              (if (= "text/event-stream" (:content-type-mimetype response))
                (let [data @(openai/chat-process-streaming-events 
                                response
                                (fn [delta accumulated status]
                                  (case status
                                    :opened  (println "Started...")
                                    :data    (println "Delta:" (pr-str delta))
                                    :done    (println "Completed."))))]
                  (println "Message:" (pr-str (message data))))
                (println (hc/slurp-response response :json-parse-mode :pretty-print)))))
          """ )
     :see-also '( 
          "http-client-j8/slurp-response" ) }

  chat-process-streaming-events [response handler & options]

  (assert (some? response))
  (assert (fn? handler))

  (when-not (= "text/event-stream" (:content-type-mimetype response))
    (throw (ex :VncException 
                """
                OpenAI server side events can only be processed on a response \
                with mimetype 'text/event-stream'!
                """)))

  (let [opts    (apply hash-map options)
        debug?  (:debug opts false)]
    ;; return a future
    (future #(do
        (let [data-accumulator  (atom "")
              usage-accumulator (atom nil)]
          ;; process the events
          (hc/process-server-side-events 
                response
                (fn [type event event-count]
                  (case type
                    :opened (do (handler "" "" :opened)
                                :ok)
                    :data   (let [payload (first (:data event))]
                              (if (= payload "[DONE]")
                                :stop
                                (let [data  (json/read-str payload :key-fn keyword)
                                      delta (extract-streaming-delta-content data debug?)
                                      usage (:usage data)]
                                  (when debug? 
                                    (hc/debug-header "Streaming response")
                                    (println data)
                                    (println))
                                  (when (some? usage)
                                    (reset! usage-accumulator usage))
                                  (when (some? delta)
                                    (swap! data-accumulator str delta)
                                    (handler delta @data-accumulator :data))
                                  :ok)))
                    :closed (do (handler "" nil :done)
                                :ok))))
          ;; the future returns the accumulated response text and the usage
          { :message  @data-accumulator
            :usage    @usage-accumulator })))))


(defn 
  ^{ :arglists '(
          "(pretty-print-json data)")
     :doc """
          Returns a pretty printed Venice JSON data value.
          """
     :see-also '( 
          "openai/chat-extract-response-message-content" ) }

  pretty-print-json [data]

  (if (coll? data) (json/pretty-print (json/write-str data)) data))


(defn 
  ^{ :arglists '(
          "(assert-response-http-ok response)")
     :doc """
          Throws an exception if the response HTTP status is not HTTP_OK.

          The exception holds the response details.
          """ }

  assert-response-http-ok [response]

  (when-not (=  (:status response) 200)
    (let [status    (:status response)
          mimetype  (:mimetype response)
          info      """
                    HTTP response is not HTTP_OK!
                    
                    HTTP Status: ~{status}
                    Mimetype:    ~{mimetype}
                    
                    Response:

                    """]
      (case mimetype
        "application/json"   (let [details (openai/pretty-print-json (:data response))]
                               (throw (ex :VncException (str info details))))
 
        "plain/text"         (let [details (:data response)]
                               (throw (ex :VncException (str info details))))
 
        "plain/html"         (let [details (:data response)]
                               (throw (ex :VncException (str info details))))

        (throw (ex :VncException info))))))


(defn 
  ^{ :arglists '(
          "(chat-extract-response-message response)"
          "(chat-extract-response-message response choice-idx)")
     :doc """
          Returns the message of an OpenAI chat JSON response.
          """
     :see-also '( 
          "openai/chat-extract-response-message"
          "openai/chat-extract-response-message-role"
          "openai/chat-extract-response-message-content"
          "openai/chat-extract-response-tool-calls-id"
          "openai/chat-extract-function-name" ) }

  chat-extract-response-message 
  
  ([response]
    (chat-extract-response-message response 0))

  ([response choice-idx]
    (assert (coll? response))
    (-<> (:choices response)
         (nth <> choice-idx)
         (:message <>))))


(defn 
  ^{ :arglists '(
          "(chat-extract-response-message-content response)"
          "(chat-extract-response-message-content response choice-idx)")
     :doc """
          Returns the message content of an OpenAI chat JSON response.
          """
     :see-also '( 
          "openai/chat-extract-response-message"
          "openai/chat-extract-response-message-role"
          "openai/chat-extract-response-tool-calls-id"
          "openai/chat-extract-function-name" ) }

  chat-extract-response-message-content 
  
  ([response]
    (chat-extract-response-message-content response 0))

  ([response choice-idx]
    (assert (coll? response))
    (-<> (:choices response)
         (nth <> choice-idx)
         (:message <>)
         (:content <>))))


(defn 
  ^{ :arglists '(
          "(chat-extract-response-message-role response)"
          "(chat-extract-response-message-role response choice-idx)")
     :doc """
          Returns the message role of an OpenAI chat JSON response.
          """
     :see-also '( 
          "openai/chat-extract-response-message"
          "openai/chat-extract-response-message-content"
          "openai/chat-extract-response-tool-calls-id"
          "openai/chat-extract-function-name" ) }

  chat-extract-response-message-role 
  
  ([response]
    (chat-extract-response-message-role response 0))

  ([response choice-idx]
    (assert (coll? response))
    (-<> (:choices response)
         (nth <> choice-idx)
         (:message <>)
         (:role <>))))


(defn 
  ^{ :arglists '(
          "(chat-extract-response-tool-calls-id response)"
          "(chat-extract-response-tool-calls-id response choice-idx)")
     :doc """
          Returns the message "tool_calls" id of an OpenAI chat JSON response.
          """
     :see-also '( 
          "openai/chat-extract-response-message"
          "openai/chat-extract-response-message-role"
          "openai/chat-extract-response-message-content"
          "openai/chat-extract-function-name" ) }

  chat-extract-response-tool-calls-id
  
  ([response]
    (chat-extract-response-tool-calls-id response 0))

  ([response choice-idx]
    (assert (coll? response))
    (-<> (:choices response)
         (nth <> choice-idx)
         (:message <>)
         (:tool_calls <>)
         (:id <>))))


(defn 
  ^{ :arglists '(
          "(chat-extract-function-name response)"
          "(chat-extract-function-name response choice-idx tools-calls-idx)")
     :doc """
          Returns the function name of an OpenAI chat JSON response.
          """
     :see-also '( 
          "openai/chat-extract-response-message"
          "openai/chat-extract-response-message-role"
          "openai/chat-extract-response-message-content"
          "openai/chat-extract-response-tool-calls-id" ) }

  chat-extract-function-name 
  
  ([response]
    (chat-extract-function-name response 0 0))

  ([response choice-idx tools-calls-idx]
    (assert chat-finish-reason-tool-calls? response)
    (-<> (:choices response)
         (nth <> choice-idx)
         (:message  <>)
         (:tool_calls <>)
         (nth <> tools-calls-idx)
         (:function <>)
         (:name  <>))))


(defn pretty-print-conversation [messages]
  (doseq [m messages]
    (let [{:keys [role content]}  m]
      (case role
        :system     (println (ansi/style (str "system: " content) 
                                         (:bright-red ansi/ANSI-CODES)))
        :user       (println (ansi/style (str "user: " content) 
                                         (:bright-green ansi/ANSI-CODES)))
        :assistant  (println (ansi/style (str "assistant: " content) 
                                         (:bright-blue ansi/ANSI-CODES)))
        :function   (println (ansi/style (str "function: " content) 
                                         (:bright-magenta ansi/ANSI-CODES)))))))


(defn
  ^{ :arglists '(
          "(image-download url basename)")
     :doc """
          Downloads an image from the given url.

          Returns a map with the image data.

          E.g.: basename = image-1

          ```
          { :name     image-1.png
            :mimetype "image/png"
            :data     <bytebuf> }
          ```
          """ }

  image-download [url img-basename]

  (let [img-response (hc/send :get url)
        mimetype     (:content-type-mimetype img-response)
        img-name     (image-file-name-from-mimetype img-basename mimetype)
        data         (hc/slurp-response img-response)]                 
    { :name     img-name
      :mimetype mimetype
      :data     data }))

(defn 
  ^{ :arglists '(
          "(image-file-name-from-mimetype basename mimetype)")
     :doc """
          Creates an image file name from a given basename and an image mimetype.

          Examples:

          | basename | mimetype   | filename       |
          | :--------| :--------- | :------------- |
          | image-1  | image/png  | "image-1.png"  |
          | image-2  | image/jpeg | "image-2.jpeg" |
          | image-3  | image/gif  | "image-3.gif"  |
          """ }
  image-file-name-from-mimetype [basename mimetype]

  (assert (string? basename))
  (assert (string? mimetype))

  (str basename "." (second (str/split mimetype "/"))))



;; -----------------------------------------------------------------------------
;; OpenAI Functions
;; -----------------------------------------------------------------------------
                                        
;; -----------------------------------------------------------------------------
;; To remember: An OpenAI response looks like
;;
;; { "created": 1714685814,
;;   "usage": {
;;     "completion_tokens": 26,
;;     "prompt_tokens": 194,
;;     "total_tokens": 220
;;   },
;;   "model": "gpt-4-0613",
;;   "id": "chatcmpl-9KYOkTLMgIEDN2hpGxCvf4cyOROHJ",
;;   "choices": [{
;;     "finish_reason": "tool_calls",
;;     "index": 0,
;;     "message": {
;;       "role": "assistant",
;;       "tool_calls": [{
;;         "function": {
;;           "name": "get_current_weather",
;;           "arguments": "{\n  \"format\": \"celsius\",\n  \"location\": \"Glasgow\"\n}"
;;         },
;;         "id": "call_I9RjSt5rnawMQD1g4GB7xGY3",
;;         "type": "function"
;;       }],
;;       "content": null
;;     },
;;     "logprobs": null
;;   }],
;;   "system_fingerprint": null,
;;   "object": "chat.completion"
;; }
;; -----------------------------------------------------------------------------


(defn 
  ^{ :arglists '(
          "(chat-finish-reason response)"
          "(chat-finish-reason response choice-idx)")
     :doc """
          Returns the finish reason text from an OpenAI JSON response.

          The text depends may be "stop" or "tool_calls". The first signals
          that the response contains an answer from the model to the passed
          question. With the ladder the models signals to the caller that
          functions must be executed to get specific data to answer the question.
          """
     :see-also '( 
          "openai/chat-finish-reason-stop?"
          "openai/chat-finish-reason-tool-calls?"
          "openai/exec-fn" ) }
  
  chat-finish-reason 
  
  ([response]
    (chat-finish-reason response 0))
  
  ([response choice-idx]
    (-<> (:choices response)
         (nth <> choice-idx)
         (:finish_reason <>))))


(defn 
  ^{ :arglists '(
          "(chat-finish-reason-stop? response)"
          "(chat-finish-reason-stop? response choice-idx)")
     :doc """
          Returns true if the OpenAI JSON response provides an answer to
          the prompt.
          """
     :see-also '( 
          "openai/chat-finish-reason"
          "openai/chat-finish-reason-tool-calls?"
          "openai/exec-fn" ) }

  chat-finish-reason-stop? 
  
  ([response]
    (chat-finish-reason-stop? response 0))

  ([response choice-idx]
    (assert map? response)
    (= "stop" (chat-finish-reason response choice-idx))))


(defn 
  ^{ :arglists '(
          "(chat-finish-reason-tool-calls? response)"
          "(chat-finish-reason-tool-calls? response choice-idx)")
     :doc """
          Returns true if the OpenAI JSON response contains tool calls 
          (functions) that it wants the client to run
          """
     :see-also '( 
          "openai/chat-finish-reason"
          "openai/chat-finish-reason-stop?"
          "openai/exec-fn" ) }

  chat-finish-reason-tool-calls? 
  
  ([response]
    (chat-finish-reason-tool-calls?  response 0))

  ([response choice-idx]
    (assert map? response)
    (= "tool_calls" (chat-finish-reason response choice-idx))))


(defn 
  ^{ :arglists '(
          "(exec-fn response fn-map)")
     :doc """
          Execute all functions from an OpenAI JSON response.

          `fn-map` is map of named functions:

          ```
          { "get_current_weather"        get-current-weather
            "get_n_day_weather_forecast" get-n-day-weather-forecast }
          ```

          Returns a list of function results, one for each function called. 

          | [![width: 15%]] | [![width: 85%]]        |
          | OK result      | `{ :ok value }`. E.g: `{ :ok "15˚C" }` |
          | ERROR result   | `{ :err exception }`. |
          """
     :see-also '( 
          "openai/chat-finish-reason"
          "openai/chat-finish-reason-stop?"
          "openai/chat-finish-reason-tool-calls?" ) }

  exec-fn [response fn-map]

  (assert map? response)
  (assert map? fn-map)

  (when-not (chat-finish-reason-tool-calls? response) 
    (throw (ex :VncEception 
              """
              The OpenAI response does not have a "tool_calls" finish reason! 
              Thus the response does not define any functions with arguments
              to call. The finish reason returned was 
              "~(exec-chat-finish-reason response)".
              """ )))

  (loop [results []
         fns     (get-function-calls response)]
    (if (empty? fns)
      results
      (let [fn-def   (first fns) ;; next function def to process
            name     (:name fn-def)
            args-str (:arguments fn-def) ;; OpenAI decided to return a simple
                                         ;; string containing JSON data to
                                         ;; to keep the order of the args!
                                         ;; A list of tuples had been the 
                                         ;; better choice here!
            args     (json/read-str args-str)] ;; convert string to JSON
        (if-let [f (get fn-map name)]         
          (recur (conj results (call-function name f args)) ;; call the function
                 (rest fns))        
          (recur (conj results (make-err-missing-fn name)) ;; missing function
                 (rest fns)))))))


(defn 
  ^{ :arglists '(
          "(audio-file-ext mimetype)")
     :doc """
          Returns the file extension for an audio mimetype.

          Examples:

          | mimetype    | file extension |
          | :---------- | :------------- |
          | audio/aac   | "aac"          |
          | audio/flac  | "flac"         |
          | audio/mpeg  | "mp3"          |
          | audio/mp4   | "mp4"          |
          | audio/mpega | "mpega"        |
          | audio/opus  | "opus"         |
          | audio/ogg   | "ogg"          |
          | audio/pcm   | "pcm"          |
          | audio/wav   | "wav"          |
          | audio/webm  | "webm"         |
          | else        | "binary"       |
          """ }

   audio-file-ext [mimetype]

   (assert (string? mimetype))

   (get audio-mimetypes mimetype "binary"))

(defn 
  ^{ :arglists '(
          "(audio-mimetype audio-type)")
     :doc """
          Returns the mimetype for an audio type.

          Examples:  :mp3  -> "audio/mpeg"
          """ }

   audio-mimetype [audio-type]

   (assert (keyword? audio-type))

   (if-let [mimetype (get (map-invert audio-mimetypes) (name audio-type) "binary")]
     mimetype
     (throw (ex :VncException "Unknown audio type \"~(audio-type)\"!"))))


(defn- get-function-calls [response]
  (->> (:choices response)
       (first)
       (:message)
       (:tool_calls)
       (filter #(= "function" (:type %)))
       (map :function)))
  

(defn- call-function [name f args]
  (try 
    (make-ok (f args))
    (catch :Exception e (make-err-failed-call name args e))))


(defn- make-ok [ret-val]
  {:ok ret-val})


(defn- make-err-missing-fn [name]
  {:err (ex :VncException 
            "Failed to call OpenAI undefined function \"~{name}\"!" )})
      

(defn- make-err-failed-call [name args ex_]
  (let [arity (count args)]
    {:err (ex :VncException 
              "Failed to call OpenAI function \"~{name} with arity ~{arity}\"!" 
              ex_)}))



;; -----------------------------------------------------------------------------
;; Util functions
;; -----------------------------------------------------------------------------

(defn- to-model [model default-model] 
  (let [model (or model default-model)]
    (cond
      (keyword? model)  (name model)
      (string? model)   model
      :else             (throw (ex :VncException 
                                    "Invalid OpenAI model data type ~(type model).")))))
  

(defn- extract-streaming-delta-content [data debug?]
  (-> (:choices data)
      (first)
      (:delta)
      (:content)))


(defn- openai-api-headers 
  ([content-type openai-api-key]
    (assert (string? content-type))
    (assert (string? openai-api-key))
    { "Content-Type"  content-type
      "Authorization" (str "Bearer " openai-api-key) })
  
  ([content-type openai-api-key headers]
    (assert (or (nil? headers) (map? headers)))
    (merge (openai-api-headers content-type openai-api-key)
           headers)))


(defn- openai-api-key-from-env [] 
  (system-env "OPENAI_API_KEY"))


(defn- build-chat-prompt [model prompt prompt-opts tools tool-choice overrule-opts]
  (let [p (cond 
            (nil? prompt)        {}
            (string? prompt)     {:messages [{:role "user" :content prompt}]}
            (sequential? prompt) {:messages prompt}
            (map? prompt)        prompt
            :else                {} )]
    (merge {:model model} 
           p 
           (if (nil? tools) {} {:tools tools})
           (if (nil? tool-choice) {} {:tool_choice tool-choice})
           (or prompt-opts {})
           (or overrule-opts {}))))


(defn- build-image-prompt [model prompt prompt-opts overrule-opts]
  (merge {:model  model
          :prompt prompt} 
         (or prompt-opts {})
         (or overrule-opts {})))


(defn- map-keys-and-vals [dict]
   (let [mapper (fn [v] (if (keyword? v) (name v) v))]
     (->> dict
          (map-keys mapper)
          (map-vals mapper))))


(defn- map-keys-and-vals-to-string [dict]
   (let [mapper (fn [v] (if (keyword? v) (name v) (str v)))]
     (->> dict
          (map-keys mapper)
          (map-vals mapper))))


(defn- dump-prompt [prompt]
  (println "\nPrompt:")
  (println (json/pretty-print (json/write-str prompt))))


(defn- validate-openai-api-key [key]
  (when (nil? key)
    (throw (ex :VncException 
               """
               Missing OpenAI api key!
               Please define an environment variable with the name \
               "OPENAI_API_KEY" or pass the key as an option \
               `:openai-api-key "sk-xxxxxxxxxxxxx"`.
               """))))


(defn- validate-tools [tools]
  (when (some? tools)
    (when-not (sequential? tools)
      (throw (ex :VncException 
                  """
                  OpenAI tools options (`:tools`) must be `nil` or a sequence of maps!

                  E.g.:

                  [ { :type "function" 
                      :function {
                          :name "get_current_weather"
                          :description "Get the current weather"
                          :parameters { ... }
                      } } ]
                  """)))))


(defn- validate-tool-choice [tools-choice]
  (when (some? tools-choice)
    (when-not (or (string? tools-choice) (map? tools-choice))
      (throw (ex :VncException 
                  """
                  An OpenAI tool choice option (`:tool_choice`) must be `nil` 
                  a string or a map!

                  E.g.:

                  { :type "function"
                    :function { 
                      :name "get_n_day_weather_forecast" 
                    } 
                  }
                  """)))))

