;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2023 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Docker utilities

;;;; See:  https://docs.docker.com/engine/reference/commandline/

;;;; Most used commands
;;;; ---------------------------------------------------------------------------
;;;; Images     (println (docker/images :format :table))
;;;;            (println (docker/image-pull "arangodb/arangodb:3.10.10"))
;;;;            (println (docker/image-rm "184e47dd1c58"))
;;;;            (println (docker/image-prune :all true))
;;;;
;;;; Containers

(ns docker)


(defonce debug-modes #{:off :on :on-no-exec})

(def-dynamic *debug* :off)


(defn
  ^{ :arglists '("(docker/debug mode)")
     :doc """
          Sets the debugging mode.

          Without argument returns the current debug mode.

          Mode:

          | :off        | No debug output |
          | :on         | Prints the raw docker command line to the current stdout channel ahead of running the command |
          | :on-no-exec | Prints the raw docker command line to the current stdout channel without running the command |
          """
     :examples '(
          "(docker/debug :on)"
          "(docker/debug :on-no-exec)"
          "(docker/debug :off)") }

  debug

  ([] docker/*debug*)

  ([mode]
    (assert (contains? debug-modes mode)
            "A debug mode must be one of {:off, :on, :on-no-exec}")
    (set! docker/*debug* mode)))


(defn
  ^{ :arglists '("(docker/version & options)")
     :doc """
          Returns the Docker version.

          Options:

          | :format {:string, :json} | Returns the output either as a string or as JSON data |
          | :version {:full, :server, :client} | Returns full (default), server, or client version |
          """
     :examples '(
          "(docker/version)"
          "(docker/version :version :client)"
          "(docker/version :version :server)"
          "(docker/version :format :json)"
          "(println (docker/version :format :string))" )
     :see-also '(
          "docker/images"
          "docker/run")}

  version [& options]

  (let [opts     (apply hash-map options)
        format   (:format opts nil)
        version  (:version opts :full)]
    (case version
      :full   (as-> (if (= format :json) "version -f json" "version") $
                    (docker/cmd $)
                    (:out $)
                    (parse-output-object format $))
      :server (as-> (docker/version :version :full :format :json) $
                    (get-in $ ["Server" "Version"]))
      :client (as-> (docker/version :version :full :format :json) $
                    (get-in $ ["Client" "Version"]))
      (throw (ex :VncException "Please use a format of {:string, :json}")))))



;; -----------------------------------------------------------------------------
;; Image functions
;;   - docker/images
;;   - docker/rmi
;;   - docker/image-rm
;;   - docker/image-pull
;;   - docker/image-prune
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(docker/images & options)")
     :doc """
          List images.

          Options:

          | :all {true, false}      | Show all images (default hides intermediate images) |
          | :digests {true, false}  | Show digests |
          | :quiet {true, false}    | If true only display image IDs |
          | :no-trunc {true, false} | Don't truncate output |
          | :format {:table, :json} | Returns the output either as a table string or as JSON data |
          """
     :examples '(
          "(println (docker/images :format :table))"
          "(docker/images :quiet true :no-trunc true :format :json)"
          "(println (docker/images :format :json))" )
     :see-also '(
          "docker/image-pull"
          "docker/rmi"
          "docker/image-rm"
          "docker/image-prune"
          "docker/run" ) }

  images [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)      ;; (if all "--all" nil)  ;; hangs on MacOSX
        digests  (:digests opts false)
        quiet    (:quiet opts false)
        no-trunc (:no-trunc opts false)
        format   (:format opts :json)
        cmdargs* ["images"]
        cmdargs* (if digests (conj cmdargs* "--digests") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if no-trunc (conj cmdargs* "--no-trunc") cmdargs*)
        cmdargs* (into cmdargs* ["--format" (name format)])]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output-list format))))


(defn
  ^{ :arglists '("(docker/image-pull name & options)")
     :doc """
          Download an image from a registry.

          Images can be pulled by name, name and tag, or digest

          Returns the stdout text from the command.

          Options:

          | :quiet {true, false} | Suppress verbose output |
          """
     :examples '(
          """
          (println (docker/image-pull "arangodb/arangodb:3.10.10"))
          (println (docker/image-pull "arangodb/arangodb"))
          """ )
     :see-also '(
          "docker/images"
          "docker/rmi"
          "docker/image-rm"
          "docker/image-prune" ) }

  image-pull [name & options]

  (let [opts     (apply hash-map options)
        quiet    (:quiet opts false)
        cmdargs* ["image" "pull"]
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (conj cmdargs* name)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/rmi image & options)")
     :doc """
          Remove an image.

          Images can be removed by name, name and tag, or image id

          Options:

          | :force {true, false} | Force removal of the image |
          | :no-prune {true, false} | Do not delete untagged parents |
          """
     :examples '(
          """
          (println (docker/rmi "arangodb/arangodb:3.10.10" :force true))
          """ )
     :see-also '(
          "docker/images"
          "docker/image-pull"
          "docker/image-rm"
          "docker/image-prune" ) }

  rmi [image & options]

  (let [opts     (apply hash-map options)
        force    (:force opts false)
        no-prune (:no-prune opts false)
        cmdargs* ["rmi"]
        cmdargs* (if force (conj cmdargs* "--force") cmdargs*)
        cmdargs* (if no-prune (conj cmdargs* "--no-prune") cmdargs*)
        cmdargs* (conj cmdargs* image)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/image-rm image-id)")
     :doc """
          Remove an image.
          """
     :examples '(
          """
          (println (docker/image-rm "184e47dd1c58"))
          """ )
     :see-also '(
          "docker/images"
          "docker/image-pull"
          "docker/rmi"
          "docker/image-prune" ) }

  image-rm [image-id]

  (let [cmdargs* ["image" "rm" image-id]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/image-prune & options)")
     :doc """
          Remove unused images.

          If `:all true` is specified, will also remove all images not
          referenced by any container. This is what you usually expect

          Returns the stdout text from the command.

          Options:

          | :all {true, false}      | Remove all unused images, not just dangling ones |
          """
     :examples '(
          "(println (docker/image-prune))"
          "(println (docker/image-prune :all true))" )
     :see-also '(
         "docker/images"
         "docker/image-pull"
         "docker/rmi"
         "docker/image-rm" ) }

  image-prune [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)
        cmdargs* ["image" "prune" "--force"]  ;; Do not prompt for confirmation
        cmdargs* (if all (conj cmdargs* "--all") cmdargs*)]
    (:out (apply docker/cmd cmdargs*))))



;; -----------------------------------------------------------------------------
;; Container functions
;;   - docker/run
;;   - docker/ps
;;   - docker/start
;;   - docker/stop
;;   - docker/rm
;;   - docker/prune
;;   - docker/exec
;;   - docker/cp
;;   - docker/diff
;;   - docker/pause
;;   - docker/unpause
;;   - docker/cp
;;   - docker/volume-list
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(docker/run image & options)")
     :doc """
          Create and run a new container from an image.

          Images can be run by name, name and tag, or image id

          Options:

          | :detach {true, false}   | Run container in background and return container ID |
          | :publish port           | Publish a container's port(s) to the host |
          | :envs vars              | Set environment variable (a sequence of env var defs) |
          | :memory limit           | Memory limit |
          | :name name              | Assign a name to the container |
          | :quiet {true, false}    | Suppress the pull output |
          | :volumes vol            | Bind mount a volume (a sequence of volume defs)|
          | :workdir dir            | Working directory inside the container |
          | :args args              | Arguments passed to container process (a sequence of args or a string) |
          """
     :examples '(
          """
          ;; Run an ArangoDB container
          (docker/run "arangodb/arangodb:3.10.10"
                      :name "myapp"
                      :publish "8529:8529"
                      :detach true
                      :envs ["ARANGO_ROOT_PASSWORD=xxxxxx"
                             "ARANGODB_OVERRIDE_DETECTED_TOTAL_MEMORY=8G"
                             "ARANGODB_OVERRIDE_DETECTED_NUMBER_OF_CORES=1"]
                      :volumes ["/Users/foo/arangodb/db:/var/lib/arangodb3"
                                "/Users/foo/arangodb/apps:/var/lib/arangodb3-apps"])
          """,
          """
          ;; Run an ArangoDB container
          (docker/run "arangodb/arangodb:3.10.10"
                      :name "myapp"
                      :publish "8529:8529"
                      :detach true
                      :envs ["ARANGO_ROOT_PASSWORD=xxxxxx"
                             "ARANGODB_OVERRIDE_DETECTED_TOTAL_MEMORY=8G"
                             "ARANGODB_OVERRIDE_DETECTED_NUMBER_OF_CORES=1"]
                      :volumes ["/Users/foo/arangodb/db:/var/lib/arangodb3"
                                "/Users/foo/arangodb/apps:/var/lib/arangodb3-apps"]
                      :args ["--database.auto-upgrade"])
          """ )
     :see-also '(
          "docker/images"
          "docker/ps"
          "docker/start" "docker/stop"
          "docker/rm" "docker/prune"
          "docker/exec" "docker/cp" "docker/diff"
          "docker/pause" "docker/unpause"
          "docker/cp"
          "docker/container-find-by-name"
          "docker/container-exists-with-name?"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  run [image & options]

  (let [opts     (apply hash-map options)
        detach   (:detach opts false)
        publish  (:publish opts nil)
        envs     (:envs opts [])
        memory   (:memory opts 0)
        name     (:name opts nil)
        quiet    (:quiet opts false)
        volumes  (:volumes opts [])
        workdir  (:workdir opts nil)
        args     (:args opts [])
        cmdargs* ["run"]
        cmdargs* (if detach (conj cmdargs* "--detach") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if (some? publish) (conj cmdargs* "--publish" publish) cmdargs*)
        cmdargs* (if (pos? memory) (conj cmdargs* "--memory" memory) cmdargs*)
        cmdargs* (if (some? name) (conj cmdargs* "--name" name) cmdargs*)
        cmdargs* (if (some? workdir) (conj cmdargs* "--workdir" workdir) cmdargs*)
        cmdargs* (if (and (some? volumes) (vector? volumes))
                   (into cmdargs* (interleave (lazy-seq (constantly "--volume")) volumes))
                   cmdargs*)
        cmdargs* (if (and (some? envs) (vector? envs))
                   (into cmdargs* (interleave (lazy-seq (constantly "--env")) envs))
                   cmdargs*)
        cmdargs* (conj cmdargs* image)
        cmdargs* (if (and (some? args) (vector? args)) (into cmdargs* args) cmdargs*)]
    ;; check if there is a already container with the name
    (when (some? name)
      (assert (not (container-running-with-name? name))
              "There is already a container running with the name \"~{name}\"!")
      (assert (not (container-exists-with-name? name))
              "There is already a container with the name \"~{name}\"! You can use `docker/start` instead."))
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/ps & options)")
     :doc """
          List containers.

          Options:

          | :all {true, false}      | Show all containers (default shows just running) |
          | :last n                 | Show n last created containers |
          | :quiet {true, false}    | If true only display container IDs |
          | :no-trunc {true, false} | Don't truncate output |
          | :format {:table, :json} | Returns the output either as a table string or as JSON data |
          """
     :examples '(
          "(println (docker/ps :all true :format :table))"
          "(docker/ps :all true :format :json)"
          "(docker/ps :all true :no-trunc true :format :json)"
          "(docker/ps :all true :no-trunc true :last 3 :format :json)"
          "(println (docker/ps :all true :format :json))" )
     :see-also '(
          "docker/start"
          "docker/stop"
          "docker/rm"
          "docker/run" ) }

  ps [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)
        lastn    (:last opts -1)
        quiet    (:quiet opts false)
        no-trunc (:no-trunc opts false)
        format   (:format opts :json)
        cmdargs* ["ps"]
        cmdargs* (if all (conj cmdargs* "--all") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if no-trunc (conj cmdargs* "--no-trunc") cmdargs*)
        cmdargs* (into cmdargs* ["--last" lastn])
        cmdargs* (into cmdargs* ["--format" (name format)])]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output-list format))))


(defn
  ^{ :arglists '("(docker/start container & options)")
     :doc """
          Start a stopped container.

          Options:

          | :attach {true, false} | Attach STDOUT/STDERR and forward signals |
          """
     :examples '(
          """(docker/start "b19b498c670b")""" )
     :see-also '(
          "docker/stop"
          "docker/ps"
          "docker/run" ) }

  start [container & options]

  (let [opts     (apply hash-map options)
        attach   (:attach opts false)
        cmdargs* ["start"]
        cmdargs* (if attach (conj cmdargs* "--attach") cmdargs*)
        cmdargs* (conj cmdargs* container)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/stop container & options)")
     :doc """
          Stop a container.

          Options:

          | :signal name | Signal to send to the container |
          | :time n      | Seconds to wait before killing the container |
          """
     :examples '(
          """
          (docker/stop "b19b498c670b" :time 30)
          """ )
     :see-also '(
          "docker/start"
          "docker/ps"
          "docker/run" ) }

  stop [container & options]

  (let [opts     (apply hash-map options)
        signal   (:signal opts nil)
        time     (:time opts 0)
        cmdargs* ["stop"]
        cmdargs* (if (and (some? signal) (string? signal))
                   (into cmdargs* ["--signal" signal])
                   cmdargs*)
        cmdargs* (if (and (number? time) (pos? time))
                   (into cmdargs* ["--time" time])
                   cmdargs*)
        cmdargs* (conj cmdargs* container)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/exec container command)")
     :doc """
          Execute a command in a running container (always in detached mode).
          """
     :examples '(
          """
          (docker/exec mycontainer "touch /tmp/execWorks")
          """ )
     :see-also '(
          "docker/ps"
          "docker/run" ) }

  exec [container command]

  (let [cmdargs* ["exec" "--detach" container command]]
   (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/rm container & options)")
     :doc """
          Remove a container.

          Options:

          | :force {true, false}   | Force the removal of a running container (uses SIGKILL) |
          | :link link             | Remove the specified link |
          | :volumes {true, false} | Remove anonymous volumes associated with the container |
          """
     :examples '(
          """
          (docker/rm "b19b498c670b")
          """ )
     :see-also '(
          "docker/prune"
          "docker/ps"
          "docker/run" ) }

  rm [container & options]

  (let [opts     (apply hash-map options)
        force    (:force opts false)
        link     (:link opts nil)
        volumes  (:volumes opts false)
        cmdargs* ["rm"]
        cmdargs* (if force (conj cmdargs* "--force") cmdargs*)
        cmdargs* (if volumes (conj cmdargs* "--volumes") cmdargs*)
        cmdargs* (if (some? link) (into cmdargs* ["--link" link]) cmdargs*)
        cmdargs* (conj cmdargs* "container")]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/prune)")
     :doc """
          Remove all stopped containers.
          """
     :examples '(
          """
          (docker/prune)
          """ )
     :see-also '(
          "docker/rm"
          "docker/ps"
          "docker/run" ) }

  prune []

  (let [cmdargs* ["prune" "--force"]]       ;; Do not prompt for confirmation
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/cp src-path dst-path & options)")
     :doc """
          Copy files/folders between a container and the local filesystem

          Options:

          | :archive {true, false}     | Archive mode (copy all uid/gid information) |
          | :follow-link {true, false} | Always follow symbol link in SRC_PATH|
          | :quiet {true, false}       | Suppress progress output during copy. Progress output is automatically suppressed if no terminal is attached |
          """
     :examples '(
          """
          ;; Copy file from host to docker container
          (docker/cp data.txt 74789744g489:/data.txt)
          """,
          """
          ;; Copy file from docker container to host
          (docker/cp 74789744g489:/data.txt data.txt)
          """,
          """
          ;; Copy a folder from host to docker container
          (docker/cp Desktop/images 74789744g489:/root/img_files/car_photos/images
          """,
          """
          ;; Copy a folder from docker container to host
          (docker/cp 74789744g489:/root/img_files/car_photos/images Desktop/images
          """ )
     :see-also '(
          "docker/diff"
          "docker/ps"
          "docker/run" ) }

  cp [src-path dst-path & options]

  (let [opts        (apply hash-map options)
        archive     (:archive opts false)
        follow-link (:follow-link  opts false)
        quiet       (:quiet opts false)
        cmdargs*    ["cp"]
        cmdargs*    (if archive (conj cmdargs* "--archive") cmdargs*)
        cmdargs*    (if follow-link (conj cmdargs* "--follow-link") cmdargs*)
        cmdargs*    (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs*    (into cmdargs* [src-path dst-path])]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/diff container & options)")
     :doc """
          Inspect changes to files or directories on a container's filesystem.

          Options:

          | :format {:string, :json} | Returns the output either as a string or as JSON data |
          """
     :examples '(
          """
          (println (docker/diff 74789744g489))
          """,
          """
          (docker/diff 74789744g489 :format :json)
          """ )
     :see-also '(
          "docker/cp"
          "docker/ps"
          "docker/run" ) }

  diff [container & options]

  (let [opts     (apply hash-map options)
        format   (:format opts :string)
        actions  {"A" :added, "C" :changed, "D" :deleted}
        cmdargs* ["diff" container]]
    (let [output (:out (apply docker/cmd cmdargs*))]
      (if (= format :json)
        (->> (str/split-lines output)
             (map #(str/split-at % 1))
             (map #(vector (get actions (first %)) (str/trim (second %)))))
        output))))


(defn
  ^{ :arglists '("(docker/pause container)")
     :doc """
          Pause all processes within a container
          """
     :examples '(
          """
          (docker/pause 74789744g489)
          """ )
     :see-also '(
          "docker/unpause"
          "docker/ps"
          "docker/run" ) }

  pause [container]

  (let [cmdargs* ["pause" container]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/unpause container)")
     :doc """
          Unpause all processes within a container
          """
     :examples '(
          """
          (docker/unpause 74789744g489)
          """ )
     :see-also '(
          "docker/pause"
          "docker/ps"
          "docker/run" ) }

  unpause [container-id]

  (let [cmdargs* ["unpause" container]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/wait & containers)")
     :doc """
          Block until one or more containers stop, then return their exit codes
          """
     :examples '(
          """
          (docker/wait 74789744g489)
          """ )
     :see-also '(
          "docker/ps"
          "docker/rm"
          "docker/run" ) }

  wait [&containers]

  (let [cmdargs* (into ["wait"] containers)]
    (:out (apply docker/cmd cmdargs*))))



;; -----------------------------------------------------------------------------
;; Volume functions
;;   - docker/volume-list
;;   - docker/volume-create
;;   - docker/volume-rm
;;   - docker/volume-exists?
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(docker/volume-list & options)")
     :doc """
          List all the volumes known to Docker.

          Options:

          | :quiet {true, false} | Only display volume names |
          | :format {:table, :json} | Returns the output either as a ascii table or as JSON data |
          """
     :examples '(
          """
          (docker/volume-list)
          """ )
     :see-also '(
          "docker/volume-create"
          "docker/volume-rm"
          "docker/volume-exists?"
          "docker/images"
          "docker/run" ) }

  volume-list [& options]

  (let [opts     (apply hash-map options)
        quiet    (:quiet opts false)
        format   (:format opts :json)
        cmdargs* ["volume" "ls"]
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (into cmdargs* ["--format" (name format)])]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output-list format))))


(defn
  ^{ :arglists '("(docker/volume-create name)")
     :doc """
          Create a volume.
          """
     :examples '(
          """
          (docker/volume-create "hello")
          """ )
     :see-also '(
          "docker/volume-list"
          "docker/volume-rm"
          "docker/volume-exists?" ) }

  volume-create [name]

  (->> (apply docker/cmd ["volume" "create" name])
       (:out)))


(defn
  ^{ :arglists '("(docker/volume-rm name)")
     :doc """
          Remove a volume.
          """
     :examples '(
          """
          (docker/volume-remove "hello")
          """ )
     :see-also '(
          "docker/volume-list"
          "docker/volume-create"
          "docker/volume-exists?" ) }

  volume-rm [name]

  (->> (apply docker/cmd ["volume" "rm" name])
       (:out)))


(defn
  ^{ :arglists '("(docker/volume-exists? name)")
     :doc """
          Returns true if the volume with the specified name exists.
          """
     :examples '(
          """
          (docker/volume-exists?  "hello")
          """ )
     :see-also '(
          "docker/volume-list" ) }

  volume-exists? [name]

  (->> (docker/volume-list ":format" ":json")
       (filter #(== name (get % "Name")))
       (count)
       (pos?)))




;; -----------------------------------------------------------------------------
;; Generic docker command
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(docker/cmd & args)")
     :doc """
          Runs any Docker command.
          """
     :examples '(
          """
          (println (docker/cmd "ps" "--all"))
          """,
          """
          ;; a single string argument works as well
          (println (docker/cmd "ps --all"))
          """,
          """
          ;; run a command with JSON output and parse the JSON output into
          ;; Venice data
          ;; use `apply` to apply a vector of arguments
          (-<> (apply docker/cmd ["ps" "--all" "--format" "json"])
               (:out <>)
               (str/split-lines <>)
               (str/join "," <>)
               (str "[" <> "]")
               (json/read-str <>))
          """ ) }

   cmd [& args]

   (let [cmd* (apply str "docker " (interpose " " args))]
     (case docker/*debug*
       :off          ((docker/os-exec) cmd* :throw-ex true)
       :on           (do
                       (println "DEBUG (no exec):"  cmd*)
                       ((docker/os-exec) cmd* :throw-ex true))
       :on-no-exec   (println "DEBUG:"  cmd*)
       :else)))



;; -----------------------------------------------------------------------------
;; Utility functions
;;   - docker/container-find-by-name
;;   - docker/container-exists-with-name?
;;   - docker/container-running-with-name?
;;   - docker/container-start-by-name
;;   - docker/container-stop-by-name
;;   - docker/container-status-by-name
;;   - docker/container-exec-by-name
;; -----------------------------------------------------------------------------

(defn
  ^{ :arglists '("(docker/container-find-by-name name)")
     :doc """
          Find all containers with a specified name
          """
     :examples '(
          """
          (docker/container-find-by-name "myapp")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-exists-with-name?"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  container-find-by-name [name]

  (->> (docker/ps :all true :format :json)
       (filter #(== name (get % "Names")))))

(defn
  ^{ :arglists '("(docker/container-exists-with-name? name)")
     :doc """
          Returns true if there is container with the specified name else false.
          """
     :examples '(
          """
          (docker/container-exists-with-name? "myapp")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-find-by-name"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  container-exists-with-name? [name]

  (pos? (count (container-find-by-name name))))


(defn
  ^{ :arglists '("(docker/container-running-with-name? name)")
     :doc """
          Checks if there is container with the specified name in 'running'
          state.

          Returns true if running else false.
          """
     :examples '(
          """
          (docker/container-running-with-name? "myapp")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-find-by-name"
          "docker/container-exists-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  container-running-with-name? [name]

  (->> (docker/ps :all true :format :json)
       (filter #(== name (get % "Names")))
       (filter #(== "running" (get % "State")))))


(defn
  ^{ :arglists '("(docker/container-start-by-name name)")
     :doc """
          Starts a container with the specified name.
          """
     :examples '(
          """
          (docker/container-start-by-name "myapp")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-find-by-name"
          "docker/container-exists-with-name?"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  container-start-by-name [name]

  (let [container (first (container-find-by-name name))
        id        (get container "ID")
        status    (get container "State")]
    (assert (some? container)
            "There is no container with the name \"~{name}\" available!")
    (assert (not= status "running")
            "There is already a container running with the name \"~{name}\"!")

    (start id)))


(defn
  ^{ :arglists '(
          "(docker/container-stop-by-name name)"
          "(docker/container-stop-by-name name time)")
     :doc """
          Stops a container with the specified name.
          """
     :examples '(
          """
          (docker/container-stop-by-name "myapp")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-find-by-name"
          "docker/container-exists-with-name?"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-status-by-name"
          "docker/container-exec-by-name" ) }

  container-stop-by-name

  ([name]
    (let [container (first (container-find-by-name name))
          id        (get container "ID")
          status    (get container "State")]
      (assert (= status "running")
              "There is no container running with the name \"~{name}\"!")
      (stop id)))

  ([name time]
    (let [container (first (container-find-by-name name))
          id        (get container "ID")
          status    (get container "State")]
      (assert (= status "running")
              "There is no container running with the name \"~{name}\"!")
      (stop id :time time))))


(defn
  ^{ :arglists '("(docker/container-status-by-name name)")
     :doc """
          Returns the status of container with the specified name.
          """
     :examples '(
          """
          (docker/container-status-by-name  "myapp")
          """ )
     :see-also '(
       "docker/run"
       "docker/container-find-by-name"
       "docker/container-exists-with-name?"
       "docker/container-running-with-name?"
       "docker/container-start-by-name"
       "docker/container-stop-by-name"
       "docker/container-exec-by-name" ) }

  container-status-by-name  [name]

  (-<> (container-find-by-name name)
       (first <>)
       (get <> "State" "unavailable")))


(defn
  ^{ :arglists '("(docker/container-exec-by-name name command)")
     :doc """
          Execute a command in the running container with the specified name.
          """
     :examples '(
          """
          (docker/container-exec-by-name  "myapp" "touch /tmp/execWorks")
          """ )
     :see-also '(
          "docker/run"
          "docker/container-find-by-name"
          "docker/container-exists-with-name?"
          "docker/container-running-with-name?"
          "docker/container-start-by-name"
          "docker/container-stop-by-name"
          "docker/container-status-by-name" ) }

  container-exec-by-name  [name]

  (let [container (first (container-find-by-name name))
        status    (get container "State")]
    (assert (= status "running")
            "There is no container running with the name \"~{name}\"!")
    (exec c command)))



;; -----------------------------------------------------------------------------
;; Private helpers
;; -----------------------------------------------------------------------------

(defn- parse-output-object [format output]
  (if (= format :json)
    (json/read-str output)
    output))


(defn- parse-output-list [format output]
  (if (= format :json)
    (as-> output $
          (str/split-lines $)      ;; docker you're kidding
          (str/join "," $)
          (str "[" $ "]")
          (json/read-str $))
    output))


(defn- os-exec []
  (case (os-type)
    :mac-osx (partial sh "/bin/sh" "-c")
    :linux   (partial sh "/bin/sh" "-c")
    :windows (partial sh "cmd" "/C")))
