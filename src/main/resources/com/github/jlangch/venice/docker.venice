;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2023 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Docker utilities

;;;; See:  https://docs.docker.com/engine/reference/commandline/


(ns docker)


(defonce debug-modes #{:off :on :on-no-exec})

(def-dynamic *debug* :off)


(defn
  ^{ :arglists '("(docker/debug mode)")
     :doc """
          Sets the debugging mode.

          Without argument returns the current debug mode.

          Mode:

          | :off        | No debug output |
          | :on         | Prints the raw docker command line to the current stdout channel ahead of running the command |
          | :on-no-exec | Prints the raw docker command line to the current stdout channel without running the command |
          """
     :examples '(
          "(docker/debug :on)"
          "(docker/debug :on-no-exec)"
          "(docker/debug :off)") }

  debug

  ([] docker/*debug*)

  ([mode]
    (assert (contains? debug-modes mode)
            "A debug mode must be one of {:off, :on, :on-no-exec}")
    (set! docker/*debug* mode)))


(defn
  ^{ :arglists '("(docker/version & options)")
     :doc """
          Returns the Docker version.

          Options:

          | :format {:pretty, :json} | Returns the output either as a pretty printed string or as JSON data |
          """
     :examples '(
          "(docker/version)"
          "(docker/version :format :json)"
          "(println (docker/version :format :pretty))" )
     :see-also '("docker/images" "docker/ps")}

  version [& options]

  (let [opts     (apply hash-map options)
        format   (:format opts :json)
        cmdargs* ["version" "--format" (name format)]]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output format))))


(defn
  ^{ :arglists '("(docker/images & options)")
     :doc """
          List images.

          Options:

          | :all {true, false}      | Show all images (default hides intermediate images) |
          | :digests {true, false}  | Show digests |
          | :quiet {true, false}    | If true only display image IDs |
          | :no-trunc {true, false} | Don't truncate output |
          | :format {:table, :json} | Returns the output either as a table string or as JSON data |
          """
     :examples '(
          "(println (docker/images :format :table))"
          "(docker/images :quiet true :no-trunc true :format :json)"
          "(println (docker/images :format :json))" )
     :see-also '("docker/image-remove" "docker/image-prune") }

  images [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)      ;; (if all "--all" nil)  ;; hangs on MacOSX
        digests  (:digests opts false)
        quiet    (:quiet opts false)
        no-trunc (:no-trunc opts false)
        format   (:format opts :json)
        cmdargs* ["images"]
        cmdargs* (if digests (conj cmdargs* "--digests") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if no-trunc (conj cmdargs* "--no-trunc") cmdargs*)
        cmdargs* (into cmdargs* ["--format" (name format)])]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output format))))


(defn
  ^{ :arglists '("(docker/image-remove id)")
     :doc """
          Remove an image given by its image id.
          """
     :examples '(
          """(docker/image-rm "28e52b5cecd8")""" )
     :see-also '("docker/images" "docker/image-prune") }

  image-remove [id]

  (let [cmdargs* ["image" "rm" id]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/image-prune & options)")
     :doc """
          Remove unused images.

          Options:

          | :all {true, false}      | Remove all unused images, not just dangling ones |
          """
     :examples '(
          "(println (docker/images :format :table))"
          "(docker/images :quiet true :format :json)"
          "(println (docker/images :format :json))" )
     :see-also '("docker/images" "docker/image-remove") }

  image-prune [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)
        cmdargs* ["image" "prune" "--force"]  ;; Do not prompt for confirmation
        cmdargs* (if all (conj cmdargs* "--all") cmdargs*)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/image-pull image-tag-or-digest & options)")
     :doc """
          Download an image from a registry.

          Options:

          | :quiet {true, false} | Suppress verbose output |
          """
     :examples '(
          """
          (docker/image-pull "arangodb/arangodb:3.10.10")
          """ )
     :see-also '("docker/images" "docker/image-remove") }

  image-pull [image-tag-or-digest & options]

  (let [opts     (apply hash-map options)
        quiet    (:quiet opts false)
        cmdargs* ["image" "pull" ]
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (conj cmdargs* image-tag-or-digest)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/run image-tag-or-id & options)")
     :doc """
          Create and run a new container from an image.

          Options:

          | :detach {true, false}   | Run container in background and return container ID |
          | :publish port           | Publish a container's port(s) to the host |
          | :envs vars              | Set environment variable (a sequence of env var defs) |
          | :memory limit           | Memory limit |
          | :name name              | Assign a name to the container |
          | :quiet {true, false}    | Suppress the pull output |
          | :volumes vol            | Bind mount a volume (a sequence of volume defs)|
          | :workdir dir            | Working directory inside the container |
          | :args arg               | Argument passed to container process (a sequence of args) |
          """
     :examples '(
          """
          ;; Run an ArangoDB container
          (docker/run "arangodb/arangodb:3.10.10"
                      :publish "8529:8529"
                      :detach true
                      :envs ["ARANGO_ROOT_PASSWORD=xxxxxx"
                             "ARANGODB_OVERRIDE_DETECTED_TOTAL_MEMORY=8G"
                             "ARANGODB_OVERRIDE_DETECTED_NUMBER_OF_CORES=1"])
          """,
          """
          ;; Run an ArangoDB container
          (docker/run "arangodb/arangodb:3.10.10"
                      :publish "8529:8529"
                      :detach true
                      :envs ["ARANGO_ROOT_PASSWORD=xxxxxx"
                             "ARANGODB_OVERRIDE_DETECTED_TOTAL_MEMORY=8G"
                             "ARANGODB_OVERRIDE_DETECTED_NUMBER_OF_CORES=1"]
                      :args ["--database.auto-upgrade"])
          """
          )
     :see-also '("docker/start" "docker/stop" "docker/cp") }

  run [image-tag-or-id & options]

  (let [opts     (apply hash-map options)
        detach   (:detach opts false)
        publish  (:publish opts nil)
        envs     (:envs opts [])
        memory   (:memory opts 0)
        name     (:name opts nil)
        quiet    (:quiet opts false)
        volumes  (:volumes opts [])
        workdir  (:workdir opts nil)
        args     (:args opts [])
        cmdargs* ["run"]
        cmdargs* (if detach (conj cmdargs* "--detach") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if (some? publish) (conj cmdargs* "--publish" publish) cmdargs*)
        cmdargs* (if (pos? memory) (conj cmdargs* "--memory" memory) cmdargs*)
        cmdargs* (if (some? name) (conj cmdargs* "--name" name) cmdargs*)
        cmdargs* (if (some? workdir) (conj cmdargs* "--workdir" workdir) cmdargs*)
        cmdargs* (if (and (some? volumes) (vector? volumes))
                   (into cmdargs* (interleave (lazy-seq (constantly "--volume")) volumes))
                   cmdargs*)
        cmdargs* (if (and (some? envs) (vector? envs))
                   (into cmdargs* (interleave (lazy-seq (constantly "--env")) envs))
                   cmdargs*)
        cmdargs* (conj cmdargs* image-tag-or-id)
        cmdargs* (if (and (some? args) (vector? args)) (into cmdargs* args) cmdargs*)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/ps & options)")
     :doc """
          List containers.

          Options:

          | :all {true, false}      | Show all containers (default shows just running) |
          | :last n                 | Show n last created containers |
          | :quiet {true, false}    | If true only display container IDs |
          | :no-trunc {true, false} | Don't truncate output |
          | :format {:table, :json} | Returns the output either as a table string or as JSON data |
          """
     :examples '(
          "(println (docker/ps :format :table))"
          "(docker/ps :all true :format :json)"
          "(docker/ps :all true :no-trunc true :format :json)"
          "(docker/ps :all true :no-trunc true :last 3 :format :json)"
          "(println (docker/ps :all true :format :json))" )
     :see-also '("docker/start" "docker/stop" "docker/cp") }

  ps [& options]

  (let [opts     (apply hash-map options)
        all      (:all opts false)
        lastn    (:last opts -1)
        quiet    (:quiet opts false)
        no-trunc (:no-trunc opts false)
        format   (:format opts :json)
        cmdargs* ["ps"]
        cmdargs* (if all (conj cmdargs* "--all") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs* (if quiet (conj cmdargs* "--no-trunc") cmdargs*)
        cmdargs* (into cmdargs* ["--last" lastn])
        cmdargs* (into cmdargs* ["--format" (name format)])]
    (->> (apply docker/cmd cmdargs*)
         (:out)
         (parse-output format))))


(defn
  ^{ :arglists '("(docker/start id & options)")
     :doc """
          Start a stopped container given by its container id.

          Options:

          | :attach {true, false} | Attach STDOUT/STDERR and forward signals |
          """
     :examples '(
          """(docker/start id "b19b498c670b")""" )
     :see-also '("docker/stop" "docker/ps") }

  start [id & options]

  (let [opts     (apply hash-map options)
        attach   (:attach opts false)
        cmdargs* ["start"]
        cmdargs* (if attach (conj cmdargs* "--attach") cmdargs*)
        cmdargs* (conj cmdargs* id)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/stop id & options)")
     :doc """
          Stop a container given by its container id.

          Options:

          | :signal name | Signal to send to the container |
          | :time n      | Seconds to wait before killing the container |
          """
     :examples '(
          """(docker/stop id "b19b498c670b" :time 30)""" )
     :see-also '("docker/start" "docker/ps") }

  stop [id & options]

  (let [opts     (apply hash-map options)
        signal   (:signal opts nil)
        time     (:time opts 0)
        cmdargs* ["stop"]
        cmdargs* (if (and (some? signal) (string? signal))
                   (into cmdargs* ["--signal" signal])
                   cmdargs*)
        cmdargs* (if (and (number? time) (pos? time))
                   (into cmdargs* ["--time" time])
                   cmdargs*)
        cmdargs* (conj cmdargs* id)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/cp src-path dst-path & options)")
     :doc """
          Copy files/folders between a container and the local filesystem

          Options:

          | :archive {true, false}     | Archive mode (copy all uid/gid information) |
          | :follow-link {true, false} | Always follow symbol link in SRC_PATH|
          | :quiet {true, false}       | Suppress progress output during copy. Progress output is automatically suppressed if no terminal is attached |
          """
     :examples '(
          """
          ;; Copy file from host to docker container
          (docker cp data.txt 74789744g489:/data.txt)
          """,
          """
          ;; Copy file from docker container to host
          (docker cp 74789744g489:/data.txt data.txt)
          """,
          """
          ;; Copy a folder from host to docker container
          (docker cp Desktop/images 74789744g489:/root/img_files/car_photos/images
          """,
          """
          ;; Copy a folder from docker container to host
          (docker cp 74789744g489:/root/img_files/car_photos/images Desktop/images
          """ )
     :see-also '("docker/ps") }

  cp [src-path dst-path & options]

  (let [opts        (apply hash-map options)
        archive     (:archive opts false)
        follow-link (:follow-link  opts false)
        quiet       (:quiet opts false)
        cmdargs*    ["cp"]
        cmdargs*    (if archive (conj cmdargs* "--archive") cmdargs*)
        cmdargs*    (if follow-link (conj cmdargs* "--follow-link") cmdargs*)
        cmdargs*    (if quiet (conj cmdargs* "--quiet") cmdargs*)
        cmdargs*    (into cmdargs* [src-path dst-path])]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/diff container-id & options)")
     :doc """
          Inspect changes to files or directories on a container's filesystem.

          Options:

          | :format {:string, :json} | Returns the output either as a string or as JSON data |
          """
     :examples '(
          """
          (println (docker diff 74789744g489))
          """,
          """
          (docker diff 74789744g489 :format :json)
          """ )
     :see-also '("docker/ps") }

  diff [container-id & options]

  (let [opts     (apply hash-map options)
        format   (:format opts :string)
        actions  {"A" :added, "C" :changed, "D" :deleted}
        cmdargs* ["diff" container-id]]
    (let [output (:out (apply docker/cmd cmdargs*))]
      (if (= format :json)
        (->> (str/split-lines output)
             (map #(str/split-at % 1))
             (map #(vector (get actions (first %)) (str/trim (second %)))))
        output))))


(defn
  ^{ :arglists '("(docker/pause container-id)")
     :doc """
          Pause all processes within a container
          """
     :examples '(
          """
          (docker pause 74789744g489)
          """ )
     :see-also '("docker/ps") }

  pause [container-id]

  (let [cmdargs* ["pause" container-id]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/unpause container-id)")
     :doc """
          Unpause all processes within a container
          """
     :examples '(
          """
          (docker unpause 74789744g489)
          """ )
     :see-also '("docker/ps") }

  unpause [container-id]

  (let [cmdargs* ["unpause" container-id]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/wait &container-ids)")
     :doc """
          Block until one or more containers stop, then return their exit codes
          """
     :examples '(
          """
          (docker wait 74789744g489)
          """ )
     :see-also '("docker/ps") }

  wait [&container-ids]

  (let [cmdargs* (into ["wait"] container-ids)]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/volumes-list)")
     :doc """
          List all the volumes known to Docker.
          """
     :examples '(
          """
          (docker/volumes-list)
          """ )
     :see-also '("docker/ps") }

  volumes-list []

  (let [cmdargs* ["volumes" "list"]]
    (:out (apply docker/cmd cmdargs*))))


(defn
  ^{ :arglists '("(docker/cmd & args)")
     :doc """
          Runs any Docker command.
          """
     :examples '(
          """
          (println (docker/cmd "version" "--format" "string"))
          """,
          """
          (println (docker/cmd "version --format string"))
          """,
          """
          (println (docker/cmd "version" "--format" "json"))
          """,
          """
          ;; run a command with JSON output and parse the JSON output into
          ;; Venice data
          (-<> (apply docker/cmd ["ps" "--all" "--format" "json"])
               (:out <>)
               (json/read-str (str "[" <> "]")))
          """ ) }

   cmd [& args]

   (let [cmd* (apply str "docker " (interpose " " args))]
     (case docker/*debug*
       :off          ((docker/exec) cmd* :throw-ex true)
       :on           (do
                       (println "DEBUG (no exec):"  cmd*)
                       ((docker/exec) cmd* :throw-ex true))
       :on-no-exec   (println "DEBUG:"  cmd*)
       :else)))


(defn- parse-output [format output]
  (if (= format :json)
    (-<> (str/split-lines output)            ;; docker you're kidding
         (str/join "," <>)
         (str "[" <> "]")
         (json/read-str <>))
    output))


(defn- exec []
  (case (os-type)
    :mac-osx (partial sh "/bin/sh" "-c")
    :linux   (partial sh "/bin/sh" "-c")
    :windows (partial sh "cmd" "/C")))
