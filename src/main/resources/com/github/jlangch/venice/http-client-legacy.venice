;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; HTTP legacy client based on the JDK HttpUrlConnection


(ns http-client-legacy)

(import :java.net.URL)
(import :java.net.HttpURLConnection)
(import :java.net.HttpsURLConnection)

(defonce ^:private hc-user-agent "Venice HTTP client (legacy)")


(defn
  ^{ :arglists '("(send method uri & options)")
     :doc """
          Send a request

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value (comma separated): ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" "value1, value2, value3"]} |
          | :body              | An optional body to send with the request¶ \
                                 The body may be of type *string*, *bytebuf*, \
                                 `:java.io.InputStream` |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type      | The content type |
          | :content-encoding  | The content encoding (a keyword), if available else nil |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """ 
     :examples '(
          """
          ;; GET (get)
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers { "Accept" "application/json, text/plain" }
                                    :debug true)
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """,
          """
          ;; POST (create)
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
            
            (let [res      (hc/send :post 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "name" "hanna", 
                                                            "role" "secretary" })
                                    :debug true)
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """,
          """
          ;; PUT (update)
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
            
            (let [res      (hc/send :put 
                                    "http://localhost:8080/employees/1001" 
                                    :headers {"Accept"       "application/json, text/plain"
                                              "Content-Type" "application/json"}
                                    :body (json/write-str { "id"   "1001", 
                                                            "name" "john", 
                                                            "role" "clerk" })
                                    :debug true)
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """,
          """
          ;; DELETE (delete)
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
            
            (let [res      (hc/send :delete 
                                    "http://localhost:8080/employees/1000" 
                                    :headers { "Accept" "text/plain" }
                                    :debug true)
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (= "text/plain" type)
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-json"
          "http-client-legacy/slurp-bytebuf" ) }

  send [method uri & options]
  
  (let [opts               (apply hash-map options)
        method             (str/upper-case (name method))
        headers            (:headers opts {})
        body               (:body opts)
        conn-timeout       (:conn-timeout opts)
        read-timeout       (:read-timeout opts)
        follow-redirects   (:follow-redirects opts)
        hostname-verifier  (:hostname-verifier opts)
        ssl-socket-factory (:ssl-socket-factory opts)
        user-agent         (:user-agent opts hc-user-agent)
        debug?             (true? (:debug opts false))
                            ;; default headers
        headers            (assoc headers "User-Agent" user-agent)
        headers            (if (not-contains? headers "Accept")
                              (assoc headers "Accept" "text/plain, */*;0.2")
                              headers)]

    (assert (string? method))
    (assert (string? uri))
    (assert (or (map? headers)))
    (assert (or (nil? body) (string? body) (bytebuf? body) (io/in-stream? body)))
    (assert (or (nil? conn-timeout) (long? conn-timeout)))
    (assert (or (nil? read-timeout) (long? read-timeout)))
    (assert (or (nil? follow-redirects) (boolean? follow-redirects)))

    (let [https?          (str/starts-with? (str/lower-case uri) "https:")
          [type encoding] (parse-content-type (get headers "Content-Type"))
          url             (. :URL :new uri)
          con             (. url :openConnection)
          con             (if https? (cast :HttpsURLConnection con)
                                     (cast :HttpURLConnection con))]
      (. con :setRequestMethod method)

      (when https?
        (when (some? hostname-verifier)
          (. con :setHostnameVerifier hostname-verifier))
        (when (some? ssl-socket-factory)
          (. con :setSSLSocketFactory ssl-socket-factory)))

      (when (some? conn-timeout)
        (. con :setConnectTimeout conn-timeout))

      (when (some? read-timeout)
        (. con :setReadTimeout read-timeout))

      (doseq [[k v] headers] 
        (. con :setRequestProperty k (str v)))

      (when (some? follow-redirects)
        (. con :setInstanceFollowRedirects follow-redirects))
      
      (when (some? body)
        (. con :setDoOutput true))

      (. con :connect)  ;; establish the connection

      ;; send body, if we got one
      (when (some? body)
        (let [os (. con :getOutputStream)]
          (cond 
            (string? body)        (spit-string body encoding os debug?)                 
            (bytebuf? body)       (spit-bytebuf body os debug?)
            (io/in-stream? body)  (spit-bytebuf (io/slurp-stream is) os debug?)
            :else                 (throw (ex :VncException 
                                            (str "Invalid " method 
                                                  " request body type"))))))

      ;; handle response
      (let [response  (get-response con)]
        (when debug? (dump-response response))
        response))))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
         "(slurp-string is)"
         "(slurp-string is charset)")
     :doc """
          Slurps the input stream with response data into a string. Defaults to 
          :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (= 200 status)
                (println (hc/slurp-string (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-json"
          "http-client-legacy/slurp-bytebuf"
          "http-client-legacy/send" ) }

  slurp-string 
  
  ([is] (slurp-string is :utf-8))
  ([is charset] (io/slurp-stream is :binary false :encoding (or charset :utf-8))))


(defn 
  ^{ :arglists '(
         "(slurp-json is)"
         "(slurp-json is charset)")
     :doc """
          Slurps the input stream with response data into JSON. Defaults to 
          :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get 
                                    "http://localhost:8080/employees" 
                                    :headers {"Accept" "application/json, text/plain"})
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-bytebuf"
          "http-client-legacy/send" ) }

  slurp-json

  ([is] (slurp-json is :utf-8))
  ([is charset] (-> (io/slurp-stream is :binary false 
                                        :encoding (or charset :utf-8))
                    (json/pretty-print))))


(defn 
 ^{ :arglists '(
         "(slurp-bytebuf is)")
     :doc """
          Slurps the input stream with response data into a bytebuf.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res    (hc/send :get 
                                  "http://localhost:8080/employees" 
                                  :headers {"Accept" "application/json, text/plain"})
                  status (:http-status res)]
              (println "Status:" status)
              (let [data (hc/slurp-bytebuf (:data-stream res))]
                (println "Bytes read:" (count data)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-json"
          "http-client-legacy/send" ) }

  slurp-bytebuf [is]

  (io/slurp-stream is :binary true))



;; -----------------------------------------------------------------------------
;; Helpers
;; -----------------------------------------------------------------------------

(defn- get-response [con]
  (let [status           (long (. con :getResponseCode))
        ok?              (<= 200 status 299)
        headers          (response-headers con)
        [type encoding]  (parse-content-type (get headers "Content-Type"))]
    { :http-status      status 
      :content-type     type
      :content-encoding encoding
      :content-length   (. con :getContentLengthLong)
      :headers          headers 
      :data-stream      (if ok? (. con :getInputStream) 
                                (. con :getErrorStream)) } ))


(defn- parse-content-type [content-type]
   ;; "application/json"                     => ["application/json" ":utf-8"]
   ;; "application/json; charset=iso-8859-1" => ["application/json" ":iso-8859-1"]
  (let [[t e]  (as-> (str/trim-to-nil content-type) v
                     (str/split v ";")
                     (map str/trim v))
               ;; default to :utf-8 and strip "charset=" prefix
        e      (keyword (str/strip-start (or e "utf-8") "charset="))] 
    [t e]))


(defn- response-headers [con]
  (->> (. con :getHeaderFields)
       (map-vals #(str/join ", " %))))  ;; just single values


(defn- spit-string [str encoding os debug?]
  (when debug? (printf "Sending string body. size %s, encoding :%s%n" 
                       (count str) 
                       (name encoding)))
  (try-with [pr (io/wrap-os-with-print-writer os encoding)]
    (print pr str)
    (flush pr)))


(defn- spit-bytebuf [buf os debug?]
  (when debug? (printf "Sending byte body. size %s%n"  (count buf)))
  (try-with [os os]
    (io/spit-stream os buf :flush true)))


(defn- dump-response [res]
  (println     "Dump response:")
  (println     "   http-status:       " (:http-status res))
  (println     "   content-type:      " (:content-type res))
  (println     "   content-encoding:  " (:content-encoding res))
  (println     "   content-length:    " (:content-length res))
  (println-map "   headers:           " (:headers res)))


(defn- println-map [head data]
  (if (or (nil? data) (empty? data))
    (println head "-")
    (let [indent  (str/repeat " " (count head))
          tuples  (into '() data)
          format  (fn [tuple] (str (first tuple) ": " (second tuple)))]
      (println head (format (first tuples)))
      (doseq [t (rest tuples)] (println indent (format t))))))
