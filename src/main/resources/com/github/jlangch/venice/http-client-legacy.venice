;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; HTTP legacy client based on the JDK HttpUrlConnection


(ns http-client-legacy)

(import :java.net.URL)
(import :java.net.HttpURLConnection)
(import :java.net.HttpsURLConnection)

(defonce ^:private hc-user-agent "Venice HTTP client (legacy)")


(defn
  ^{ :arglists '("(send method uri & options)")
     :doc """
          Send a request

          ¶¶*Request Options:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :headers           | A map of request headers. Headers can be single- \
                                 or multi-value: ¶\
                                 {"X-Header-1" "value1" ¶ \
                                  "X-Header-2" ["value1" "value2"  "value3"]} |
          | :body              | An optional body to send with the request¶ \
                                 The body may be of type *string*, *bytebuf*, \
                                 `:java.io.InputStream` |
          | :body-encoding     | If the body is a string the encoding for the \
                                 encoding can be specified. The charset is a \
                                 keyword {:utf-8, :iso-8859-1, ...}. \
                                 Defaults to :utf-8 |
          | :conn-timeout      | An optional connection timeout in milliseconds |
          | :read-timeout      | An optional read timeout in milliseconds |
          | :follow-redirects  | Sets whether HTTP redirects (requests with \
                                 response code 3xx) should be automatically \
                                 followed. |
          | :hostname-verifier | Sets the hostname verifier. An object of type \
                                 `:javax.net.ssl.HostnameVerifier`. ¶\
                                 Use only for HTTPS requests |
          | :ssl-socket-factory | Sets the SSL socket factory. An object of type \
                                 `:javax.net.ssl.SSLSocketFactory`. ¶\
                                 Use only for HTTPS requests |
          | :user-agent         | User agent. Defaults to "Venice HTTP client (legacy)" |
          | :debug              | Debug true/false. Defaults to false |

          ¶¶*Returns a map with the response fields:*

          | [![width: 20%]]    | [![width: 80%]] |
          | :http-status       | The HTTP status (a long) |
          | :content-type      | The content type |
          | :content-encoding  | The content encoding (a keyword), if available else nil |
          | :content-length    | The content length (a long), if available else -1 |
          | :headers           | A map of headers. key: header name, value: list \
                                 of header values |
          | :data-stream       | The response data input stream |
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get "http://localhost:8080/employees" 
                                    :headers {"Accept" ["application/json" "text/plain"]})
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-json"
          "http-client-legacy/slurp-bytebuf" ) }

  send [method uri & options]
  
  (try
    (let [opts               (apply hash-map options)
          method             (str/upper-case (name method))
          headers            (:headers opts {})
          body               (:body opts)
          body-encoding      (:body-encoding opts)
          conn-timeout       (:conn-timeout opts)
          read-timeout       (:read-timeout opts)
          follow-redirects   (:follow-redirects opts)
          hostname-verifier  (:hostname-verifier opts)
          ssl-socket-factory (:ssl-socket-factory opts)
          user-agent         (:user-agent opts hc-user-agent)
          debug?             (true? (:debug opts false))
                             ;; default headers
          headers            (assoc headers "User-Agent" user-agent)
          headers            (if (not-contains? headers "Accept")
                               (assoc headers "Accept" "*/*")
                               headers)]

      (assert (string? method))
      (assert (string? uri))
      (assert (or (map? headers)))
      (assert (or (nil? body) (string? str) (bytebuf? body) (io/in-stream? body)))
      (assert (or (nil? body-encoding) (keyword? body-encoding)))
      (assert (or (nil? conn-timeout) (long? conn-timeout)))
      (assert (or (nil? read-timeout) (long? read-timeout)))
      (assert (or (nil? follow-redirects) (boolean? follow-redirects)))

      (let [https? (str/starts-with? (str/lower-case uri) "https:")
            url    (. :URL :new uri)
            con    (. url :openConnection)
            con    (if https? (cast :HttpsURLConnection con)
                              (cast :HttpURLConnection con))]

        (. con :setRequestMethod method)

        (when https?
          (when (some? hostname-verifier)
            (. con :setHostnameVerifier hostname-verifier))
          (when (some? ssl-socket-factory)
            (. con :setSSLSocketFactory ssl-socket-factory)))

        (when (some? conn-timeout)
          (. con :setConnectTimeout conn-timeout))

        (when (some? read-timeout)
          (. con :setReadTimeout read-timeout))

        (doseq [[k v] headers] 
          (if (sequential? v)
            (doseq [i v] (. con :setRequestProperty k (str i)))  ; multi-value
            (. con :setRequestProperty k (str v))))              ; single-value

        (when (some? follow-redirects)
          (. con :setInstanceFollowRedirects follow-redirects))
        
        (when (some? body)
          (. con :setDoOutput true))

         (. con :connect)  ;; establish the connection

        ;; send body
        (when (some? body)
          (let [os (. con :getOutputStream)]
            (cond 
              (string? body)        (spit-string body encoding os)                 
              (bytebuf? body)       (spit-bytebuf body os)
              (io/in-stream? body)  (spit-bytebuf (io/slurp-stream is) os)
              :else                 (throw (ex :VncException 
                                              (str "Invalid " method 
                                                    " request body type"))))))

        ;; handle response
        (let [response  (get-response con)]
          (when debug? (dump-response response))
          response)))

  (catch :Exception e (throw (ex :VncException (ex-message e) e)))))



;; -----------------------------------------------------------------------------
;; Utils
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
         "(slurp-string is)"
         "(slurp-string is charset)")
     :doc """
          Slurps the input stream with response data into a string. Defaults to 
          :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get "http://localhost:8080/employees" 
                                    :headers {"Accept" ["application/json" "text/plain"]})
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (= 200 status)
                (println (hc/slurp-string (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-json"
          "http-client-legacy/slurp-bytebuf"
          "http-client-legacy/send" ) }

  slurp-string 
  
  ([is] (slurp-string is :utf-8))
  ([is charset] (io/slurp-stream is :binary false :encoding (or charset :utf-8))))


(defn 
  ^{ :arglists '(
         "(slurp-json is)"
         "(slurp-json is charset)")
     :doc """
          Slurps the input stream with response data into JSON. Defaults to 
          :utf-8 charset.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res      (hc/send :get "http://localhost:8080/employees" 
                                    :headers {"Accept" ["application/json" "text/plain"]})
                  status   (:http-status res)
                  type     (:content-type res)
                  encoding (:content-encoding res)]
              (println "Status:" status)
              (if (and (= 200 status) (= "application/json" type))
                (println (hc/slurp-json (:data-stream res) encoding))
                (println (hc/slurp-string (:data-stream res) encoding)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-bytebuf"
          "http-client-legacy/send" ) }

  slurp-json

  ([is] (slurp-json is :utf-8))
  ([is charset] (-> (io/slurp-stream is :binary false 
                                        :encoding (or charset :utf-8))
                    (json/pretty-print))))


(defn 
 ^{ :arglists '(
         "(slurp-bytebuf is)")
     :doc """
          Slurps the input stream with response data into a bytebuf.
          """ 
     :examples '(
          """
          (do
            (load-module :http-client-legacy ['http-client-legacy :as 'hc])
          
            (let [res    (hc/send :get "http://localhost:8080/employees" 
                                  :headers {"Accept" ["application/json" "text/plain"]})
                  status (:http-status res)]
              (println "Status:" status)
              (let [data (hc/slurp-bytebuf (:data-stream res))]
                (println "Bytes read:" (count data)))))
          """ )
     :see-also '(
          "http-client-legacy/slurp-string"
          "http-client-legacy/slurp-json"
          "http-client-legacy/send" ) }

  slurp-bytebuf [is]

  (io/slurp-stream is :binary true))



;; -----------------------------------------------------------------------------
;; Helpers
;; -----------------------------------------------------------------------------

(defn- get-response [con]
  (let [http-status          (long (. con :getResponseCode))
        ok?                  (<= 200 http-status 299)
        headers              (response-headers con)
        content-type-details (->> (get headers "Content-Type")
                                  (first)
                                  (parse-content-type))
        type                 (first content-type-details)
        encoding             (-> (second content-type-details)
                                 (str/strip-start "charset="))]
    { :http-status      http-status 
      :content-type     type
      :content-encoding (if (nil? encoding) nil (keyword encoding))
      :content-length   (. con :getContentLengthLong)
      :headers          headers 
      :data-stream      (if ok? (. con :getInputStream) 
                                (. con :getErrorStream)) } ))


(defn- parse-content-type [ct]
  (let [e  (as-> (str/trim-to-nil ct) v
                 (str/split v ";")
                 (map str/trim v))]
    [(first e) (second e)]))


(defn- response-headers [con]
  (->> (. con :getHeaderFields)
       (map-vals #(into '() %))))


(defn- spit-string [str charset os]
  (try-with [pr (io/wrap-os-with-print-writer os charset)]
    (print pr str)
    (flush pr)))


(defn- spit-bytebuf [buf os]
  (try-with [os os]
    (io/spit-stream os buf :flush true)))


(defn- dump-response [res]
  (println     "Dump response:")
  (println     "   http-status:       " (:http-status res))
  (println     "   content-type:      " (:content-type res))
  (println     "   content-encoding:  " (:content-encoding res))
  (println     "   content-length:    " (:content-length res))
  (println-map "   headers:           " (:headers res)))


(defn- println-map [head data]
  (if (or (nil? data) (empty? data))
    (println head "-")
    (let [indent  (str/repeat " " (count head))
          tuples  (into '() data)
          format  (fn [tuple] 
                    (let [name   (first tuple)
                          values (second tuple)
                          values (if (sequential? values)
                                   (str/join ", " values)
                                   values)]
                      (str name ": " values)))]
      (println head (format (first tuples)))
      (doseq [t (rest tuples)] (println indent (format t))))))
