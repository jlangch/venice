;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; JDBC core utils

;;;; See: 
;;;; https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html


(ns jdbc-core)

(load-module :ascii-table)


(import :java.sql.DriverManager)
(import :java.sql.Connection)
(import :java.sql.Statement)
(import :java.sql.PreparedStatement)
(import :java.sql.Types)



;; -----------------------------------------------------------------------------
;; Create / Drop database
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(create-database conn database)"
          "(create-database conn database force)" )
     :doc """
          Creates a new database. If force flag is true drops the database first
          if it exists. 
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/create-database conn "test")))
          """,
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/create-database conn "test" true)))
          """) 
     :see-also '(
          "jdbc-core/drop-database" ) }

  create-database 

  ([conn database]
    (create-database conn database false))

  ([conn database force]
    (assert (instance-of? :Connection conn))
    (assert (string? database))
    (assert (boolean? force))
    (when force
      (drop-database conn database))
    (try-with [st (create-statement conn)]
      (execute st (str "CREATE DATABASE " database)))))


(defn 
  ^{ :arglists '(
          "(drop-database conn database)"
          "(drop-database conn database force)" )
     :doc """
          Drops a database if it exists. 

          The force option will attempt to terminate all existing connections 
          to the database.

          *Note: The force option is supported for PostgreSQL only and disconnects
          all connections prior to dropping the database!*
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/drop-database conn "test")))
          """) 
     :see-also '(
          "jdbc-core/create-database" ) }

  drop-database

  ([conn database]
    (drop-database conn database false))
      
  ([conn database force]
    (assert (instance-of? :Connection conn))
    (assert (string? database))
    (assert (boolean? force))
    
    (try-with [st (create-statement conn)]
      (if (postgresql? conn)
        (execute st (str/format "DROP DATABASE IF EXISTS %s%s"
                                database
                                (if force " FORCE" "")))
        (if force
          (throw (ex :VncException """
                                   Dropping a database with force flag true is \
                                   only supported for PostgreSQL yet!
                                   """))
          (execute st (str/format "DROP DATABASE IF EXISTS %s" database)))))))


(defn 
  ^{ :arglists '(
          "(postgresql? conn)" )
     :doc """
          Returns true if 'conn' is a PostgreSQL connection else false.
          """ }

  postgresql? [conn]

  (assert (instance-of? :Connection conn))

  (let [db-meta (jdbc/db-meta-data conn)]
    (str/equals-ignore-case? "PostgreSQL" (:product-name db-meta))))




;; -----------------------------------------------------------------------------
;; Connection 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(closed? conn)" )
     :doc """
          Returns true the connections is closed else false.
          """ }

  closed? [conn]

  (assert (instance-of? :Connection conn))
  (. conn :isClosed))



;; -----------------------------------------------------------------------------
;; Transactions 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(tx-isolation conn)" )
     :doc """
          Returns transaction isolation level of the connection

          Levels:

            * `:tx-none`
            * `:tx-read-commited`
            * `:tx-read-uncommited`
            * `:tx-repeatable-read`
            * `:tx-serializable`
          """
     :examples '(
          """
          (jdbc-core/tx-isolation conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  tx-isolation [conn]

  (assert (instance-of? :Connection conn))

  (let [level  (. conn :getTransactionIsolation)]
    (get (map-invert tx-isolation-levels) level level)))


(defn 
  ^{ :arglists '(
          "(tx-isolation! conn level)" )
     :doc """
          Set the transaction isolation level for the connection

          Levels:
          
            * `:tx-none`
            * `:tx-read-commited`
            * `:tx-read-uncommited`
            * `:tx-repeatable-read`
            * `:tx-serializable`
          """
     :examples '(
          """
          (jdbc-core/tx-isolation! conn :tx-repeatable-read)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  tx-isolation! [conn level]

  (assert (instance-of? :Connection conn))
  (assert (or (long? level) (keyword? level)))
  (if (long? level)
    (. conn :setTransactionIsolation level)
    (if-let [l (get tx-isolation-levels level)]
      (. conn :setTransactionIsolation l)
      (throw (ex :VncException "Invalid Tx isolation level '~{level}'")))))


(defn 
  ^{ :arglists '(
          "(auto-commit? conn)" )
     :doc """
          Returns true if auto commit is enabled on the connection else false
          """
     :examples '(
          """
          (jdbc-core/auto-commit? conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  auto-commit? [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :getAutoCommit))


(defn 
  ^{ :arglists '(
          "(auto-commit! conn on)" )
     :doc """
          Activate/Deactivate auto commit on a connection
          """
     :examples '(
          """
          (jdbc-core/auto-commit! conn false)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  auto-commit! [conn on]
  
  (assert (instance-of? :Connection conn))
  (assert (boolean? on))
  (. conn :setAutoCommit on))


(defn 
    ^{ :arglists '(
          "(commit! conn)" )
     :doc """
          Commit the current transaction on the connection
          """
     :examples '(
          """
          (jdbc-core/auto-commit! conn false)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/rollback!" ) }

  commit! [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :commit))


(defn 
    ^{ :arglists '(
          "(rollback! conn)" )
     :doc """
          Rollback the current transaction on the connection
          """
     :examples '(
          """
          (jdbc-core/rollback! conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!" ) }

  rollback! [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :rollback))




;; -----------------------------------------------------------------------------
;; Statements 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(create-statement conn)" )
     :doc """
          Create a statement
          """
     :examples '(
          """
          (jdbc-core/create-statement conn)
          """) 
     :see-also '(
          "jdbc-core/prepare-statement" ) }

  create-statement [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :createStatement))


(defn 
  ^{ :arglists '(
          "(prepare-statement conn sql)" )
     :doc """
          Create a prepared statement
          """
     :examples '(
          """
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        ps   (jdbc/prepare-statement conn "INSERT INTO foo VALUES(?,?)")]
               (jdbc/ps-int 1 1I)
               (jdbc/ps-string 2 "Harry Potter")
               (jdbc/execute ps)))
          """) 
     :see-also '(
          "jdbc-core/create-statement" ) }

   prepare-statement [conn sql]
   
   (assert (instance-of? :Connection conn))
   (assert (string? sql))
   (. conn :prepareStatement sql))



;; -----------------------------------------------------------------------------
;; Execute queries 
;; -----------------------------------------------------------------------------

(defn execute 
  ([stmt]
    (assert (instance-of? :PreparedStatement stmt))
    (. stmt :execute)) 

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)]
        (. stmt :execute sql))
      (. conn-or-stmt :execute sql))))


(defn execute-query 
  ([stmt]
    (assert (instance-of? :PreparedStatement stmt))
    (try-with [rs (. stmt :executeQuery)]
      (collect-result-set)))

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)
                 rs   (. stmt :executeQuery sql)]
        (collect-result-set rs))
      (try-with [rs  (. conn-or-stmt :executeQuery sql)]
        (collect-result-set rs)))))
 

(defn execute-update 
  ([stmt]
    (assert (instance-of? :PreparedStatement stmt))
    (. stmt :executeUpdate))

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)]
        (. stmt :executeUpdate sql))
      (. conn-or-stmt :executeUpdate sql))))


(defn- collect-result-set [rs]
  (let [meta-data  (. rs :getMetaData)
        col-count  (. meta-data :getColumnCount)]
    (loop [rows []]
      (if (rs-next? rs)
        (recur (conj rows (row-values rs col-count)))
        { :col-names (col-names meta-data), :rows rows}))))


(defn- col-names [rs-meta-data]
  (let [count  (. rs-meta-data :getColumnCount)]
  (loop [names [], col 1]
    (if (<= col count)
      (let [name (. rs-meta-data :getColumnName col)]
        (recur (conj names name) (inc col)))
        names))))


(defn- row-values [rs col-count]
  (loop [values [], col 1]
    (if (<= col col-count)
      (let [val (map-value (. rs :getObject col))]  
        (recur (conj values val) (inc col)))
        values)))


(defn- map-value [val]
  (cond 
    (sql-date? val)  (convert-sql-date-to-local-date-time val)
    :else            val))


(defn- sql-date? [val]
  (instance-of? :java.sql.Date val))



;; -----------------------------------------------------------------------------
;; Prepared statement
;; -----------------------------------------------------------------------------

(defn rs-clear-parameters [ps]
  (assert (instance-of? :PreparedStatement ps))
  (. ps :clearParameters))

(defn rs-decimal [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (decimal? val)))
  (. ps :setBigDecimal (int idx) val))

(defn rs-boolean [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (boolean? val)))
  (. ps :setBoolean (int idx) val))

(defn rs-double [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (double? val)))
  (. ps :setDouble (int idx) val))

(defn rs-float [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (double? val)))
  (. ps :setFloat (int idx) val))

(defn rs-int [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (int? val) (long? val)))
  (. ps :setInt (int idx) (int val)))

(defn rs-long [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (int? val) (long? val)))
  (. ps :setLong (int idx) (long val)))

(defn rs-string [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (string? val)))
  (. ps :setString (int idx) val))

(defn rs-date [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (time/date? val) 
              (time/local-date-time? val)  (time/zoned-date-time? val)))
  (if (nil?)
    (. ps :setDate (int idx) nil)
    (->> (time/format val "yyyy-mm-dd")
         (. :java.sql.Date :valueOf)
         (. ps :setDate (int idx)))))

(defn rs-timestamp [ps idx val]
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (or (nil?) (time/date? val) 
              (time/local-date-time? val)  (time/zoned-date-time? val)))
  (cond 
    (nil?)        (. ps :setTimestamp (int idx) nil)
    (time/date?)  (->> (time/local-date-time val)
                       (. :java.sql.Timestamp :from)
                       (. ps :setTimestamp (int idx)))
    :else         (->> (. :java.sql.Timestamp :from val)
                       (. ps :setTimestamp (int idx)))))



;; -----------------------------------------------------------------------------
;; Result Set
;; -----------------------------------------------------------------------------

(defn rs-string [rs name-or-index]
  (. rs :getString name-or-index))


(defn rs-boolean [rs name-or-index]
  (. rs :getBoolean name-or-index))


(defn rs-date [rs name-or-index]
  (. rs :getDate name-or-index))


(defn rs-double [rs name-or-index]
  (. rs :getDouble name-or-index))


(defn rs-long [rs name-or-index]
  (. rs :getLong name-or-index))


(defn rs-int [rs name-or-index]
  (. rs :getInt name-or-index))


(defn rs-first? [rs]
  (. rs :first))


(defn rs-next? [rs]
  (. rs :next))



;; -----------------------------------------------------------------------------
;; Data Converter
;; -----------------------------------------------------------------------------

(defn convert-sql-date-to-local-date-time [d]
  (if (nil? d) nil (time/local-date-time d)))


(defn convert-sql-date-to-local-date [d]
  (if (nil? d) nil (time/local-date d)))



;; -----------------------------------------------------------------------------
;; ResultSet Data Renderer
;; -----------------------------------------------------------------------------

(defn render-query-result  
  ([data]
    (render-query-result data 80))

  ([data max-col-width]
    (let [min-col-width 3
          col-names     (:col-names data)
          rows          (:rows data)
          rows          (map (fn [r] (map (fn [v] (render-cell v)) r)) rows)
          widths        (col-widths col-names rows min-col-width max-col-width)
          headers       (map (fn [v] (hash-map :header { :text     (first v)
                                                         :align    :left
                                                         :overflow :newline }
                                              :width (second v)))
                            (map vector col-names widths)) ]
      (ascii-table/render headers rows :standard-database 0))))


(defn print-query-result [data]
  (println (render-query-result data)))


(defn- render-cell [v]
  (cond 
    (nil? v)                   "<null>"
    (string? v)                (str/truncate v 100 "...")
    (boolean? v)               (if v "true" "false")
    (char? v)                  (str v)
    (long? v)                  (str v)
    (int? v)                   (str (long v))
    (double? v)                (str v)
    (time/date? v)             (str (time/local-date-time v))
    (time/local-date? v)       (str v)
    (time/local-date-time? v)  (str v)
    (java-obj? v)              (let [clazz (class-name (class-of v))]
                                  (case clazz
                                    "org.postgresql.util.PGobject"  (str v)
                                    (str "[" clazz "]")))
    :else                      (str "[" (type v) "]")))


(defn- col-widths [col-names rows min-with max-width]
  (let [matrix (conj rows col-names)]
    (->> (map (fn [r] (map (fn [v] (if (nil? v) 0 (count (str v)))) r)) matrix)
         (transpose)
         (map #(apply max %))
         (map #(clamp % min-with max-width)))))


(defn- transpose [matrix]
  (apply map vector matrix))


(defn- PGobject? [v]
  (= "org.postgresql.util.PGobject" (class-name (class-of v))))



;; -----------------------------------------------------------------------------
;; Metadata
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(db-meta-data conn)" )
     :doc """
          List the meta data of a database
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/db-meta-data conn)))
          """) }

  db-meta-data [conn]

  (try-with [md  (. conn :getMetaData)]
    { :product-name     (. md :getDatabaseProductName)
      :product-version  (. md :getDatabaseProductVersion)
      :driver-name      (. md :getDriverName)
      :driver-version   (. md :getDriverVersion) } ))


(defn 
  ^{ :arglists '(
          "(db-features conn)" )
     :doc """
          List the database' features
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/db-features conn)))
          """) }

  db-meta-data [conn]

  (try-with [md  (. conn :getMetaData)]
    { :supports-full-outer-joins   (. md :supportsFullOuterJoins)
      :supports-stored-procedures  (. md :supportsStoredProcedures)
      :supports-transactions       (. md :supportsTransactions)
      :supports-savepoints         (. md :supportsSavepoints)
      :supports-batch-updates      (. md :supportsBatchUpdates) } ))


(defn 
  ^{ :arglists '(
          "(schemas conn)" )
     :doc """
          List the schemas of a database
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/schemas conn)))
          """) }

  schemas [conn]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getSchemas)]
    (loop [schemas []]
      (if (rs-next? rs)
        (recur (conj schemas { :schem   (rs-string rs "TABLE_SCHEM")
                               :catalog (rs-string rs "TABLE_CATALOG") }))
        schemas))))


(defn 
  ^{ :arglists '(
          "(tables conn)" )
     :doc """
          List the tables of a database
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")]
              (jdbc/tables conn)))
          """) }

  tables [conn]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getTables nil nil "%" ["TABLE"])]
    (loop [tables []]
      (if (rs-next? rs)
        (recur (conj tables (rs-string rs "TABLE_NAME")))
        tables))))


(defn 
  ^{ :arglists '(
          "(columns conn table)" )
     :doc """
          List the columns of a database table
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
              (jdbc/columns conn "users")))
          """) }

  columns [conn table]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getColumns nil nil table nil)]
    (loop [columns []]
      (if (rs-next? rs)
        (recur (conj columns { :name      (rs-string rs "COLUMN_NAME")
                               :size      (rs-string rs "COLUMN_SIZE")
                               :type      (type-map (rs-int rs "DATA_TYPE") :unknown)
                               :nullable? (rs-string rs "IS_NULLABLE")
                               :auto-inc? (rs-string rs "IS_AUTOINCREMENT") }))
        columns))))


(defonce type-map {
    (. :Types :ARRAY)                    :ARRAY
    (. :Types :BIGINT)                   :BIGINT
    (. :Types :BINARY)                   :BINARY
    (. :Types :BIT)                      :BIT
    (. :Types :BLOB)                     :BLOB
    (. :Types :BOOLEAN)                  :BOOLEAN
    (. :Types :CHAR)                     :CHAR
    (. :Types :CLOB)                     :CLOB
    (. :Types :DATALINK)                 :DATALINK
    (. :Types :DATE)                     :DATE
    (. :Types :DECIMAL)                  :DECIMAL
    (. :Types :DISTINCT)                 :DISTINCT
    (. :Types :DOUBLE)                   :DOUBLE
    (. :Types :FLOAT)                    :FLOAT
    (. :Types :INTEGER)                  :INTEGER
    (. :Types :JAVA_OBJECT)              :JAVA_OBJECT
    (. :Types :LONGNVARCHAR)             :LONGNVARCHAR
    (. :Types :LONGVARBINARY)            :LONGVARBINARY
    (. :Types :LONGVARCHAR)              :LONGVARCHAR
    (. :Types :NCHAR)                    :NCHAR
    (. :Types :NCLOB)                    :NCLOB
    (. :Types :NULL)                     :NULL
    (. :Types :NUMERIC)                  :NUMERIC
    (. :Types :NVARCHAR)                 :NVARCHAR
    (. :Types :OTHER)                    :AROTHERRAY
    (. :Types :REAL)                     :REAL
    (. :Types :REF)                      :REF
    (. :Types :REF_CURSOR)               :REF_CURSOR
    (. :Types :ROWID)                    :ROWID
    (. :Types :SMALLINT)                 :SMALLINT
    (. :Types :SQLXML)                   :SQLXML
    (. :Types :STRUCT)                   :STRUCT
    (. :Types :TIME_WITH_TIMEZONE)       :TIME_WITH_TIMEZONE
    (. :Types :TIMESTAMP)                :TIMESTAMP
    (. :Types :TIMESTAMP_WITH_TIMEZONE)  :TIMESTAMP_WITH_TIMEZONERAY
    (. :Types :TINYINT)                  :TINYINT
    (. :Types :VARBINARY)                :VARBINARY
    (. :Types :VARCHAR)                  :VARCHAR } )



(defonce tx-isolation-levels {
  ;; A constant indicating that transactions are not supported.
  :tx-none             (. :Connection :TRANSACTION_NONE)

  ;; A constant indicating that dirty reads are prevented; non-repeatable reads 
  ;; and phantom reads can occur.
  :tx-read-commited    (. :Connection :TRANSACTION_READ_COMMITTED)

  ;; A constant indicating that dirty reads, non-repeatable reads and phantom 
  ;; reads can occur.
  :tx-read-uncommited  (. :Connection :TRANSACTION_READ_UNCOMMITTED)

  ;; A constant indicating that dirty reads and non-repeatable reads are 
  ;; prevented; phantom reads can occur.
  :tx-repeatable-read  (. :Connection :TRANSACTION_REPEATABLE_READ)

  ;; A constant indicating that dirty reads, non-repeatable reads and phantom 
  ;; reads are prevented.
  :tx-serializable     (. :Connection :TRANSACTION_SERIALIZABLE) })

