;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2024 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; JDBC core utils

;;;; See: 
;;;; https://docs.oracle.com/javase/8/docs/api/java/sql/package-summary.html


(ns jdbc-core)

(load-module :ascii-table)


(import :java.sql.DriverManager)
(import :java.sql.Connection)
(import :java.sql.Statement)
(import :java.sql.PreparedStatement)
(import :java.sql.Types)
(import :java.sql.Clob)
(import :java.sql.Blob)



;; -----------------------------------------------------------------------------
;; Create / Drop database
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(create-database conn database)"
          "(create-database conn database force)" )
     :doc """
          Creates a new database. If force flag is true drops the database first
          if it exists. 
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/create-database conn "test")))
          """,
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/create-database conn "test" true)))
          """) 
     :see-also '(
          "jdbc-core/drop-database" ) }

  create-database 

  ([conn database]
    (create-database conn database false))

  ([conn database force]
    (assert (instance-of? :Connection conn))
    (assert (string? database))
    (assert (boolean? force))
    (when force
      (drop-database conn database))
    (try-with [st (create-statement conn)]
      (execute st (str "CREATE DATABASE " database)))))


(defn 
  ^{ :arglists '(
          "(drop-database conn database)"
          "(drop-database conn database force)" )
     :doc """
          Drops a database if it exists. 

          The force option will attempt to terminate all existing connections 
          to the database.

          *Note: The force option is supported for PostgreSQL only and disconnects
          all connections prior to dropping the database!*
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "pg" "pg")]
              (jdbc/drop-database conn "test")))
          """) 
     :see-also '(
          "jdbc-core/create-database" ) }

  drop-database

  ([conn database]
    (drop-database conn database false))
      
  ([conn database force]
    (assert (instance-of? :Connection conn))
    (assert (string? database))
    (assert (boolean? force))
    
    (try-with [st (create-statement conn)]
      (if (postgresql? conn)
        (execute st (str/format "DROP DATABASE IF EXISTS %s%s"
                                database
                                (if force " FORCE" "")))
        (if force
          (throw (ex :VncException """
                                   Dropping a database with force flag true is \
                                   only supported for PostgreSQL yet!
                                   """))
          (execute st (str/format "DROP DATABASE IF EXISTS %s" database)))))))


(defn 
  ^{ :arglists '(
          "(postgresql? conn)" )
     :doc """
          Returns true if 'conn' is a PostgreSQL connection else false.
          """ }

  postgresql? [conn]

  (assert (instance-of? :Connection conn))

  (let [db-meta (jdbc/db-meta-data conn)]
    (str/equals-ignore-case? "PostgreSQL" (:product-name db-meta))))




;; -----------------------------------------------------------------------------
;; Connection 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(closed? conn)" )
     :doc """
          Returns true the connections is closed else false.
          """ }

  closed? [conn]

  (assert (instance-of? :Connection conn))
  (. conn :isClosed))



;; -----------------------------------------------------------------------------
;; Transactions 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(tx-isolation conn)" )
     :doc """
          Returns transaction isolation level of the connection

          Levels:

            * `:tx-none`
            * `:tx-read-commited`
            * `:tx-read-uncommited`
            * `:tx-repeatable-read`
            * `:tx-serializable`
          """
     :examples '(
          """
          (jdbc-core/tx-isolation conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  tx-isolation [conn]

  (assert (instance-of? :Connection conn))

  (let [level  (. conn :getTransactionIsolation)]
    (get (map-invert tx-isolation-levels) level level)))


(defn 
  ^{ :arglists '(
          "(tx-isolation! conn level)" )
     :doc """
          Set the transaction isolation level for the connection

          Levels:
          
            * `:tx-none`
            * `:tx-read-commited`
            * `:tx-read-uncommited`
            * `:tx-repeatable-read`
            * `:tx-serializable`
          """
     :examples '(
          """
          (jdbc-core/tx-isolation! conn :tx-repeatable-read)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  tx-isolation! [conn level]

  (assert (instance-of? :Connection conn))
  (assert (or (long? level) (keyword? level)))
  (if (long? level)
    (. conn :setTransactionIsolation level)
    (if-let [l (get tx-isolation-levels level)]
      (. conn :setTransactionIsolation l)
      (throw (ex :VncException "Invalid Tx isolation level '~{level}'")))))


(defn 
  ^{ :arglists '(
          "(auto-commit? conn)" )
     :doc """
          Returns true if auto commit is enabled on the connection else false
          """
     :examples '(
          """
          (jdbc-core/auto-commit? conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  auto-commit? [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :getAutoCommit))


(defn 
  ^{ :arglists '(
          "(auto-commit! conn on)" )
     :doc """
          Activate/Deactivate auto commit on a connection
          """
     :examples '(
          """
          (jdbc-core/auto-commit! conn false)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/commit!"
          "jdbc-core/rollback!" ) }

  auto-commit! [conn on]
  
  (assert (instance-of? :Connection conn))
  (assert (boolean? on))
  (. conn :setAutoCommit on))


(defn 
    ^{ :arglists '(
          "(commit! conn)" )
     :doc """
          Commit the current transaction on the connection
          """
     :examples '(
          """
          (jdbc-core/auto-commit! conn false)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/rollback!" ) }

  commit! [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :commit))


(defn 
    ^{ :arglists '(
          "(rollback! conn)" )
     :doc """
          Rollback the current transaction on the connection
          """
     :examples '(
          """
          (jdbc-core/rollback! conn)
          """) 
     :see-also '(
          "jdbc-core/tx-isolation"
          "jdbc-core/tx-isolation!"
          "jdbc-core/auto-commit?"
          "jdbc-core/auto-commit!"
          "jdbc-core/commit!" ) }

  rollback! [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :rollback))




;; -----------------------------------------------------------------------------
;; Statements 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(create-statement conn)" )
     :doc """
          Create a statement
          """
     :examples '(
          """
          (jdbc-core/create-statement conn)
          """) 
     :see-also '(
          "jdbc-core/prepare-statement" ) }

  create-statement [conn]
  
  (assert (instance-of? :Connection conn))
  (. conn :createStatement))


(defn 
  ^{ :arglists '(
          "(prepare-statement conn sql)" )
     :doc """
          Create a prepared statement
          """
     :examples '(
          """
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        ps   (jdbc/prepare-statement conn "INSERT INTO foo VALUES(?,?)")]
               (jdbc/ps-int 1 1I)
               (jdbc/ps-string 2 "Harry Potter")
               (jdbc/execute ps)))
          """) 
     :see-also '(
          "jdbc-core/create-statement" ) }

   prepare-statement [conn sql]
   
   (assert (instance-of? :Connection conn))
   (assert (string? sql))
   (. conn :prepareStatement sql))



;; -----------------------------------------------------------------------------
;; Execute queries 
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(execute pstmt)"
          "(execute conn-or-stmt sql)" )
     :doc """
          Executes the SQL statement in prepared statement or executes an SQL
          statement on a JDBC statement or connection.
          """
     :examples '(
          """
          ;; using a prepared statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        ps   (jdbc/prepare-statement conn "INSERT INTO foo VALUES(1,?)")]
               (jdbc/ps-int 1 1I)
               (jdbc/ps-string 2 "Harry Potter")
               (jdbc/execute ps)))
          """,
          """
          ;; running an SQL statement on a connection (creates an implicit JDBC statement)
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")]
               (jdbc/execute conn "INSERT INTO foo VALUES(1, \"Harry Potter\")")))
          """,
          """
          ;; running an SQL statement on a JDBC statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        stmt (jdbc/create-statement conn)]
               (jdbc/execute stmt "INSERT INTO foo VALUES(1, \"Harry Potter\")")))
          """) 
     :see-also '(
          "jdbc-core/execute-query"
          "jdbc-core/execute-update" ) }

  execute 

  ([pstmt]
    (assert (instance-of? :PreparedStatement pstmt))
    (. pstmt :execute)) 

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)]
        (. stmt :execute sql))
      (. conn-or-stmt :execute sql))))


(defn 
  ^{ :arglists '(
          "(execute-query pstmt)"
          "(execute-query conn-or-stmt sql)" )
     :doc """
          Executes the SQL statement in prepared statement or executes an SQL
          statement on a JDBC statement or connection.

          Returns a parsed ResultSet as map with the column names and a vector
          of row values. 

          Row values may be of type:

          * string
          * boolean
          * int
          * long
          * double
          * decimal
          * :java.sql.Clob
          * :java.sql.Blob

          ```
          { :col-names ["name" "age"]
            :rows [ ["john" 29] 
                    ["mary" 32] ] }
          ```
          """
     :examples '(
          """
          ;; using a prepared statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        ps   (jdbc/prepare-statement conn "SELECT * FROM foo")]
                (jdbc/execute-query ps)))
          """,
          """
          ;; running an SQL statement on a connection (creates an implicit JDBC statement)
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")]
               (jdbc/execute conn "SELECT * FROM foo")))
          """,
          """
          ;; running an SQL statement on a JDBC statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        stmt (jdbc/create-statement conn)]
               (jdbc/execute stmt "SELECT * FROM foo")))
          """) 
     :see-also '(
          "jdbc-core/execute"
          "jdbc-core/execute-update" ) }

  execute-query 

  ([pstmt]
    (assert (instance-of? :PreparedStatement pstmt))
    (try-with [rs (. pstmt :executeQuery)]
      (collect-result-set)))

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)
                 rs   (. stmt :executeQuery sql)]
        (collect-result-set rs))
      (try-with [rs  (. conn-or-stmt :executeQuery sql)]
        (collect-result-set rs)))))
 

(defn 
  ^{ :arglists '(
          "(execute-update pstmt)"
          "(execute-update conn-or-stmt sql)" )
     :doc """
          Executes the SQL statement in prepared statement or executes an SQL
          statement on a JDBC statement or connection.

          Returns an integer value that reports the number of rows affected by 
          the SQL statement
          """
     :examples '(
          """
          ;; using a prepared statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        ps   (jdbc/prepare-statement conn "INSERT INTO foo VALUES(1,?)")]
               (jdbc/ps-int 1 1I)
               (jdbc/ps-string 2 "Harry Potter")
               (jdbc/execute-update ps)))
          """,
          """
          ;; running an SQL statement on a connection (creates an implicit JDBC statement)
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")]
               (jdbc/execute-update conn "INSERT INTO foo VALUES(1, \"Harry Potter\")")))
          """,
          """
          ;; running an SQL statement on a JDBC statement
          (do
             (load-module :jdbc-core ['jdbc-core :as 'jdbc])
             (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])

             (try-with [conn (jdbp/create-connection "localhost" 5432 "test" "pg" "pg")
                        stmt (jdbc/create-statement conn)]
               (jdbc/execute-update stmt "INSERT INTO foo VALUES(1, \"Harry Potter\")")))
          """) 
     :see-also '(
          "jdbc-core/execute"
          "jdbc-core/execute-query" ) }
  
  execute-update 

  ([pstmt]
    (assert (instance-of? :PreparedStatement pstmt))
    (. pstmt :executeUpdate))

  ([conn-or-stmt sql]
    (assert (or (instance-of? :Connection conn-or-stmt)
                (instance-of? :Statement conn-or-stmt)))
    (if (instance-of? :Connection conn-or-stmt)
      (try-with [stmt (create-statement conn-or-stmt)]
        (. stmt :executeUpdate sql))
      (. conn-or-stmt :executeUpdate sql))))


(defn- collect-result-set [rs]
  (let [meta-data  (. rs :getMetaData)
        col-count  (. meta-data :getColumnCount)]
    (loop [rows []]
      (if (rs-next! rs)
        (recur (conj rows (row-values rs col-count)))
        { :col-names (col-names meta-data), :rows rows}))))


(defn- col-names [rs-meta-data]
  (let [count  (. rs-meta-data :getColumnCount)]
  (loop [names [], col 1]
    (if (<= col count)
      (let [name (. rs-meta-data :getColumnName col)]
        (recur (conj names name) (inc col)))
        names))))


(defn- row-values [rs col-count]
  (loop [values [], col 1]
    (if (<= col col-count)
      (let [val (map-value (. rs :getObject col))]  
        (recur (conj values val) (inc col)))
        values)))


(defn- map-value [val]
  (cond 
    (sql-date? val)  (convert-sql-date-to-local-date-time val)
    :else            val))


(defn- sql-date? [val]
  (instance-of? :java.sql.Date val))



;; -----------------------------------------------------------------------------
;; Prepared statement
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(ps-clear-parameters ps)" )
     :doc """
          Clears the prepared statment parameter.
          """
     :examples '(
          "(jdbc-core/ps-clear-parameters ps)") 
     :see-also '(
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-clear-parameters [ps]

  (assert (instance-of? :PreparedStatement ps))
  (. ps :clearParameters))

(defn 
  ^{ :arglists '(
          "(ps-blob ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given blob value.

          The value may be a `bytebuf` or a `:java.io.InputStream`.
          """
     :examples '(
          "(jdbc-core/ps-decimal ps 1 (bytebuf [1 2 3]))"
          "(jdbc-core/ps-decimal ps 1 (io/bytebuf-in-stream (bytebuf [1 2 3])))") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-blob [ps idx val]

  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (bytebuf? val) (io/in-stream? val)))
  (cond 
    (nil? val)          (. ps :setBlob (int idx) nil)
    (bytebuf? val)      (. ps :setBlob (int idx) (io/bytebuf-in-stream val))
    (io/in-stream? val) (. ps :setBlob (int idx) val)))

(defn 
  ^{ :arglists '(
          "(ps-clob ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given clob value.

          The value may be a `string` or a `:java.io.Reader`.
          """
     :examples '(
          "(jdbc-core/ps-decimal ps 1 \"123456\")"
          "(jdbc-core/ps-decimal ps 1 (io/string-reader \"123456\"))" ) 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-clob [ps idx val]

  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (string? val) (io/reader? val)))
  (cond 
    (nil? val)        (. ps :setClob (int idx) nil)
    (string? val)     (. ps :setClob (int idx) (io/string-reader val))
    (io/reader? val)  (. ps :setClob (int idx) val)))

(defn 
  ^{ :arglists '(
          "(ps-decimal ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given decimal value.
          """
     :examples '(
          "(jdbc-core/ps-decimal ps 1 3.1415M)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-decimal [ps idx val]

  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (decimal? val)))
  (. ps :setBigDecimal (int idx) val))

(defn 
  ^{ :arglists '(
          "(ps-boolean ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given boolean value.
          """
     :examples '(
          "(jdbc-core/ps-boolean ps 1 true)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }
  
  ps-boolean [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (boolean? val)))
  (. ps :setBoolean (int idx) val))

(defn 
  ^{ :arglists '(
          "(ps-double ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given double value.
          """
     :examples '(
          "(jdbc-core/ps-double ps 1 1.24)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }
  
  ps-double [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (double? val)))
  (. ps :setDouble (int idx) val))

(defn 
  ^{ :arglists '(
          "(ps-float ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given double value.
          """
     :examples '(
          "(jdbc-core/ps-float ps 1 1.24)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }
  
  ps-float [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (double? val)))
  (. ps :setFloat (int idx) val))

(defn 
  ^{ :arglists '(
          "(ps-int ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given int value.
          """
     :examples '(
          "(jdbc-core/ps-int ps 1 10I)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-int [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (int? val) (long? val)))
  (. ps :setInt (int idx) (int val)))

(defn 
  ^{ :arglists '(
          "(ps-long ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given long value.
          """
     :examples '(
          "(jdbc-core/ps-long ps 1 10)") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-long [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (int? val) (long? val)))
  (. ps :setLong (int idx) (long val)))

(defn 
  ^{ :arglists '(
          "(ps-string ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given string value.
          """
     :examples '(
          "(jdbc-core/ps-string ps 1 \"abcdef\")") 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-date"
          "jdbc-core/ps-timestamp" ) }

  ps-string [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (string? val)))
  (. ps :setString (int idx) val))

(defn 
  ^{ :arglists '(
          "(ps-date ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given date value.
          """
     :examples '(
          "(jdbc-core/ps-date ps 1 (time/date))"
          "(jdbc-core/ps-date ps 1 (time/local-date 2020 1 1))"
          "(jdbc-core/ps-date ps 1 (time/local-date-time 2020 1 1 14 0 0))"
          "(jdbc-core/ps-date ps 1 (time/zoned-date-time \"UTC\" 2020 1 1 14 0 0))" ) 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-timestamp" ) }

  ps-date [ps idx val]

  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (time/date? val)  (time/local-date? val)
              (time/local-date-time? val)  (time/zoned-date-time? val)))
  (if (nil? val)
    (. ps :setDate (int idx) nil)
    (->> (time/format val "yyyy-mm-dd")
         (. :java.sql.Date :valueOf)
         (. ps :setDate (int idx)))))

(defn 
  ^{ :arglists '(
          "(ps-timestamp ps idx val)" )
     :doc """
          Sets the prepared statment parameter to the given timestamp value.
          """
     :examples '(
          "(jdbc-core/ps-timestamp ps 1 (time/date))"
          "(jdbc-core/ps-timestamp ps 1 (time/local-date 2020 1 1))"
          "(jdbc-core/ps-timestamp ps 1 (time/local-date-time 2020 1 1 14 0 0))"
          "(jdbc-core/ps-timestamp ps 1 (time/zoned-date-time \"UTC\" 2020 1 1 14 0 0))" ) 
     :see-also '(
          "jdbc-core/ps-clear-parameters"
          "jdbc-core/ps-blob"
          "jdbc-core/ps-clob"
          "jdbc-core/ps-decimal"
          "jdbc-core/ps-boolean"
          "jdbc-core/ps-double"
          "jdbc-core/ps-float"
          "jdbc-core/ps-int"
          "jdbc-core/ps-long"
          "jdbc-core/ps-string"
          "jdbc-core/ps-date" ) }
  
  ps-timestamp [ps idx val]
  
  (assert (instance-of? :PreparedStatement ps))
  (assert (or (int? idx) (long? idx)))
  (assert (pos? idx))
  (assert (or (nil? val) (time/date? val) 
              (time/local-date-time? val)  (time/zoned-date-time? val)))
  (cond 
    (nil? val)        (. ps :setTimestamp (int idx) nil)
    (time/date? val)  (->> (time/local-date-time val)
                           (. :java.sql.Timestamp :from)
                           (. ps :setTimestamp (int idx)))
    :else             (->> (. :java.sql.Timestamp :from val)
                           (. ps :setTimestamp (int idx)))))



;; -----------------------------------------------------------------------------
;; Result Set
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(rs-first! rs)" )
     :doc """
          Moves the cursor to the first row in this ResultSet object.

          Returns true if the cursor is on a valid row; false if there are no
          rows in the result set
          """
     :examples '(
          "(jdbc-core/rs-first! rs)" ) 
     :see-also '(
          "jdbc-core/rs-next!"
          "jdbc-core/rs-last!" ) }

  rs-first! [rs]

  (. rs :first))


(defn 
  ^{ :arglists '(
          "(rs-next! rs)" )
     :doc """
          Moves the cursor forward one row from its current position.
          A ResultSet cursor is initially positioned before the first row;
          the first call to the method next makes the first row the current
          row; the second call makes the second row the current row, and so on. 

          Returns true if the new current row is valid; false if there are no
          more rows
          """
     :examples '(
          "(jdbc-core/rs-next! rs)" ) 
     :see-also '(
          "jdbc-core/rs-first!"
          "jdbc-core/rs-last!" ) }

  rs-next! [rs]
  
  (. rs :next))


(defn 
  ^{ :arglists '(
          "(rs-last! rs)" )
     :doc """
          Moves the cursor to the last row in this ResultSet object.

          Returns true if the cursor is on a valid row; false if there are no
          rows in the result set
          """
     :examples '(
          "(jdbc-core/rs-last! rs)" ) 
     :see-also '(
          "jdbc-core/rs-first!"
          "jdbc-core/rs-next!" ) }

  rs-last! [rs]
  
  (. rs :last))


(defn rs-string [rs name-or-index]
  (. rs :getString name-or-index))


(defn rs-boolean [rs name-or-index]
  (. rs :getBoolean name-or-index))


(defn rs-date [rs name-or-index]
  (. rs :getDate name-or-index))


(defn rs-timestamp [rs name-or-index]
  (. rs :getTimestamp name-or-index))


(defn rs-double [rs name-or-index]
  (. rs :getDouble name-or-index))


(defn rs-long [rs name-or-index]
  (. rs :getLong name-or-index))


(defn rs-int [rs name-or-index]
  (. rs :getInt name-or-index))



;; -----------------------------------------------------------------------------
;; CLOB
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(clob? val)" )
     :doc """
          Returns true if val is a:java.sql.Clob
          """
     :examples '(
          "(jdbc-core/clob? v)" ) 
     :see-also '(
          "jdbc-core/clob-length"
          "jdbc-core/clob-reader" 
          "jdbc-core/clob-free") }

  clob? [val]

  (instance-of? :Clob val))


(defn 
  ^{ :arglists '(
          "(clob-length clob)" )
     :doc """
          Returns the length of a clob
          """
     :examples '(
          "(jdbc-core/clob-length vc" ) 
     :see-also '(
          "jdbc-core/clob?"
          "jdbc-core/clob-reader"
          "jdbc-core/clob-free" ) }

  clob-length [clob]

  (assert (instance-of? :Clob clob))
  (. clob :length))


(defn 
  ^{ :arglists '(
          "(clob-reader clob)" )
     :doc """
          Returns a :java.io.Reader to read the clob data
          """
     :examples '(
          "(jdbc-core/clob-reader c)" ) 
     :see-also '(
          "jdbc-core/clob?"
          "jdbc-core/clob-length"
          "jdbc-core/clob-free" ) }

  clob-reader [clob]

  (assert (instance-of? :Clob clob))
  (. clob :getCharacterStream))


(defn 
  ^{ :arglists '(
          "(clob-free clob)" )
     :doc """
          Frees the Clob object and releases the resources the resources that
          it holds.
          """
     :examples '(
          "(jdbc-core/clob-free c)" ) 
     :see-also '(
          "jdbc-core/clob?"
          "jdbc-core/clob-length"
          "jdbc-core/clob-reader" ) }

  clob-free [clob]

  (assert (instance-of? :Clob clob))
  (. clob :free))



;; -----------------------------------------------------------------------------
;; BLOB
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(blob? val)" )
     :doc """
          Returns true if val is a:java.sql.Blob
          """
     :examples '(
          "(jdbc-core/blob? v)" ) 
     :see-also '(
          "jdbc-core/blob-length"
          "jdbc-core/blob-in-stream"
          "jdbc-core/blob-bytebuf"
          "jdbc-core/blob-free" ) }

  blob? [val]

  (instance-of? :Blob val))


(defn 
  ^{ :arglists '(
          "(blob-length blob)" )
     :doc """
          Returns the length of a blob
          """
     :examples '(
          "(jdbc-core/blob-length b)" ) 
     :see-also '(
          "jdbc-core/blob?"
          "jdbc-core/blob-in-stream"
          "jdbc-core/blob-bytebuf"
          "jdbc-core/blob-free" ) }

  blob-length [blob]

  (assert (instance-of? :Blob blob))
  (. blob :length))


(defn 
  ^{ :arglists '(
          "(blob-in-stream blob)" )
     :doc """
          Returns a :java.io.InputStream to read the blob data
          """
     :examples '(
          "(jdbc-core/blob-in-stream b)" ) 
     :see-also '(
          "jdbc-core/blob?"
          "jdbc-core/blob-length"
          "jdbc-core/blob-bytebuf"
          "jdbc-core/blob-free" ) }

  blob-in-stream [blob]

  (assert (instance-of? :Blob blob))
  (. blob :getBinaryStream))


(defn 
  ^{ :arglists '(
          "(blob-bytebuf blob)" )
     :doc """
          Returns the blob data as a bytebuf
          """
     :examples '(
          "(jdbc-core/blob-bytebuf b)" ) 
     :see-also '(
          "jdbc-core/blob?"
          "jdbc-core/blob-length"
          "jdbc-core/blob-in-stream"
          "jdbc-core/blob-free" ) }

  blob-bytebuf [blob]

  (assert (instance-of? :Blob blob))
  (. blob :getBytes 0 (. blob :length)))


(defn 
  ^{ :arglists '(
          "(blob-free blob)" )
     :doc """
          Frees the Blob object and releases the resources the resources that
          it holds.
          """
     :examples '(
          "(jdbc-core/blob-free b)" ) 
     :see-also '(
          "jdbc-core/blob?"
          "jdbc-core/blob-length"
          "jdbc-core/blob-in-stream"
          "jdbc-core/blob-bytebuf" ) }

  blob-free [blob]

  (assert (instance-of? :Blob blob))
  (. blob :free))



;; -----------------------------------------------------------------------------
;; Data Converter
;; -----------------------------------------------------------------------------

(defn convert-sql-date-to-local-date-time [d]
  (if (nil? d) nil (time/local-date-time d)))


(defn convert-sql-date-to-local-date [d]
  (if (nil? d) nil (time/local-date d)))



;; -----------------------------------------------------------------------------
;; ResultSet Data Renderer
;; -----------------------------------------------------------------------------

(defn render-query-result  
  ([data]
    (render-query-result data 80))

  ([data max-col-width]
    (let [min-col-width 3
          col-names     (:col-names data)
          rows          (:rows data)
          rows          (map (fn [r] (map (fn [v] (render-cell v)) r)) rows)
          widths        (col-widths col-names rows min-col-width max-col-width)
          headers       (map (fn [v] (hash-map :header { :text     (first v)
                                                         :align    :left
                                                         :overflow :newline }
                                              :width (second v)))
                            (map vector col-names widths)) ]
      (ascii-table/render headers rows :standard-database 0))))


(defn print-query-result [data]
  (println (render-query-result data)))


(defn- render-cell [v]
  (cond 
    (nil? v)                   "<null>"
    (string? v)                (str/truncate v 100 "...")
    (boolean? v)               (if v "true" "false")
    (char? v)                  (str v)
    (long? v)                  (str v)
    (int? v)                   (str (long v))
    (double? v)                (str v)
    (time/date? v)             (str (time/local-date-time v))
    (time/local-date? v)       (str v)
    (time/local-date-time? v)  (str v)
    (java-obj? v)              (let [clazz (class-name (class-of v))]
                                  (case clazz
                                    "org.postgresql.util.PGobject"  (str v)
                                    (str "[" clazz "]")))
    :else                      (str "[" (type v) "]")))


(defn- col-widths [col-names rows min-with max-width]
  (let [matrix (conj rows col-names)]
    (->> (map (fn [r] (map (fn [v] (if (nil? v) 0 (count (str v)))) r)) matrix)
         (transpose)
         (map #(apply max %))
         (map #(clamp % min-with max-width)))))


(defn- transpose [matrix]
  (apply map vector matrix))


(defn- PGobject? [v]
  (= "org.postgresql.util.PGobject" (class-name (class-of v))))



;; -----------------------------------------------------------------------------
;; Metadata
;; -----------------------------------------------------------------------------

(defn 
  ^{ :arglists '(
          "(meta-data conn)" )
     :doc """
          List the meta data of a database

          Example PostgreSQL meta data:

          ```
          { :product-name "PostgreSQL" 
            :driver-name "PostgreSQL JDBC Driver"
            :driver-version "42.7.3" 
            :product-version "16.2 (Debian 16.2-1.pgdg120+2)" }
          ```
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/meta-data conn)))
          """) }

  meta-data [conn]

  (try-with [md  (. conn :getMetaData)]
    { :product-name     (. md :getDatabaseProductName)
      :product-version  (. md :getDatabaseProductVersion)
      :driver-name      (. md :getDriverName)
      :driver-version   (. md :getDriverVersion) } ))


(defn 
  ^{ :arglists '(
          "(features conn)" )
     :doc """
          List the database' features

          Example PostgreSQL features:
          
          ```
          { :supports-stored-procedures true 
            :supports-full-outer-joins true 
            :supports-savepoints true 
            :supports-batch-updates true 
            :supports-transactions true }
          ```
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/features conn)))
          """) }

  features [conn]

  (try-with [md  (. conn :getMetaData)]
    { :supports-full-outer-joins   (. md :supportsFullOuterJoins)
      :supports-stored-procedures  (. md :supportsStoredProcedures)
      :supports-transactions       (. md :supportsTransactions)
      :supports-savepoints         (. md :supportsSavepoints)
      :supports-batch-updates      (. md :supportsBatchUpdates) } ))


(defn 
  ^{ :arglists '(
          "(schemas conn)" )
     :doc """
          List the schemas of a database

          Example PostgreSQL schemas:
          
          ```
          [ { :schem "information_schema" 
              :catalog nil
            } 
            { :schem "pg_catalog" 
              :catalog nil
            }
            { :schem "public" 
              :catalog nil 
            } ]
          ```
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "pg" "pg")]
              (jdbc/schemas conn)))
          """) }

  schemas [conn]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getSchemas)]
    (loop [schemas []]
      (if (rs-next! rs)
        (recur (conj schemas { :schem   (rs-string rs "TABLE_SCHEM")
                               :catalog (rs-string rs "TABLE_CATALOG") }))
        schemas))))


(defn 
  ^{ :arglists '(
          "(tables conn)" )
     :doc """
          List the tables of a database

          Example PostgreSQL Chinook database:
          
          ```
          [ "album" 
            "artist" 
            "customer" 
            "employee" 
            "genre" 
            "invoice" 
            "invoice_line" 
            "media_type" 
            "playlist" 
            "playlist_track" 
            "track" ]
            ```
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "chinook" "pg" "pg")]
              (jdbc/tables conn)))
          """) }

  tables [conn]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getTables nil nil "%" ["TABLE"])]
    (loop [tables []]
      (if (rs-next! rs)
        (recur (conj tables (rs-string rs "TABLE_NAME")))
        tables))))


(defn 
  ^{ :arglists '(
          "(columns conn table)" )
     :doc """
          List the columns of a database table

          Example PostgreSQL Chinook database "genre" table:
          
          ```
          [ { :name "genre_id" 
              :type :INTEGER 
              :size "10" 
              :nullable? "NO" 
              :auto-inc? "YES" } 
            { :name "name" 
              :type :VARCHAR 
              :size "120"
              :nullable? "YES" 
              :auto-inc? "NO" } ]
          ```
          """
     :examples '(
          """
          (do
            (load-module :jdbc-core ['jdbc-core :as 'jdbc])
            (load-module :jdbc-postgresql ['jdbc-postgresql :as 'jdbp])
            (try-with [conn (jdbp/create-connection "localhost" 5432 "chinook" "pg" "pg")
              (jdbc/columns conn "genre")))
          """) }

  columns [conn table]

  (try-with [md  (. conn :getMetaData)
             rs  (. md :getColumns nil nil table nil)]
    (loop [columns []]
      (if (rs-next! rs)
        (recur (conj columns { :name      (rs-string rs "COLUMN_NAME")
                               :size      (rs-string rs "COLUMN_SIZE")
                               :type      (type-map (rs-int rs "DATA_TYPE") :unknown)
                               :nullable? (rs-string rs "IS_NULLABLE")
                               :auto-inc? (rs-string rs "IS_AUTOINCREMENT") }))
        columns))))


(defonce type-map {
    (. :Types :ARRAY)                    :ARRAY
    (. :Types :BIGINT)                   :BIGINT
    (. :Types :BINARY)                   :BINARY
    (. :Types :BIT)                      :BIT
    (. :Types :BLOB)                     :BLOB
    (. :Types :BOOLEAN)                  :BOOLEAN
    (. :Types :CHAR)                     :CHAR
    (. :Types :CLOB)                     :CLOB
    (. :Types :DATALINK)                 :DATALINK
    (. :Types :DATE)                     :DATE
    (. :Types :DECIMAL)                  :DECIMAL
    (. :Types :DISTINCT)                 :DISTINCT
    (. :Types :DOUBLE)                   :DOUBLE
    (. :Types :FLOAT)                    :FLOAT
    (. :Types :INTEGER)                  :INTEGER
    (. :Types :JAVA_OBJECT)              :JAVA_OBJECT
    (. :Types :LONGNVARCHAR)             :LONGNVARCHAR
    (. :Types :LONGVARBINARY)            :LONGVARBINARY
    (. :Types :LONGVARCHAR)              :LONGVARCHAR
    (. :Types :NCHAR)                    :NCHAR
    (. :Types :NCLOB)                    :NCLOB
    (. :Types :NULL)                     :NULL
    (. :Types :NUMERIC)                  :NUMERIC
    (. :Types :NVARCHAR)                 :NVARCHAR
    (. :Types :OTHER)                    :AROTHERRAY
    (. :Types :REAL)                     :REAL
    (. :Types :REF)                      :REF
    (. :Types :REF_CURSOR)               :REF_CURSOR
    (. :Types :ROWID)                    :ROWID
    (. :Types :SMALLINT)                 :SMALLINT
    (. :Types :SQLXML)                   :SQLXML
    (. :Types :STRUCT)                   :STRUCT
    (. :Types :TIME_WITH_TIMEZONE)       :TIME_WITH_TIMEZONE
    (. :Types :TIMESTAMP)                :TIMESTAMP
    (. :Types :TIMESTAMP_WITH_TIMEZONE)  :TIMESTAMP_WITH_TIMEZONERAY
    (. :Types :TINYINT)                  :TINYINT
    (. :Types :VARBINARY)                :VARBINARY
    (. :Types :VARCHAR)                  :VARCHAR } )



(defonce tx-isolation-levels {
  ;; A constant indicating that transactions are not supported.
  :tx-none             (. :Connection :TRANSACTION_NONE)

  ;; A constant indicating that dirty reads are prevented; non-repeatable reads 
  ;; and phantom reads can occur.
  :tx-read-commited    (. :Connection :TRANSACTION_READ_COMMITTED)

  ;; A constant indicating that dirty reads, non-repeatable reads and phantom 
  ;; reads can occur.
  :tx-read-uncommited  (. :Connection :TRANSACTION_READ_UNCOMMITTED)

  ;; A constant indicating that dirty reads and non-repeatable reads are 
  ;; prevented; phantom reads can occur.
  :tx-repeatable-read  (. :Connection :TRANSACTION_REPEATABLE_READ)

  ;; A constant indicating that dirty reads, non-repeatable reads and phantom 
  ;; reads are prevented.
  :tx-serializable     (. :Connection :TRANSACTION_SERIALIZABLE) })

