;;;;   __    __         _
;;;;   \ \  / /__ _ __ (_) ___ ___
;;;;    \ \/ / _ \ '_ \| |/ __/ _ \
;;;;     \  /  __/ | | | | (_|  __/
;;;;      \/ \___|_| |_|_|\___\___|
;;;;
;;;;
;;;; Copyright 2017-2025 Venice
;;;;
;;;; Licensed under the Apache License, Version 2.0 (the "License");
;;;; you may not use this file except in compliance with the License.
;;;; You may obtain a copy of the License at
;;;;
;;;;     http://www.apache.org/licenses/LICENSE-2.0
;;;;
;;;; Unless required by applicable law or agreed to in writing, software
;;;; distributed under the License is distributed on an "AS IS" BASIS,
;;;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;;;; See the License for the specific language governing permissions and
;;;; limitations under the License.

;;;; Aviron ClamAV client file watcher queue

(ns aviron-queue)

(import :org.repackage.com.github.jlangch.aviron.filewatcher.FileWatcherQueue)

(defn 
  ^{ :arglists '(
          "(create)"
          "(create capacity)")
     :doc """
          Create a new file queue with either the default capacity or an 
          explicit capacity.

          The file queue is buffering file watching events. It asynchronously 
          decouples the event producing file watcher from the event consuming 
          AV scanner client.
 
          The queue never blocks and never grows beyond limits to protect the 
          system! Therefore the queue is non blocking and has a fix capacity. 
          As a consequence it must discard old events if overrun. 

          File watchers (like the Java `WatchService` or the `fswatch` tool) 
          have the same behavior. If they get overrun with file change events 
          they discard events and signal it by sending an 'OVERFLOW' event to 
          their clients.
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (aviron-queue/create))
          """,
          """
          (do
            (load-module :aviron)
            (aviron-queue/create 5000))
          """)
     :see-also '(
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  create 
  ([]
    (. :FileWatcherQueue :new))
  ([capacity]
    { :pre [(long? capacity) (pos? capacity)] }
    (. :FileWatcherQueue :new capacity)))


(defn 
  ^{ :arglists '(
          "(capacity queue)")
     :doc """
          Returns the capacity of the file queue
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/capacity q)))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  capacity [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (long (. queue :capacity)))


(defn 
  ^{ :arglists '(
          "(empty? queue)")
     :doc """
          Returns `true` if the file queue is empty else `false`
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/empty? q)))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  empty? [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (. queue :isEmpty))


(defn 
  ^{ :arglists '(
          "(size queue)")
     :doc """
          Returns the size of the file queue
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/size q)))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  size [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (long (. queue :size)))


(defn 
  ^{ :arglists '(
          "(clear queue)")
     :doc """
          Clears the file queue
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/clear q)))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  clear [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (. queue :clear))


(defn 
  ^{ :arglists '(
          "(remove queue file)")
     :doc """
          Removes a file form the queue.
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (aviron-queue/push q (io/file "/data/c.txt"))
              (aviron-queue/remove q (io/file "/data/b.txt"))))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/push"
          "aviron-queue/pop" ) }

  remove [queue file] 

  { :pre [(instance-of? :FileWatcherQueue queue)
          (io/file? file)] }
  (. queue :remove file))


(defn 
  ^{ :arglists '(
          "(push queue file)")
     :doc """
          Push a new file to the tail of the queue

          Whenever pushing a file to a full queue the queue's head element is
          discarded in favor of pushing the new file. The overflow count is 
          incremented in this case.
 
          The queue never blocks and never grows beyond limits to protect the 
          system! Therefore the queue is non blocking and has a fix capacity. 
          As a consequence it must discard old events if overrun. 
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (println (aviron-queue/pop q))
              (println (aviron-queue/pop q))))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/pop" ) }

  push [queue file] 

  { :pre [(instance-of? :FileWatcherQueue queue)
          (io/file? file)] }
  (. queue :push file))


(defn 
  ^{ :arglists '(
          "(pop queue)",
          "(pop queue n)",
          "(pop queue n existing-files-only)")
     :doc """
          Pops the next or n next files from the head of the queue.

          If 'existing-files-only' is `true` discards any queue head files that
          are not existing.
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (println (aviron-queue/pop q))
              (println (aviron-queue/pop q))
              (println (aviron-queue/pop q))))
          """,
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (aviron-queue/push q (io/file "/data/c.txt"))
              (println (aviron-queue/pop q 5))))
          """,
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (aviron-queue/push q (io/file "/data/c.txt"))
              (println (aviron-queue/pop q 5 true))))
          """)

     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/push" ) }

  pop 

  ([queue] 
    { :pre [(instance-of? :FileWatcherQueue queue)] }
    (. queue :pop))

  ([queue n]
    { :pre [(instance-of? :FileWatcherQueue queue)
            (long? n) (pos? n)] }
    (into [] (. queue :pop n)))

  ([queue n existing-files-only]
    { :pre [(instance-of? :FileWatcherQueue queue)
            (long? n) (pos? n)
            (boolean? existing-files-only)] }
    (into [] (. queue :pop n existing-files-only))))


(defn 
  ^{ :arglists '(
          "(overflow-count queue)")
     :doc """
          Returns the overflow event count.

          Whenever pushing a file to a full queue the queue's head element is 
          discarded in favor of pushing the new file. The overflow count is 
          incremented in this case.
 
          The queue never blocks and never grows beyond limits to protect the 
          system! Therefore the queue is non blocking and has a fix capacity. 
          As a consequence it must discard old events if overrun. 
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create 5)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (aviron-queue/push q (io/file "/data/d.txt"))
              (aviron-queue/push q (io/file "/data/e.txt"))
              (aviron-queue/push q (io/file "/data/f.txt"))
              ;; overflow event (the head element "/data/a.txt" is discarded)
              (aviron-queue/push q (io/file "/data/g.txt"))
              (println (aviron-queue/overflow-count q))))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/pop" ) }

  overflow-count [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (. queue :overflowCount))


(defn 
  ^{ :arglists '(
          "(overflow-reset queue)")
     :doc """
          Resets the overflow count
          """
     :examples '(
          """
          (do
            (load-module :aviron)
            (let [q (aviron-queue/create 5)]
              (aviron-queue/push q (io/file "/data/a.txt"))
              (aviron-queue/push q (io/file "/data/b.txt"))
              (aviron-queue/push q (io/file "/data/d.txt"))
              (aviron-queue/push q (io/file "/data/e.txt"))
              (aviron-queue/push q (io/file "/data/f.txt"))
              ;; overflow event (the head element "/data/a.txt" is discarded)
              (aviron-queue/push q (io/file "/data/g.txt")) 
              (println (aviron-queue/overflow-count q))
              (println (aviron-queue/overflow-reset q))
              (println (aviron-queue/overflow-count q))))
          """)
     :see-also '(
          "aviron-queue/create"
          "aviron-queue/capacity"
          "aviron-queue/empty?"
          "aviron-queue/size"
          "aviron-queue/clear"
          "aviron-queue/remove"
          "aviron-queue/pop" ) }

  overflow-reset [queue] 

  { :pre [(instance-of? :FileWatcherQueue queue)] }
  (. queue :resetOverflowCount))
